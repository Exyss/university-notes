\documentclass[a4paper, 12pt]{report}

\usepackage[dvipsnames]{xcolor}

%%%%%%%%%%%%%%%%
% Set Variables %
%%%%%%%%%%%%%%%%

\def\useItalian{1}  % 1 = Italian, 0 = English

\def\courseName{Progettazione di Sistemi Digitali}

\def\coursePrerequisites{Nessuno}

\def\book{\curlyquotes{Digital Design and Computer Architecture - ARM Edition}, S. Harris, D. Harris}

\def\authorName{Simone Bianco}
\def\email{bianco.simone@outlook.it}
\def\github{https://github.com/Exyss/university-notes}
\def\linkedin{https://www.linkedin.com/in/simone-bianco}


%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage{../../../packages/Nyx/nyx-packages}
\usepackage{../../../packages/Nyx/nyx-styles}
\usepackage{../../../packages/Nyx/nyx-frames}
\usepackage{../../../packages/Nyx/nyx-macros}
\usepackage{../../../packages/Nyx/nyx-title}
\usepackage{../../../packages/Nyx/nyx-intro}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{../../../packages/Nyx/logo.png}

\if\useItalian1
    \institute{\curlyquotes{\hspace{0.25mm}Sapienza} Università di Roma}
    \faculty{Ingegneria dell'Informazione,\\Informatica e Statistica}
    \department{Dipartimento di Informatica}
    \ifdefined\book
        \subtitle{Appunti integrati con il libro \book}
    \fi
    \author{\textit{Autore}\\\authorName}
\else
    \institute{\curlyquotes{\hspace{0.25mm}Sapienza} University of Rome}
    \faculty{Faculty of Information Engineering,\\Informatics and Statistics}
    \department{Department of Computer Science}
    \ifdefined\book
        \subtitle{Lecture notes integrated with the book \book}
    \fi
    \author{\textit{Author}\\\authorName}
\fi


\title{\courseName}
\date{\today}

% \supervisor{Linus \textsc{Torvalds}}
% \context{Well, I was bored\ldots}

\definecolor{DarkGreen}{HTML}{24881d}

%%%%%%%%%%%%%%
% Components %
%%%%%%%%%%%%%%

\ctikzset{multipoles/flipflop/clock
wedge size=0.35}

\tikzset{mux 2by1/.style={muxdemux, muxdemux def={Lh=4, Rh=3, NL=2, NT=1, NB=0, w=2, square pins=1}}}

\tikzset{mux 4by1/.style={muxdemux, muxdemux def={Lh=4.5, Rh=3, NL=4, NT=2, NB=0, w=2, square pins=1}}}

\tikzset{dec 2by4/.style={muxdemux, muxdemux def={Lh=4.5, Rh=4.5, NL=2, NT=0, NB=0, NR=4, w=3, square pins=1}}}

\tikzset{latch SR/.style={flipflop, flipflop def={t1=R, t3=S, t6=Q, t4=\ctikztextnot{Q}}}}

\tikzset{latch D/.style={flipflop, flipflop def={t2=D, t6=Q, tu=CLK, t4=\ctikztextnot{Q}}}}

\tikzset{flipflop D/.style={flipflop, flipflop def={t2=D, t6=Q, cu=1, t4=\ctikztextnot{Q}}}}

\tikzset{small-FF/.style={flipflop, flipflop def={t2={\,}, t5={\,}, cu=1, width=0.75}}}

\tikzset{small-FF R/.style={flipflop, flipflop def={t2={\,}, t5={\,}, cu=1, td=R, width=0.75}}}

\tikzset{small-FF R 2-2/.style={flipflop, flipflop def={t1={\,}, t3={\,}, t6={\,}, t4={\,}, cu=1, td=R, width=0.75}}}

\tikzset{flipflop enabled/.style={flipflop, flipflop def={t2=D, t6=Q, cu=1, td=ENABLE, t4=\ctikztextnot{Q}}}}

\tikzset{flipflop resettable/.style={flipflop, flipflop def={t2=D, t6=Q, cu=1, td=RESET, t4=\ctikztextnot{Q}}}}

\tikzset{flipflop settable/.style={flipflop, flipflop def={t2=D, t6=Q, cu=1, td=SET, t4=\ctikztextnot{Q}}}}

\tikzset{square-1-1/.style={muxdemux, muxdemux def={Lh=3, Rh=3, NL=1, NT=0, NB=0, NR=1, w=3, square pins=1}}}

\tikzset{square-2-1/.style={muxdemux, muxdemux def={Lh=3, Rh=3, NL=2, NT=0, NB=0, NR=1, w=3, square pins=1}}}

\tikzset{half-adder/.style={muxdemux, muxdemux def={Lh=4.5, Rh=3, NL=2, NT=0, NB=1, inset w=1, inset Lh=0.5, w=2, square pins=1}, rotate=-90}}

\tikzset{full-adder/.style={muxdemux, muxdemux def={Lh=4.5, Rh=3, NL=2, NT=1, NB=1, inset w=1, inset Lh=0.5, w=2, square pins=1}, rotate=-90}}

\tikzset{subtractor/.style={muxdemux, muxdemux def={Lh=4.5, Rh=3, NL=2, NT=0, NB=0, inset w=1, inset Lh=0.5, w=2, square pins=1}, rotate=-90}}

\tikzset{comparator/.style={muxdemux, muxdemux def={Lh=4.5, Rh=4.5, NL=2, NT=0, NB=0, w=2, square pins=1}, rotate=-90}}

\tikzset{shifter/.style={muxdemux, muxdemux def={Lh=3, Rh=3, NL=1, NR=1, NT=1, NB=0, w=3, square pins=1}}}

\tikzset{counter/.style={flipflop, flipflop def={t5=Q, cu=1, td=RESET}}}

\tikzset{shift register/.style={flipflop, flipflop def={t2={$S_{in}$}, t6=Q, cu=1, t4={$S_{out}$}}}}

\tikzset{bit-cell/.style={muxdemux, muxdemux def={Lh=2, Rh=2, NL=0, NT=1, NB=0, NR=1, w=2.5, square pins=1}}}

\tikzset{LUT/.style={muxdemux, muxdemux def={Lh=3, Rh=3, NL=4, NT=0, NB=0, NR=1, w=3, square pins=1}}}

\tikzset{LUT short/.style={muxdemux, muxdemux def={Lh=3, Rh=3, NL=1, NT=0, NB=0, NR=1, w=3, square pins=1}}}

\tikzset{ALU/.style={muxdemux, muxdemux def={Lh=5, Rh=3, NL=2, NT=1, NB=0, inset w=0.75, inset Lh=2, inset Rh=1, w=2, square pins=1}, rotate=-90}}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
    \maketitle

    % The following style changes are valid only inside this scope 
    {
        \hypersetup{allcolors=black}
        \fancypagestyle{plain}{%
        \fancyhead{}        % clear all header fields
        \fancyfoot{}        % clear all header fields
        \fancyfoot[C]{\thepage}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}}

        \romantableofcontents
    }

    \introduction

    %%%%%%%%%%%%%%%%%%%%%

    \chapter{Sistema numerico binario}
    
    \section{Numeri binari naturali} \label{SistemaBinario}
    
    Nella maggior parte dei casi, nella vita reale siamo abituati a contare elementi e ad eseguire calcoli matematici in \textbf{decimale}, utilizzando l'insieme di numeri 0, 1, 2, ..., 9. Per poter rappresentare i numeri più grandi di questi, abbiamo instaurato un \textbf{sistema posizionale} dove ad ogni \textit{colonna} ha un valore 10 volte più grande della precedente. Dunque, da destra a sinistra, le colonne del sistema decimale assumono il valore della cifra rappresentata moltiplicata per una \textit{potenza di 10}, come nel seguente esempio:
    
    \begin{center}
        \includegraphics{resources/images/chapter_1/decimal_system.png}
    \end{center}
    
    Abbiamo quindi definito le caratteristiche di un sistema numerico in \textbf{base 10} (che indicheremo con un 10 al di sotto del numero rappresentato). Utilizzando le stesse caratteristiche, possiamo definire dei sistemi numerici in \textit{base n}, dove ogni colonna assume un valore \textit{n} volte più grande della precedente.
    
    In particolare, il sistema numerico con cui lavorano i microprocessori è il sistema in \textbf{base 2}. L'impiego di questo sistema numerico, seppur di difficile utilizzo per noi umani, è estremamente conveniente per i sistemi digitali, poiché abbiamo solo due cifre disponibili: lo \textbf{0} e l'\textbf{1}. Traducendo ciò in termini di circuiti elettronici, è possibile utilizzare queste uniche due cifre per rappresentare gli unici due stati che un componente può assumere: \textit{acceso} (dunque con un passaggio di corrente al suo interno, rappresentato con il numero 1) o \textit{spento} (senza passaggio di corrente, rappresentato con il numero 0).
    
    \newpage
    
    Seguendo le caratteristiche definite precedentemente per il sistema numerico decimale, vediamo la rappresentazione di un numero in sistema binario:
    
    \begin{center}
        \includegraphics{resources/images/chapter_1/binary_system.png}
    \end{center}
    
    Per facilitare le conversioni tra i due sistemi che effettueremo in seguito, possiamo tabellare le potenze di 2 più comuni:
    
    
    \begin{center}
        \begin{tabular}{ c | c }
            \hline
            Potenze & Valore decimale \\
            \hline
            $2^{-5}$ & 0.03125 \\ 
            $2^{-4}$ & 0.0625 \\ 
            $2^{-3}$ & 0.125 \\ 
            $2^{-2}$ & 0.25 \\ 
            $2^{-1}$ & 0.5 \\ 
            $2^0$ & 1 \\ 
            $2^1$ & 2 \\
            $2^2$ & 4 \\ 
        \end{tabular}
        \quad\quad
        \begin{tabular}{ c | c }
            \hline
            Potenze & Valore decimale \\
            \hline
            $2^3$ & 8 \\ 
            $2^4$ & 16 \\ 
            $2^5$ & 32 \\ 
            $2^6$ & 64 \\ 
            $2^7$ & 128 \\
            $2^8$ & 256 \\ 
            $2^9$ & 512 \\ 
            $2^{10}$ & 1024 \\
        \end{tabular}
    \end{center}
    
    \subsection{Conversioni, Unità di misura e Sistema esadecimale}
    
    \subsubsection{Conversione da Binario a Decimale}
    
    Per poter convertire un numero binario in uno decimale, il procedimento è molto semplice: partendo dalla cifra più a destra, \textbf{moltiplichiamo} ogni colonna con una \textbf{potenza di 2}, incrementando l'elevamento di 1 ad ogni passaggio, partendo da 0. Infine, \textbf{sommeremo} tutti i valori precedentemente calcolati per ottenere il numero decimale equivalente.
    
    Per comprendere meglio, riprendiamo l'esempio di numero binario riportato precedentemente, $10110_2$.
    Partendo dalla cifra più a destra, numeriamo i valori delle potenze corrispondenti ad ogni colonna:
    
    \begin{itemize}
        \item 1° cifra più a destra (0) $\Rightarrow$ moltiplico per $2^0 \Rightarrow 0 \cdot 2^0$
        \item 2° cifra più a destra (1) $\Rightarrow$ moltiplico per $ 2^1  \Rightarrow 1 \cdot 2^1$
        \item 3° cifra più a destra (1) $\Rightarrow$ moltiplico per $ 2^2  \Rightarrow 1 \cdot 2^2$
        \item 4° cifra più a destra (0) $\Rightarrow$ moltiplico per $ 2^3  \Rightarrow 0 \cdot 2^3$
        \item 5° cifra più a destra (1) $\Rightarrow$ moltiplico per $ 2^4  \Rightarrow 1 \cdot 2^4$
    \end{itemize}
    
    \newpage

    Una volta calcolati i valori assunti da ogni colonna, non ci resta che sommarli per ottenere il numero in base decimale:
    
    \[ 10110_2 = 0 \cdot 2^0 + 1 \cdot 2^1 + 1 \cdot 2^2 + 0 \cdot 2^3 + 1 \cdot 2^4 = 0 + 2 + 4 + 0 + 16 = 22_{10} \]
    
    \subsubsection{Conversione da Decimale a Binario} \label{dec_to_bin}
    
    Per convertire un numero decimale in un numero binario, possiamo procedere in due modi:
    
    \begin{enumerate}
        \item Trovare la \textbf{più alta potenza di due} minore del numero da convertire e \textbf{sottrarla} a quest'ultimo. Se il valore ottenuto non è 0, allora \textit{ripetere} il procedimento. Riscrivere in binario le potenze trovate.
        
        $53_{10} = ?_2$
        \begin{enumerate}
            \item $53 - 2^5 = 21 \Rightarrow$ Scriverò 1 nella 6° colonna da destra
            \item $21 - 2^4 = 5 \Rightarrow$ Scriverò 1 nella 5° colonna da destra
            \item $5 - 2^2 = 1 \Rightarrow$ Scriverò 1 nella 3° colonna da destra
            \item $1 - 2^0 = 0 \Rightarrow$ Scriverò 1 nella 1° colonna da destra
        \end{enumerate}
        
        Risultato: $53_{10} = 110101_2$
        
        \item \textbf{Dividere per 2} (divisione con resto) il numero da convertire. \textit{Ripetere} il procedimento fino a che non si raggiunge 0. Infine, riscrivere da sinistra verso destra \textbf{tutti i resti} trovati a partire \textit{dal basso verso l'alto}
        
        \begin{center}
            $53_{10} = ?_2$
            
            \begin{tabular}{ c | c | c }
                \hline
                Divisione & Quoziente & Resto \\
                \hline
                $53 / 2$ & 26 & 1 \\ 
                $26 / 2$ & 13 & 0 \\ 
                $13 / 2$ & 6 & 1 \\ 
                $6 / 2$ & 3 & 0 \\ 
                $3 / 2$ & 1 & 1 \\
                $1 / 2$ & 0 & 1 \\
            \end{tabular}
            
            $53_{10} = 110101_2$
        \end{center}
    \end{enumerate}
    
    \subsubsection{Conversioni approssimate}
    
    Come abbiamo visto nella sezione \ref{SistemaBinario}, il valore di $2^{10}$ (ossia 1024) è molto vicino a 1000. Per via di questa coincidenza, possiamo facilmente calcolare (approssimativamente) le potenze di 2 di grande dimensione:
    
    \[ 2^{32} = 2^{10} \cdot 2^{10} \cdot 2^{10} \cdot 2^2 \approx 1000 \cdot 1000 \cdot 1000 \cdot 4 \approx 4'000'000'000 \]
    
    Ovviamente, ciò implica che più sia grande la potenza di 2 che andiamo a calcolare in questo modo, più grande sarà l'errore di approssimazione (ad esempio, in realtà $2^{32} = 4'294'967'296$).
    
    \subsubsection{Unità di misura}
    
    Nel corso degli anni, si sono andate a definire quelle che sono delle vere e proprie \textbf{unità di misura} del sistema di numerazione binario:
    
    \begin{enumerate}
        \item \textbf{1 Bit} = 1 cifra binaria
        \item \textbf{1 Nibble} = 4 Bit
        \item \textbf{1 Byte} = 8 Bit = 2 Nibble
        \item \textbf{1 Kilobyte} = 1024 Byte
        \item \textbf{1 Megabyte} = 1024 Kilobyte
        \item \textbf{1 Gigabyte} = 1024 Megabyte
        \item ...
    \end{enumerate}
    
    Esiste anche un'unità di misura generica chiamata \textbf{word}, indicante una quantità di Bit a scelta dell'utilizzatore o del contesto
    
    È necessario affermare anche l'esistenza di due \textbf{terminologie} importanti che ci torneranno utili in futuro: \textbf{most significant} e \textbf{least significant}. Queste due terminologie vengono applicate solitamente ai \textit{Bit} o ai \textit{Byte}, indicando rispettivamente il Bit/Byte \textit{più a sinistra} (most significant) e il Bit/Byte \textit{più a destra} (least significant).
    
    \[ \underbrace{1}_{MS \, Bit} 0 \; 1 \; 1 \; 0 \; 0 \; 1 \overbrace{0}^{LS \, Bit} \]
    
    \[ \underbrace{11110011}_{MS \, Byte} \; 11111111 \; 00110100 \; \overbrace{00101110}^{LS \, Byte}\]
    
    \subsubsection{Sistema di numerazione esadecimale} \label{hexadecimal}
    
    Oltre al classico sistema numerico decimale e al sistema binario, un ulteriore sistema che utilizzeremo per rappresentare i numeri è il \textbf{sistema esadecimale (hexadecimal)}, ossia in \textit{base 16}.
    
    Ma come possiamo rappresentare i valori di un sistema numerico in base 16 utilizzando solo i 10 simboli forniti dal sistema decimale? La risposta è molto semplice: utilizzando una scrittura \textbf{alfanumerica}. L'insieme dei valori rappresentabili in un sistema decimale corrisponde a:
    
    \begin{center}
            \begin{tabular}{ l | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c }
                Decimale & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 \\
                \hline
                Esadecimale & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & A & B & C & D & E & F \\
            \end{tabular}
        \end{center}
    
    \newpage
    
    Poiché il numero 16 equivale ad una potenza di 2, questo sistema numerico risulta particolarmente comodo per rappresentare \textit{lunghe sequenze di Byte}, poiché ci permette di rappresentare con una singola \textit{cifra} (o \textit{valore}) un \textbf{insieme di 4 Bit} (o 1 Nibble):
    
    \quad
    
    \begin{center}
        \begin{tabular}{ c | c | c }
            \hline
            Decimale & Binario & Esadecimale \\
            \hline
            0 & 0000 & 0 \\
            1 & 0001 & 1 \\
            2 & 0010 & 2 \\
            3 & 0011 & 3 \\
            4 & 0100 & 4 \\
            5 & 0101 & 5 \\
            6 & 0110 & 6 \\
            7 & 0111 & 7 \\
            8 & 1000 & 8 \\
            9 & 1001 & 9 \\
            10 & 1010 & A \\
            11 & 1011 & B \\
            12 & 1100 & C \\
            13 & 1101 & D \\
            14 & 1110 & E \\
            15 & 1111 & F \\
        \end{tabular}
    \end{center}
    
    \quad
    
    Per via di questa proprietà, quindi, il sistema esadecimale viene utilizzato come \textbf{abbreviazione} del sistema binario \textit{facilmente convertibile} da binario a esadecimale (o viceversa), come nel seguente esempio:
    \[ \underbrace{0100}_{4} \underbrace{1010}_{A} \underbrace{1111}_{F} \Rightarrow 4AF_{16} \; \text{oppure} \; 0x4AF \]
    
    Invece, per poter effettuare delle conversioni tra il sistema esadecimale e quello decimale, possiamo utilizzare i vari metodi già impiegati effettuare le conversioni tra binario e decimale, \textit{sostituendo} l'uso del 2 con l'uso del 16.
    
    \subsection{Operazioni aritmetiche in sistema binario}
    Per poter \textbf{sommare} due numeri binari, il procedimento da seguire è lo stesso valido per la somma tra due numeri decimali: sommo colonna per colonna le cifre dei due numeri, scrivendo il valore ottenuto e il suo \textbf{riporto}, il quale conterà come valore aggiuntivo da considerare successiva somma in colonna. Di seguito un esempio grafico
    
    \begin{center}
        \begin{tabular}{ r r r r c }
            3 & ${}^{1}7$ & ${}^{1}3$ & 4 & + \\
            5 & 1 & 6 & 8 & = \\
            \hline
            8 & 9 & 0 & 2 \\
        \end{tabular}
        \quad\quad\quad\quad\quad
        \begin{tabular}{ r r r r c }
            ${}^{1}0$ & ${}^{1}1$ & ${}^{1}0$ & 1 & + \\
            0 & 0 & 1 & 1 & = \\
            \hline
            1 & 0 & 0 & 0 \\
        \end{tabular}
        
        Sinistra: addizione tra numeri decimali - Destra: addizione tra numeri binari
    \end{center}
    
    \newpage
    
    \label{mul_bin}
    Allo stesso modo, le \textbf{moltiplicazioni} in sistema binario seguono anche esse la stessa logica delle moltiplicazioni decimali:
    
    \begin{center}
        \begin{tabular}{ r r r r r c }
              & 2 & 3 & 0 & x \\
              &   & 4 & 2 & = \\
            \hline
              & 4 & 6 & 0 & + \\
            9 & 2 & 0 &   & = \\
            \hline
            9 & 6 & 6 & 0 &   \\
        \end{tabular}
        \quad\quad\quad\quad
        \begin{tabular}{ r r r r r r r c }
              &   &   &   & 1 & 0 & 1 & x \\
              &   &   &   & 1 & 1 & 1 & = \\
            \hline
              &   &   &   & 1 & 0 & 1 & + \\
              &   &   & ${}^{1}$1 & 0 & 1 &   & + \\
              &   & ${}^{1}$1 & 0 & 1 &   &   & = \\
            \hline
              & 1 & 0 & 0 & 0 & 1 & 1 &  \\
        \end{tabular}
        
        A sinistra: prodotto tra due numeri decimali.
        
        A Destra: prodotto tra due numeri binari.
    \end{center}
    
    Per poter effettuare \textbf{sottrazioni} e \textbf{divisioni}, vengono utilizzate le \textit{proprietà matematiche}, trasformando ad esempio una sottrazione tra due numeri in una somma tra essi dove uno dei due assume valore negativo (es: $100_2 - 11_2 = 100_2 + (-11_2)$). Nei paragrafi successivi vedremo dei \textbf{metodi di rappresentazione} che permettono di poter lavorare con i numeri negativi.
    
    \subsubsection{Overflow}
    poiché i sistemi digitali operano con un \textbf{numero fisso} di Bit, è necessario considerare quei casi in cui, durante un'addizione o una moltiplicazione, il numero di Bit sia \textit{insufficiente} a poter rappresentare il risultato. Questa problematica viene definita col termine \textbf{overflow} (ossia \textit{stra-bordare}).
    
    Nell'ultima moltiplicazione del paragrafo precedente, possiamo vedere un tipico esempio di overflow: i due moltiplicandi utilizzano entrambi 3 Bit, ma il loro prodotto ne richiede \textit{almeno} 6. In questi casi, i \textit{Bit in eccesso} vengono \textbf{scartati}, generando un \textbf{risultato "sballato"} (se nell'esempio tagliassimo i Bit in eccesso, la moltiplicazione risulterebbe come 101 x 111 = 011, dunque 5 x 7 = 3). Tuttavia, come vedremo in seguito, vi sono casi in cui l'overflow viene utilizzato come \textbf{vantaggio} e non come svantaggio.
    
    \subsubsection{Shift di Bit a destra e a sinistra} \label{shift1}
    
    Un operatore binario aggiuntivo rispetto alla normale aritmetica decimale è l'operazione di \textbf{shift} (o \textit{spostamento}). Lo shift è un operatore che prevede lo spostamento \textbf{a destra o a sinistra} di una certa quantità di \textit{caselle} di tutti i Bit del numero binario sul quale viene applicato.
    
    \[ 000101_2 << 2 = 010100 \]
    
    \[ 011000_2 >> 2 = 000110 \]
    
    \newpage
    
    \section{Numeri binari negativi}
    
    Fino ad ora, abbiamo parlato di numeri binari strettamente positivi. Tuttavia, per compiere ulteriori operazioni aritmetiche è necessario, dunque, introdurre il \textbf{segno} nell'ambito dei numeri binari. Vedremo due diversi \textbf{metodi di rappresentazione} dei numeri negativi, i numeri in \textbf{segno/magnitudine} e i numeri in \textbf{complemento a 2}.
    
    \subsection{Numeri in Sign/Magnitude}
    
    Nel primo metodo di rappresentazione, le carte in regola non cambiano molto: il \textbf{most significant Bit} del numero rappresenta il suo \textbf{segno}, mentre tutti gli altri rappresentano il suo valore (o \textbf{magnitudine}). Nel caso in cui il bit del segno assuma \textit{valore 0}, allora saremo davanti ad un numero \textbf{positivo}, mentre se assumerà \textit{valore 1} allora sarà un numero \textbf{negativo}. Di seguito due esempi:
    
    \[ \overbrace{0}^{Segno}10111_2 \Rightarrow +23
    \quad\quad\quad\quad\quad
    \overbrace{1}^{Segno}01011_2 \Rightarrow -11\]
    
    L'uso del MSB per il segno, ovviamente, \textbf{dimezza} e la gamma di valori positivi rappresentabili con una determinata quantità di bit, tuttavia sblocca l'accesso ad altrettanti numeri negativi. Ricapitolando, dati \textit{n bit}, nei due metodi di rappresentazione abbiamo i seguenti \textbf{intervalli} di valori disponibili:
    
    \[ \overbrace{\left[ 0, \; 2^n-1 \right]}^{Unsigned}  \quad\quad\quad\quad\quad \underbrace{\left[ -(2^{n-1}-1), \; 2^{n-1}-1 \right]}_{Sign/Magnitude}\]
    
    Nonostante ciò, anche questo formato ha delle problematiche: le \textbf{addizioni non funzionano} (come mostrato nell'esempio inferiore) e abbiamo \textbf{due modi} per rappresentare lo \textbf{zero} (1000 e 0000, corrispondenti a -0 e +0).
    
    \begin{center}
        \begin{tabular}{ r r r r r c }
            & ${}^1$1 & ${}^1$1 & 1 & 0 & + \\
            & 0 & 1 & 1 & 0 & = \\
            \hline
            \color{red}{1} & 0 & 1 & 0 & 0 &   \\
        \end{tabular}
        
        Errore!! Anche se scartassimo l'overflow, avremmo comunque -6 + 6 = +4
    \end{center}
    
    \subsection{Numeri in Complemento a 2} \label{Ca2}
    
    Per risolvere queste problematiche, è stato introdotto il sistema binario basato sul \textbf{complemento a 2}, il quale aggiunge un \textbf{ulteriore significato} al \textbf{MSB}. In questo sistema, il MSB assume il suo \textbf{effettivo valore}, tuttavia, a differenza del sistema senza segno, il valore assunto sarà \textbf{negativo}. Dati \textit{n bit}, dunque, il MSB assumerà il valore $-(2^{n-1})$, mentre tutti gli altri bit manterranno il valore \textbf{positivo}:
    
    \[ 10111_{Ca2} = 1 \cdot 2^0 + 1 \cdot 2^1 + 1 \cdot 2^2 + 0 \cdot 2^3 + (-1 \cdot 2^4) = -9_{10} \]
    
    Il Complemento a 2 di un numero decimale \textbf{positivo} corrisponde esattamente alla sua normale rappresentazione nel sistema binario.
    
    Per poter calcolare il Complemento a 2 di un numero decimale \textbf{negativo}, invece, è prima necessario calcolare il \textbf{Complemento ad 1} del suo corrispettivo numero binario \textbf{positivo}. Con la terminologia "calcolare il Complemento ad 1" si intende semplicemente \textbf{invertire} tutti i bit, trasformando quindi tutti i suoi 0 in 1 e viceversa:
    
    \[ -25_{10} \Rightarrow +25_{10} = 011001_2 \Rightarrow 100110_{Ca1} \]
    
    Una volta calcolato il Complemento ad 1, il prossimo passo sarà semplicemente \textbf{sommare 1 al LSB del Ca1}
    
    \[ -25_{10} \Rightarrow 100110_{Ca1} \Rightarrow 100110_{Ca1} + 1 \Rightarrow 100111_{Ca2} \]
    
    Per confermare che la conversione sia avvenuta correttamente, possiamo calcolare il valore del Ca2 ottenuto contando il valore dei singoli bit come mostrato ad inizio paragrafo:
    
    \[ 100111_{Ca2} = 1 \cdot 2^0 + 1 \cdot 2^1 + 1 \cdot 2^2 + 0 \cdot 2^3 + 0 \cdot 2^4 + (-1 \cdot 2^5) = -25_{10} \]
    
    Considerando tutte le proprietà del Ca2 che abbiamo descritto, possiamo notare come \textbf{calcolare il Ca2} di un numero \textit{già scritto} in forma Ca2 equivale a \textbf{invertire} il suo segno:
        
    \[ +25_{10} = 011001_{Ca2} \quad\quad\quad -25_{10} = 100111_{Ca2}\]
    \[ Ca2(011001_{Ca2}) = 100111_{Ca2}\]
    
    L'utilità del Ca2 è evidente: per via del modo in cui viene rappresentato, è possibile svolgere \textbf{operazioni} tra numeri di segno opposto senza problematiche (come mostrato nell'esempio inferiore). Inoltre, viene risolto anche il problema dei \textbf{due zeri}, poiché 0000 corrisponderà al normale 0, mentre 1000 corrisponderà a -8.
    \[ +6_{10} = 0110_{Ca2} \quad\quad\quad -6_{10} = 1010_{Ca2}\]
    
    \begin{center}
        \begin{tabular}{ r r r r r c }
            & ${}^1$1 & ${}^1$0 & 1 & 0 & + \\
            & 0 & 1 & 1 & 0 & = \\
            \hline
            \color{red}{1} & 0 & 0 & 0 & 0 &   \\
        \end{tabular}
        
        Corretto! Scartando l'overflow otteniamo che -6 + 6 = 0
    \end{center}
    
    poiché 1000 rappresenta un numero aggiuntivo rispetto al sistema sign/magnitude, il \textbf{range di valori} negativi rappresentabili in Ca2 è $-(2^{n-1})$, invece di $-(2^{n-1}-1)$:
    
    \[ \overbrace{\left[ 0, \; 2^n-1 \right]}^{Unsigned}  \quad\quad\quad \underbrace{\left[ -(2^{n-1}-1), \; 2^{n-1}-1 \right]}_{Sign/Magnitude} \quad\quad\quad \underbrace{\left[ -(2^{n-1}), \; 2^{n-1}-1 \right]}_{Ca2}\]
    
    \subsubsection{Incrementare il numero di bit}
    
    Per lavorare con i numeri in Ca2, in alcuni casì può essere necessario incrementare il numero di bit utilizzati. Tuttavia, quando viene compiuta questa operazione è necessario tenere conto del \textbf{segno} del numero rappresentato:
    
    \begin{itemize}
        \item Il numero $010011_{Ca2}$ può essere "allungato" aggiungendo la quantità desiderata di \textbf{0} davanti il numero: $01011_{Ca2} \Rightarrow \textbf{000}01011_{Ca2}$. Questo è possibile poiché si tratta di un numero \textit{positivo}
        \item Il numero $110011_{Ca2}$ può essere "allungato" aggiungendo la quantità desiderata di \textbf{1} davanti il numero: $11011_{Ca2} \Rightarrow \textbf{111}11011_{Ca2}$. Questo è possibile poiché si tratta di un numero \textit{negativo}, quindi è necessario mantenere costanti il segno e il valore finale del numero. Nel caso in cui fosse utilizzato lo 0 al posto dell'1, il valore finale del numero in Ca2 \textbf{cambierebbe}
    \end{itemize}
    
    \subsubsection{Lo Shift come moltiplicazione o divisione} \label{shift2}
    
    Poiché lo shift prevede lo \textbf{spostare i bit} di un numero binario a sinistra e a destra, nel caso dei numeri in Ca2 questo operatore può essere utilizzato come \textbf{moltiplicazione} e \textbf{divisione}, ma solo nel caso in cui il moltiplicatore o divisore sia \textbf{una potenza di 2}:
    
    \[ B \cdot 2^n = B << n 
    \quad\quad\quad\quad\quad
    B / 2^n = B >>> n\] 
    
    Il motivo per cui nella divisione utilizziamo il \textbf{triplo shift a destra ($>>>$)}, è semplicemente un modo per segnalare la necessità di dover tener conto del \textbf{segno} nel caso in cui venga applicato lo shift su un numero in Ca2 \textbf{negativo}.
    Inoltre, nell'eseguire questi calcoli tramite shift, è necessario sfruttare l'overflow a proprio vantaggio. Di seguito alcuni esempi:
    
    \begin{itemize}
        \item $00001 << 2 = 00100 \quad\Rightarrow\quad 1 \cdot 2^2 = 4$
        \item $11101 << 2 = 10100 \quad\Rightarrow\quad -3 \cdot 2^2 = -12$
        \item $01000 >>> 2 = 00010 \quad\Rightarrow\quad 8 / 2^2 = 2$
        \item $10000 >>> 2 = 11100 \quad\Rightarrow\quad -16 / 2^2 = -4$
    \end{itemize}
    
    \newpage

    \section{Numeri binari razionali}
    
    Come per il sistema decimale, anche nel sistema binario è possibile rappresentare i numeri razionali. Tuttavia, nel caso del sistema binario esistono due tipologie di rappresentazione utilizzabili: i numeri a \textbf{virgola fissa (fixed-point numbers)} e i numeri a \textbf{virgola mobile (floating-point number)}.
    
    \subsection{Numeri a virgola fissa}
    
    Questo sistema di rappresentazione è l'equivalente \textit{1 ad 1} della \textbf{classica rappresentazione} dei numeri razionali nel sistema decimale. In quest'ultimo, il modo in cui i numeri razionali vengono rappresentati corrisponde alla seguente somma:
    
    \[ 134.56_{10} = 1 \cdot 10^2 + 3 \cdot 10^1 + 4 \cdot 10^0 + 5 \cdot 10^{-1} + 6 \cdot 10^{-2}\]
    
    Allo stesso modo, il seguente numero binario espresso in forma razionale corrisponderà ad una somma tra il prodotto delle singole cifre per le loro potenze di 2 rispettive, risultando quindi in una semplice \textbf{estensione} della normale rappresentazione binaria di un numero:
    
    \[ 110.11_2 = 1 \cdot 2^2 + 1 \cdot 2^1 + 0 \cdot 2^0 + 1 \cdot 2^{-1} + 1 \cdot 2^{-2} = 6.75_{10}\]
    
    Per poter convertire un numero decimale razionale in un numero binario razionale, è necessario scomporre il processo in \textbf{due fasi}:
    
    \begin{enumerate}
        \item Conversione in binario della \textbf{parte intera} del numero decimale
        \item Conversione in binario della \textbf{parte razionale} del numero decimale
    \end{enumerate}
    
    La prima fase siamo già in grado di svilupparla tramite le metodologie imparate nella sezione \ref{dec_to_bin}. Per la seconda, invece, è necessario introdurre un nuovo metodo:
    
    \begin{enumerate}
        \item Moltiplicare la parte razionale per 2.
        
        \begin{enumerate}
            \item Se il risultato ottenuto è \textbf{uguale ad 1}, allora passa al punto 2.
            \item Se il risultato ottenuto è \textbf{maggiore di 1}, allora sarà necessario \textbf{sottrarre 1} al risultato ottenuto.
            Successivamente, ripeti il punto 1 utilizzando l'attuale risultato parziale come parte frazionaria
            \item Se il risultato ottenuto è \textbf{minore di 1}, allora ripeti il punto 1 utilizzando l'attuale risultato parziale come parte frazionaria
        \end{enumerate}
        \item Una volta che la parte frazionaria non sia più presente nel risultato parziale (dunque quando si arriva al punto 1.a), sarà necessario riscrivere partendo dall'alto tutte le \textbf{parti intere dei risultati parziali ottenuti} durante lo svolgimento dell'algoritmo
    \end{enumerate}
    
    \newpage

    \label{fixed_point}
    Per comprendere meglio questo processo, vediamo un esempio pratico dove convertiremo il numero $17.625_{10}$ in binario:
    
    \begin{itemize} 
        \item La parte intera siamo già in grado di convertirla, quindi $17_{10} \Rightarrow 010001_2$
        \item Per la parte razionale, applichiamo l'algoritmo descritto precedentemente:
        
        \begin{enumerate}
            \item $0.625 \cdot 2 = \color{red}1\color{black}.25 \Rightarrow (1.25 - 1 = 0.25)$
            \item $0.25 \cdot 2 = \color{red}0\color{black}.5$
            \item $0.5 \cdot 2 = \color{red}1\color{black}$
        \end{enumerate}
        
        Una volta raggiunto 1, consideriamo partendo dall'alto tutte le parti intere dei risultati parziali (segnate in rosso), ottenendo la parte razionale del nostro numero binario finale, ossia \textbf{.101$_2$}.
        
        \item L'ultimo passo è quello di unire la parte intera binaria a quella razionale, ottenendo che:
        \[ 17.625_{10} = 010001.101_2\]
    \end{itemize}
    
    \subsection{Numeri a virgola mobile}
    
    Così come i numeri a virgola fissa sono l'equivalente binario dei numeri razionali decimali, i numeri a virgola mobile sono l'equivalente binario della \textbf{notazione scientifica} dei numeri decimali.
    
    In linea generica, i numeri in notazione scientifica (sia decimale che binaria) vengono rappresentati nella seguente forma
    
    \[ \pm M \cdot B^E \]
    dove:
    \begin{itemize}
        \item \textbf{M} = Mantissa
        \item \textbf{B} = Base
        \item \textbf{E} = Esponente
    \end{itemize}
    
    \quad
    
    Poiché lavoriamo con definite quantità di bit, solitamente i numeri floating-point vengono rappresentati utilizzando \textbf{32 bit}, dove il \textbf{primo bit} rappresenta il \textit{segno}, i successivi \textbf{8 bit} rappresentano l'\textit{esponente} e i restanti \textbf{23 bit} rappresentano la \textit{mantissa}.
    
    \quad
    
     \begin{center}
        \begin{tabular}{| c | c | c |}
            \hline
            1 bit & 8 bit & \qquad 23 bit \qquad\quad \\
            \hline
            \multicolumn{1}{c}{\upbracefill} & \multicolumn{1}{c}{\upbracefill} & \multicolumn{1}{c}{\upbracefill} \\
            \multicolumn{1}{c}{Sign} &
            \multicolumn{1}{c}{Exponent} & \multicolumn{1}{c}{Mantissa}\\
        \end{tabular}
    \end{center}
    
    \newpage
    
    Per convertire un numero decimale nella sua forma floating-point, è necessario seguire i seguenti passaggi:
    
    \begin{enumerate}
        \item Convertire il numero in un binario \textbf{fixed-point unsigned}, poichè il segno sarà rappresentato dal primo bit del float
        \item \textbf{Riscrivere il numero} in "notazione scientifica binaria" portando la virgola fino ad una sola unità
        \item Riscrivere il \textit{segno}, la \textit{mantissa} e l'\textit{esponente} nei loro \textbf{campi equivalenti} della rappresentazione floating-point, 
    \end{enumerate}
    
    \quad
    
    Riprendendo l'esempio fatto per la conversione in fixed-point nella sezione \ref{fixed_point}, convertiamo il numero $17.625_{10}$ in floating-point:
    
    \begin{enumerate}
        \item $17.625_{10} = 10001.101_2$
        \item $10001.101_2 = 1.0001101_2 \cdot 2^4$
        \item Converto i tre campi necessari in binario per poi riscriverli nei campi rispettivi:
            \begin{itemize}
                \item \textit{Sign} = $0_2$
                \item \textit{Exponent} = $100_2$
                \item \textit{Mantissa} = $10001101_2$
            \end{itemize}
    \end{enumerate}
    
    \quad
    
    \begin{center}
        \begin{tabular}{| c | c | c |}
            \hline
            0 & 00000100 & 10001101000000000000000 \\
            \hline
            \multicolumn{1}{c}{\upbracefill} & \multicolumn{1}{c}{\upbracefill} & \multicolumn{1}{c}{\upbracefill} \\
            \multicolumn{1}{c}{Sign} &
            \multicolumn{1}{c}{Exponent} & \multicolumn{1}{c}{Mantissa}\\
        \end{tabular}
    \end{center}
    
    \quad
    
    Facendo attenzione al \textbf{secondo passaggio} del procedimento, possiamo notare come \textbf{qualsiasi numero} venga rappresentato in notazione scientifica binaria abbia un 1 come unità a cui viene attribuita la virgola:
    
    \begin{itemize}
        \item $17.625_{10} = 10001.101_2 = \color{red}1\color{black}.0001101_2 \cdot 2^4$
        \item $-58.25_{10} = 111010.01_2 = \color{red}1\color{black}.1101001_2 \cdot 2^5$
        \item $228_{10} = 11100100_2 = \color{red}1\color{black}.1100100_2 \cdot 2^7$
    \end{itemize}

    Per convenzione, quindi, nel momento in cui andiamo a riempire i rispettivi campi del floating-point possiamo direttamente \textbf{ignorare} l'1 prima della virgola, andando a guadagnare un bit aggiuntivo da poter utilizzare per rappresentare le cifre \textit{dopo} la virgola:
    
    $17.625_{10} = 10001.101_2 = \color{red}1\color{black}.0001101_2 \cdot 2^4$
    
    \quad \begin{tabular}{| c | c | c |}
            \hline
            0 & 00000100 & \color{red}1\color{black}0001101000000000000000 \\
            \hline
        \end{tabular}
        $\Rightarrow$ Senza ignorare l'1 davanti la virgola 
        
    \quad \begin{tabular}{| c | c | c |}
            \hline
            0 & 00000100 & 00011010000000000000000 \\
            \hline
        \end{tabular}
        $\Rightarrow$ Ignorando l'1 davanti la virgola
    
    Nonostante questo passaggio possa sembrare superfluo, esso è \textbf{estremamente utile}, poiché nel caso in cui dovessimo rappresentare in float un numero in notazione scientifica binaria con 23 bit \textbf{dopo} la virgola, saremmo costretti a dover \textbf{tagliare} una parte di precisione scartando il LSB, poiché non possiamo inserire 24 bit nello spazio di 23 predisposto dalla mantissa.
    
    \quad
    
    \subsubsection{Lo Standard IEEE 754}
    
    Ora che abbiamo guadagnato un bit aggiuntivo da poter usare per la precisione della mantissa, resta solo una problematica da risolvere: come possiamo rappresentare i numeri in notazione scientifica binaria con \textbf{esponente negativo}?
    
    Lo \textbf{Standard IEEE 754}, il più utilizzato, propone una soluzione semplice: aggiungiamo un \textbf{bias di 127 all'esponente}.
    
    Riprendiamo ancora una volta l'esempio della sezione \ref{fixed_point}:
    \[ 17.625_{10} = 10001.101_2 = 1.0001101_2 \cdot 2^4 \]
    
    Una volta portato il numero in questa forma, aggiungiamo \textbf{127} al suo esponente, per poi convertirlo nel formato floating-point (ignorando il bit prima della virgola della mantissa):
    \[ 17.625_{10} = 10001.101_2 = 1.0001101_2 \cdot 2^{(4+127)} = 1.0001101_2 \cdot 2^{131} \]
    
    \quad
    
    \begin{center}
        \begin{tabular}{| c | c | c |}
            \hline
            0 & 10000011 & 00011010000000000000000 \\
            \hline
            \multicolumn{1}{c}{} &
            \multicolumn{1}{c}{\upbracefill} &
            \multicolumn{1}{c}{} \\
            \multicolumn{1}{c}{} &
            \multicolumn{1}{c}{$131_{10}$} &
            \multicolumn{1}{c}{}\\
        \end{tabular}
    \end{center}
    
    \quad
    
    Grazie al bias di 127, possiamo scrivere anche i numeri con un esponente negativo \textbf{fino a -127} (poiché aggiungendo il bias l'esponente finale sarebbe 0, quindi rappresentabile positivamente). Tuttavia, perdiamo anche l'uso di una parte di esponenti positivi, poiché il valore massimo rappresentabile in 8 bit è 255.
    
    \subsubsection{Casi speciali, Tipi di precisione e rappresentazione in Esadecimale}
    
    Nel caso dei numeri floating-point, sono stati stabiliti dei \textbf{casi speciali} per poter rappresentare dei valori particolari o non esprimibili numericamente:
    
    \begin{center}
        \begin{tabular}{| c | c | c | c |}
            \hline
            Numero Equivalente & Segno & Esponente & Mantissa \\
            \hline
            0 & 1 o 0 & 00000000 & 00000000000000000000000 \\
            $\infty$ & 0 & 11111111 & 00000000000000000000000 \\
            $-\infty$ & 1 & 11111111 & 00000000000000000000000 \\
            NaN & 1 o 0 & 11111111 & diverso da 0 \\
            Num. Denormali & 1 o 0 & 00000000 & $(-1)^S \cdot 2^{-126} \cdot 0.m$ con $m \neq 0$\\
            \hline
        \end{tabular}
    \end{center}
    
    Inoltre, esistono vari \textbf{tipi di precisione} possibili per i numeri float in base al numero di bit utilizzati per rappresentarli:
    
    \begin{center}
        \begin{tabular}{| c | c | c | c | c | c |}
            \hline
            Tipologia & Bit Tot. & Segno & Esponente & Mantissa & Bias\\
            \hline
            Half-precision & 16 bit & 1 bit & 5 bit & 10 bit & 15 \\
            Single-precision & 32 bit & 1 bit & 8 bit & 23 bit & 127 \\
            Double-precision & 64 bit & 1 bit & 11 bit & 52 bit & 1023 \\
            \hline
        \end{tabular}
    \end{center}
    
    \quad
    
    L'utilità di avere più tipi di precisione è per prevenire la possibilità di un \textbf{overflow} o un \textbf{underflow} (ossia quando il numero è troppo piccolo per essere rappresentato), poiché altrimenti sarebbe necessario \textbf{arrotondare} il valore, perdendo una parte di precisione (si consiglia \href{https://www.youtube.com/watch?v=Js99ciGwho0}{questo video} se interessati ad una spiegazione dettagliata).
    
    Analogamente, anche per i floating point in half-precision vi sono \textbf{casi speciali}:
    
    \begin{center}
        \begin{tabular}{| c | c | c | c |}
            \hline
            Numero Equivalente & Segno & Esponente & Mantissa \\
            \hline
            0 & 1 o 0 & 00000 & 0000000000 \\
            $\infty$ & 0 & 11111 & 0000000000 \\
            $-\infty$ & 1 & 11111 & 0000000000 \\
            NaN & 1 o 0 & 11111 & diverso da 0 \\
            Num. Denormali & 1 o 0 & 00000 & $(-1)^S \cdot 2^{-14} \cdot 0.m$ con $m \neq 0$\\
            \hline
        \end{tabular}
    \end{center}

    Un ulteriore modalità di \textbf{rappresentazione} dei numeri float è tramite l'uso dei numeri esadecimali. Poiché 32 bit corrispondono a 8 gruppi da 4 bit, possiamo riscrivere ogni numero float come \textbf{8 numeri esadecimali}, utilizzando il metodo visto nella sezione \ref{hexadecimal}:
    
    \[ 17.625_{10} = \underbrace{0 \; 100}_{4} \underbrace{0001}_{1} \underbrace{1 \; 000}_{8} \underbrace{1101}_{D} \underbrace{0000}_{0} \underbrace{0000}_{0} \underbrace{0000}_{0}\underbrace{0000}_{0} {}_{float} \Rightarrow 0x418D0000\]
    
    \quad

    \subsubsection{Operazioni tra numeri floating-point}
    
    Per \textbf{sommare} due numeri in rappresentazione floating-point, il processo necessario è molto semplice:
    
    \begin{enumerate}
        \item Rappresentare nuovamente i due numeri in forma di \textbf{notazione scientifica binaria}
        \item Portare entrambi i numeri allo \textit{stesso esponente}
        \item Sommare le due mantisse, normalizzandole se necessario
        \item Aggiustare l'esponente e riscrivere in forma floating-point, \textit{arrotondando} in caso di overflow o underflow
    \end{enumerate}
    
    \textbf{Esempio:}
    
    Somma i due numeri float 0x3FC00000 e 0x40500000
    
    \begin{enumerate}
        \item $0x3FC00000 = 0 \; 01111111 \; 10000000000000000000000_{float} = 1.1 \cdot 2^0 \Rightarrow 0.11 \cdot 2^1$
        
        \item $0x40500000 = 0 \; 10000000 \; 10100000000000000000000_{float} = 1.101 \cdot 2^1$
        
        \item $0.11 \cdot 2^1 + 1.101 \cdot 2^1 = 10.011 \cdot 2^1$
        
            \begin{center}
                \begin{tabular}{ r r r r r r c }
                    & $^1$0. & 1 & 1 & 0 & + \\
                    & 1. & 1 & 0 & 1 & = \\
                    \hline
                    1 & 0. & 0 & 1 & 1 &   \\
                \end{tabular}
            \end{center}
            
        \item $10.011 \cdot 2^1 \Rightarrow 1.0011 \cdot 2^2 = \underbrace{0 \; 100}_{4} \underbrace{0000}_{0} \underbrace{1 \; 001}_{9} \underbrace{1000}_{8} \underbrace{0000}_{0} \underbrace{0000}_{0} \underbrace{0000}_{0}  \underbrace{0000}_{0} {}_{float} \Rightarrow 0x40980000 $
        
    \end{enumerate}
    
    \quad
    
    Per \textbf{moltiplicare} due numeri float, invece, il processo necessario è leggermente diverso:
    
    \begin{enumerate}
        \item Rappresentare nuovamente i due numeri in forma di \textbf{notazione scientifica binaria}
        \item \textit{Sommare} i due esponenti
        \item Moltiplicare le due mantisse, normalizzandole se necessario
        \item Aggiustare l'esponente e riscrivere in forma floating-point, \textit{arrotondando} in caso di overflow o underflow
    \end{enumerate}
    
    \textbf{Esempio:}
    
    Calcolare il prodotto dei due numeri float 0x3FC00000 e 0x40500000
    
    \begin{enumerate}
        \item $0x3FC00000 = 0 \; 01111111 \; 10000000000000000000000_{float} = 1.1 \cdot 2^0$
        
        \item $0x40500000 = 0 \; 10000000 \; 10100000000000000000000_{float} = 1.101 \cdot 2^1$
        
        \item $1.101 \cdot 2^1 \cdot 1.1 \cdot 2^0  = 10.0111 \cdot 2^1$
        
            \begin{center}
                \begin{tabular}{ r r r r r r c }
                      &   & 1. & 1 & 0  & 1 & x \\
                      &   &    &   & 1. & 1 & = \\
                    \hline
                      &   & 1. & 1 & 0  & 1 & + \\
                      & $^1$1. & 1 & 0 & 1 &   & = \\
                    \hline
                     1 & 0. & 0 & 1 & 1 & 1  &  \\
                \end{tabular}
            \end{center}
            
        \item $10.0111 \cdot 2^1 \Rightarrow 1.00111 \cdot 2^2 = \underbrace{0 \; 100}_{4} \underbrace{0000}_{0} \underbrace{1 \; 001}_{9} \underbrace{1100}_{C} \underbrace{0000}_{0} \underbrace{0000}_{0} \underbrace{0000}_{0}  \underbrace{0000}_{0} {}_{float} \Rightarrow 0x409C0000 $
    \end{enumerate}
    
    %%%%%%%%%%%%%%%%%%%%%
    %%%% NEW CHAPTER %%%%
    %%%%%%%%%%%%%%%%%%%%%
    \chapter{Circuiti combinatori}
    
    \section{Definizioni}
    
    Nell'elettronica digitale, un \textbf{circuito logico} è una rete di dispositivi elettronici che processa un \textbf{valore discreto}. Ogni circuito è provvisto di un insieme di \textbf{input} che vengono processati all'interno di esso, restituendo uno o più \textbf{output}.
    
    Oltre ai suoi input e ai suoi output, ogni circuito viene descritto da una \textbf{specifica funzionale}, che esprime il modo in cui il circuito agisce sugli input per generare gli output, e una \textbf{specifica temporale}, che esprime il tempo impiegato dal circuito per processare processare gli input e generare gli output.
    
    \begin{center}
        \includegraphics{resources/images/chapter_2/circuit1.png}
    \end{center}
    
    I circuiti logici, quindi, possono essere visti come delle \textbf{scatole nere} di cui è necessario tener conto solo degli input che vengono forniti e degli output che vengono restituiti. Al loro interno, i circuiti logici sono composti da \textbf{nodi} e \textbf{elementi} (E1, E2, E3, ...), che spesso sono a loro volta dei circuiti logici. I nodi, invece, sono dei fili elettrici il cui voltaggio trasporta un valore discreto. Possono essere dei nodi di \textit{input} (A, B, C, ...), di \textit{output} (Y, Z, ...) o \textit{interni} al circuito stesso (n1, ...), ricevendo e consegnando dati da e al \textbf{mondo esterno}.
    
    \begin{center}
        \includegraphics[scale=0.9]{resources/images/chapter_2/circuit2.png}
    \end{center}
    
    \newpage
    
    \label{seq_circ_intro}
    
    I circuiti logici possono essere divisi in due macro-categorie: circuiti \textbf{combinatori} e circuiti \textbf{sequenziali}. I primi sono \textbf{senza memoria}, dunque il valore degli output dipende solo dagli input e dal modo in cui vengono elaborati al suo interno. I secondi, invece, sono dotati di \textbf{memoria}, dunque il valore degli output dipende sia dal valore degli input nel momento precedente all'elaborazione, sia dal valore che hanno assunto nelle precedenti elaborazioni. In questo capitolo, vedremo prima il funzionamento e le regole che determinano i circuiti combinatori, per poi passare a quelli sequenziali.
    
    Per poter essere definito come combinatorio, un circuito logico deve rispettare determinate \textbf{caratteristiche}:
    \begin{itemize}
        \item Ogni elemento del circuito deve essere a sua volta \textit{combinatorio}
        \item Ogni nodo è un \textit{input} oppure si connette ad esattamente \textit{un output}
        \item Nel circuito non sono presenti dei collegamenti \textit{ciclici}
    \end{itemize}
    
    \begin{center}
        \includegraphics{resources/images/chapter_2/circuit3.png}
    \end{center}
    
    Nella foto mostrata, solo i circuiti \textit{a}, \textit{c} ed \textit{e} sono combinatori, poiché rispettano tutte le caratteristiche precedentemente elencate.
    
    \section{Porte logiche}
    
    Le \textbf{porte logiche} sono la forma più semplice di circuiti logici, poiché la loro funzione prevede il ricevere in input uno o più valori \textbf{valori binari} per produrre un output a sua volta binario. Poiché si tratta di circuiti digitali, e dunque di elettronica, il valore assunto dagli input e dagli output è descritto da due semplici relazioni: se vi è \textbf{passaggio di corrente} (indipendentemente dall'intensità) allora il nodo assume valore 1, mentre in sua \textbf{assenza} assume valore 0.
    
    La relazione tra gli input e gli output delle porte logiche vengono descritte tramite delle \textbf{tabelle della verità} e tramite le \textbf{equazioni Booleane} (derivanti da  Boole, inventore di questo tipo di algebra), ossia un'espressione matematica che utilizza solo valori binari.
    
    \newpage
    
    Di seguito, vedremo una carrellata contenente tutte le porte logiche rappresentate graficamente, con annesse tabelle della verità ed equazioni booleane:
    
    \begin{center}
        \begin{tabular}{c c c}
            \\
            \color{blue}\large{\textsf{\textbf{BUFFER}}}\color{black} && \color{blue}\large{\textsf{\textbf{NOT}}}\color{black} \\
            
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=north, yshift=-10, buffer port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A};
            \end{circuitikz} 
            & \qquad\qquad\qquad\qquad &
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=north, yshift=-10, not port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A};
            \end{circuitikz}\\\\
             
            $ Y = A$ & & $ Y = \overline{A}$ \\\\
            
            \begin{tabular}{c | c}
                A & Y \\
                \hline
                0 & 0 \\
                1 & 1
            \end{tabular}
            & &
            \begin{tabular}{c | c}
                A & Y \\
                \hline
                0 & 1 \\
                1 & 0
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \begin{center}
        \begin{tabular}{c c c c c}
            \\\\
            \color{blue}\large{\textsf{\textbf{AND}}}\color{black} && \color{blue}\large{\textsf{\textbf{OR}}}\color{black} && \color{blue}\large{\textsf{\textbf{XOR}}}\color{black} \\
            
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=north, yshift=-10, and port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A}
                    (port.in 2) node (B1)[anchor=east]{B};
            \end{circuitikz} 
            & \qquad\qquad\qquad &
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=north, yshift=-10, or port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A}
                    (port.in 2) node (B1)[anchor=east]{B};
            \end{circuitikz} 
            & \qquad\qquad\qquad  & 
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=north, yshift=-10, xor port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A}
                    (port.in 2) node (B1)[anchor=east]{B};
            \end{circuitikz} \\\\
             
            $ Y = AB$ & & $ Y = A + B$ & & $Y = A \oplus B$\\\\
            
            \begin{tabular}{c c | c}
                A & B & Y \\
                \hline
                0 & 0 & 0 \\
                0 & 1 & 0 \\
                1 & 0 & 0 \\
                1 & 1 & 1 
            \end{tabular}
            & &
            \begin{tabular}{c c | c}
                A & B & Y \\
                \hline
                0 & 0 & 0 \\
                0 & 1 & 1 \\
                1 & 0 & 1 \\
                1 & 1 & 1 
            \end{tabular}
            & &
            \begin{tabular}{c c | c}
                A & B & Y \\
                \hline
                0 & 0 & 0 \\
                0 & 1 & 1 \\
                1 & 0 & 1 \\
                1 & 1 & 0 
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \begin{center}
        \begin{tabular}{c c c c c}
            \\\\
            \color{blue}\large{\textsf{\textbf{NAND}}}\color{black} && \color{blue}\large{\textsf{\textbf{NOR}}}\color{black} && \color{blue}\large{\textsf{\textbf{XNOR}}}\color{black} \\
            
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=north, yshift=-10, nand port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A}
                    (port.in 2) node (B1)[anchor=east]{B};
            \end{circuitikz} 
            & \qquad\qquad\qquad &
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=north, yshift=-10, nor port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A}
                    (port.in 2) node (B1)[anchor=east]{B};
            \end{circuitikz} 
            & \qquad\qquad\qquad  & 
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=north, yshift=-10, xnor port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A}
                    (port.in 2) node (B1)[anchor=east]{B};
            \end{circuitikz} \\\\
             
            $ Y = \overline{AB}$ & & $ Y = \overline{A + B}$ & & $Y = \overline{A \oplus B}$\\\\
            
            \begin{tabular}{c c | c}
                A & B & Y \\
                \hline
                0 & 0 & 1 \\
                0 & 1 & 1 \\
                1 & 0 & 1 \\
                1 & 1 & 0 
            \end{tabular}
            & &
            \begin{tabular}{c c | c}
                A & B & Y \\
                \hline
                0 & 0 & 1 \\
                0 & 1 & 0 \\
                1 & 0 & 0 \\
                1 & 1 & 0 
            \end{tabular}
            & &
            \begin{tabular}{c c | c}
                A & B & Y \\
                \hline
                0 & 0 & 1 \\
                0 & 1 & 0 \\
                1 & 0 & 0 \\
                1 & 1 & 1 
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \section{Equazioni booleane}
    
    Una volta appresi i concetti base dei circuiti logici e il funzionamento delle porte logiche, possiamo di ciò che descrive dettagliatamente le \textbf{specifiche funzionali} di circuito logico, ossia le già citate \textbf{equazioni booleane}.
    
    Il seguente circuito logico (CL) è dotato di tre input (A, B e $C_{in}$) e due output (S, $C_{out}$, e può essere descritto sia in forma scritta sia in forma grafica:
    
    \begin{center}
        \[ S = F(A, B, C_{in})\]
        \[ C_{out} = F(A, B, C_{in})\]
        \includegraphics{resources/images/chapter_2/circuit4.png}
    \end{center}
    
    Per descrivere le specifiche funzionali del circuito, è necessario definire le equazioni booleane che mettono in \textbf{relazione} gli input con gli output. In questo esempio, andremo a descrivere le due funzioni che generano gli output S e $C_{out}$ come:
    
    \[ S = A \oplus B \oplus C_{in} \]
    \[ C_{out} = AB + AC_{in} + BC_{in} \]
    
    In aggiunta, possiamo anche definire la \textbf{tabella della verità} corrispondente all'equazione descritta:
    
    \begin{center}
        \begin{tabular}{c c c | c c c | c c}
                \multicolumn{3}{c}{Inputs} &
                \multicolumn{3}{c}{Middle terms} &
                \multicolumn{2}{c}{Outputs} \\
                \multicolumn{3}{c}{\downbracefill} & \multicolumn{3}{c}{\downbracefill} &
                \multicolumn{2}{c}{\downbracefill} \\
                A & B & $C_{in}$ & AB & $AC_{in}$ & $BC_{in}$  & S & $C_{out}$ \\
                \hline
                0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 \\
                0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 \\
                0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 \\
                1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
                1 & 0 & 1 & 0 & 1 & 0 & 0 & 1 \\
                1 & 1 & 0 & 1 & 0 & 0 & 0 & 1 \\
                1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
                \\
            \end{tabular}
    \end{center}
    
    Senza saperlo, abbiamo appena descritto completamente un \textbf{sommatore ad 1 bit con riporto}, dove S corrisponde al valore ottenuto dalla somma dei bit A, B e $C_{in}$, ossia il possibile riporto di una precedente somma, mentre $C_{out}$ corrisponde al riporto generato dalla somma stessa.
    
    Nel caso non sia chiaro il suo funzionamento, nessun problema: questo componente fondamentale \textbf{verrà analizzato in uno stato molto avanzato del corso}.
    
    Prima di poter parlare dettagliatamente di equazioni booleane, è necessario introdurre una serie di \textbf{terminologie}:
    
    \begin{itemize}
        \item \textbf{Complement}: l'opposto stretto di una variabile $\Rightarrow \overline{A}$ è il complemento di \textit{A}
        \item \textbf{Literal}: una variabile o un suo complemento $\Rightarrow A, \overline{A}, B, \overline{B}$
        \item \textbf{Implicant}: un prodotto tra letterali $\Rightarrow A\overline{B}, \overline{AC}, ABC$
        \item \textbf{Minterm}: un prodotto tra tutte le variabili in input $\Rightarrow ABC, A\overline{B}C, \overline{ABC}$
        \item \textbf{Maxterm}: una somma tra tutte le variabili in input $\Rightarrow$ A+B+C, $A+\overline{B}+C, \overline{A+B+C}$
    \end{itemize} 
    
    \subsection{Somma di prodotti (SOP) e Prodotto di somme (POS)}
    
    Due ulteriori modi per rappresentare le equazioni booleane è attraverso le \textit{forma canoniche} \textbf{Sum-of-Products (SOP)} e \textbf{Product-of-Sums (POS)}. È opportuno sottolineare che \textbf{ogni} equazione booleana può essere definita in queste due forme.
    
    Nella forma \textbf{SOP}, ad ogni riga della tabella della verità, descrivente il rapporto tra input e output, corrisponde un \textbf{minterm} tra le variabili della funzione, dove gli zeri assumono la forma di \textbf{complementare}, mentre gli uno non vengono negati. Infine, la funzione descritta dall'equazione booleana viene rappresentata come la \textbf{somma dei minterm} il cui output è \textbf{1}.
    
    Nella forma \textbf{POS}, invece, ad ogni riga della tabella della verità corrisponde un \textbf{maxterm} tra le variabili della funzione, dove gli uno assumono la forma di \textbf{complementare}, mentre gli zeri non vengono negati. Infine, la funzione descritta dall'equazione booleana viene rappresentata come il \textbf{prodotto dei maxterm} il cui output è \textbf{0}.
    
    Proviamo a descrivere l'equazione $Y = A \oplus B$ prima in forma SOP e poi in forma POS:
    
    \begin{center}
        \begin{tabular}{ c c | c | c | c }
            A & B & Minterm & Maxterm & Y \\
            \hline
            0 & 0 & $\overline{A} \cdot \overline{B}$ & $A+B$ & 0 \\
            0 & 1 & $\overline{A} \cdot B $  & $A+\overline{B}$ & 1 \\
            1 & 0 & $A \cdot \overline{B}$ & $\overline{A}+B$& 1 \\
            1 & 1 & $A \cdot B$& $\overline{A}+\overline{B}$ & 0 \\\\
        \end{tabular}
    \end{center}
    
    \[ Forma \; SOP \Rightarrow Y = F(A, B) = \overline{A}B + A\overline{B} = \Sigma (1, 2) \]
    \[ Forma \; POS \Rightarrow Y = F(A, B) = (A+B)(\overline{A}+\overline{B}) = \Pi (0, 3) \]
    
    In seguito, vedremo l'utilità di poter riscrivere ogni equazione booleana in termini di somme e prodotti al fine di poter semplificare le equazioni ai \textbf{minimi implicanti} necessari
    
    \newpage
    
    \subsection{Algebra di Boole}
    
    L'algebra introdotta dal matematico George Boole, seppur molto poco utilizzata nel periodo in cui venne introdotta, trovò un'applicazione estremamente efficiente nel campo dell'elettronica digitale. Proprio come nella normale algebra, Boole introdusse una serie di \textbf{assiomi} e \textbf{teoremi} che dettano il rapporto tra i valori discreti 0 ed 1.
    
    Tramite questi assiomi e teoremi, è possibile \textbf{semplificare} notevolmente le equazioni booleane descriventi i circuiti logici. La caratteristica fondamentale di essi è la loro \textbf{dualità}, ossia la completa \textit{intercambiabilità} tra AND ($\cdot$) ed OR (+) e tra 1 e 0, senza alterare la veridicità dell'assioma o del teorema.
    
    \begin{center}
        \begin{tabular}{l | l | l}
            \textbf{Nome} & \textbf{Assioma/Teorema} & \textbf{Assioma/Teorema duale} \\
            \hline
            Assioma 1 & $A = 0 \Leftrightarrow A \neq 1$ & $A = 1 \Leftrightarrow A \neq 0$ \\
            Assioma 2 & $\overline{0} = 1$ & $\overline{1} = 0$ \\
            Assioma 3 & $0 \cdot 0 = 0$ & $1 + 1 = 1$ \\
            Assioma 4 & $1 \cdot 1 = 1$ & $0 + 0 = 0$ \\
            Assioma 5 & $0 \cdot 1 = 1 \cdot 0 = 0$ & $1+0 = 0+1 = 1$\\
            T. d'identità & $A \cdot 1 = A$ & $A+0 = A$ \\
            T. di elemento nullo & $A \cdot 0 = 0$ & $A+1 = 1$ \\
            T. d'idempotenza & $AA = A$ & $B+B = B$ \\
            T. d'involuzione & $\overline{\overline{B}} = B$ & $\overline{\overline{B}} = B$ \\
            T. del complementare & $\overline{B}B = 0$ & $\overline{B}+B = 1$ \\
            P. commutativa & $AB = BA$ & $A + B= B + A$ \\
            P. associativa & $(AB) C = A (BC)$ & $(A + B) + C = A + (B + C)$ \\
            P. distributiva & $A (B + C) = AB+AC$ & $A + BC = (A+B)(A+C)$ \\
            1° T. dell'assorbimento & $A+AB = A$ & $A(A+B) = A$ \\
            2° T. dell'assorbimento & $A+\overline{A}B = A+B$ & $A(\overline{A}+B)=AB$\\
            3° T. dell'assorbimento & $AB + \overline{A}B = B$ & $(A+B)(\overline{A}+B) = B$ \\
            T. di DeMorgan & $\overline{AB} = \overline{A} + \overline{B}$ & $\overline{A+B} = \overline{A} \cdot \overline{B}$\\
        \end{tabular}
    \end{center}
    
    \quad
    
    Possiamo provare la \textbf{veridicità} di questi teoremi in due modalità confrontando per confrontando le tavole della verità di entrambi i membri dell'equazione, oppure usando reciprocamente i \textbf{teoremi} e gli \textbf{assiomi}
    
    Una volta appresi gli assiomi e i teoremi dell'algebra booleana, possiamo metterli in pratica cercando di semplificare l'equazione $Y = ABC + \overline{A}\,\overline{B}+\overline{A}$
    
    \begin{enumerate}
        \item Applico il teorema dell'\textbf{assorbimento} $\implies ABC + \overline{A} \, \overline{B}+\overline{A} = ABC + \overline{A} $
        \item Applico la proprietà \textbf{distributiva} $\Rightarrow ABC + \overline{A} = (A+\overline{A})(B+\overline{A})(C+\overline{A})$
        \item Applico il teorema del \textbf{complementare} $\Rightarrow (A+\overline{A})(B+\overline{A})(C+\overline{A}) = (B+\overline{A})(C+\overline{A})$
        \item Applico la proprietà \textbf{distributiva} all'inverso $\Rightarrow (B+\overline{A})(C+\overline{A}) = \overline{A}+BC$
    \end{enumerate}
    
    Concludiamo quindi che: $Y = ABC + \overline{A}\,\overline{B}+\overline{A} = \overline{A}+BC$
    
    Per verificare che la semplificazione sia effettivamente valida e non errata, possiamo definire la tabella della verità rappresentante entrambe le due forme dell'equazione:
    
    \begin{center}
        \begin{tabular}{ c c c | c | c }
            A & B & C & $ABC + \overline{A}\,\overline{B}+\overline{A}$ & $\overline{A}+BC$\\
            \hline
            0 & 0 & 0 & 1 & 1\\
            0 & 0 & 1 & 1 & 1\\
            0 & 1 & 0 & 1 & 1\\
            0 & 1 & 1 & 1 & 1\\
            1 & 0 & 0 & 0 & 0\\
            1 & 0 & 1 & 0 & 0\\
            1 & 1 & 1 & 1 & 1\\
            \\
        \end{tabular}
    \end{center}
    
    Proviamo ora invece a semplificare l'equazione $Y = (A + BC)(A + DE)$. In questo caso, possiamo applicare la proprietà distributiva in due modi diversi:
    
    \begin{enumerate}
        \item Duale della p. distributiva in modo inverso:
        
        \begin{itemize}
            \item $(A + BC)(A + DE) = A + (BC \cdot DE) = A+BCDE$
        \end{itemize}
        
        \item Distribuisco (A + BC) in (A + DE) per poi applicare il duale del primo teorema dell'assorbimento:
        
        \begin{itemize}
            \item $(A + BC)(A + DE) = AA + ADE + ABC + BCDE = A + ADE + ABC + BCDE$
            \item $AA + ADE + ABC + BCDE = A + ABC + BCDE = A + BCDE$
        \end{itemize}
    \end{enumerate}
    
    \subsection{Bubble Pushing}
    
    Il \textbf{Teorema di DeMorgan} stabilisce che il \textbf{complemento dei prodotti} equivale alla \textbf{somma dei complementi} e che di conseguenza il suo duale afferma che il \textbf{complemento della somma} equivale al \textbf{prodotto dei complementi}. Nonostante possa sembrare poco intuitivo, questo teorema può essere anche rivisitato in \textbf{forma grafica}, rendendo la sua interpretazione più semplice:
    
    \begin{center}
        \begin{tabular}{c c c}
            \\
            \color{blue}\textsf{\textbf{NAND}}\color{black} && \color{blue}\textsf{\textbf{OR}}\color{black} \\
            
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=east, nand port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A}
                    (port.in 2) node (B1)[anchor=east]{B};
            \end{circuitikz} 
            & \quad$\Longrightarrow$\quad\qquad &
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=east, or port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A}
                    (port.in 2) node (B1)[anchor=east]{B};
                \node at (port.bin 1) [ocirc, left]{} ;
                \node at (port.bin 2) [ocirc, left]{} ;
            \end{circuitikz} \\
             
            $ Y = \overline{AB}$ &  & $ Y = \overline{A} + \overline{B}$\\
        \end{tabular}
        \begin{tabular}{c c c}
            \\
            \color{blue}\textsf{\textbf{NOR}}\color{black} && \color{blue}\textsf{\textbf{AND}}\color{black} \\
            
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=east, nor port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A}
                    (port.in 2) node (B1)[anchor=east]{B};
            \end{circuitikz} 
            & \quad$\Longrightarrow$\quad\qquad &
            \begin{circuitikz}
                \draw
                    (0,2) node (port) [anchor=east, and port]{}
                    (port.out)  node  [anchor=west]{Y}
                    (port.in 1) node (A1)[anchor=east]{A}
                    (port.in 2) node (B1)[anchor=east]{B};
                \node at (port.bin 1) [ocirc, left]{} ;
                \node at (port.bin 2) [ocirc, left]{} ;
            \end{circuitikz} \\\\
             
            $ Y = \overline{A+B}$ & & $ Y = \overline{A} \cdot \overline{B}$\\\\
        \end{tabular}
    \end{center}
    
    \newpage
    
    Come possiamo notare nell'immagine precedente, l'appicazione del teorema di DeMorgan corrisponde all'invertire un AND con un OR (o viceversa) e allo spostare la \textit{bolla} del NOT \textbf{dall'output agli input} (o viceversa).
    
    Per via di quest'ultima impostazione a livello grafico, nell'ambito della progettazione dei sistemi digitali è nata una \textit{convenzione}, chiamata \textbf{bubble pushing}, dove si cerca di spostare tutte le bolle NOT presenti nel circuito da sinistra verso destra (\textbf{forward bubble pushing}) oppure da destra verso sinistra (\textbf{backwards bubble pushing}), rendendo più fluido il processo di semplificazione.
    
    Proviamo a semplificare il seguente circuito utilizzando il \textbf{backwards} bubble pushing:
    
    \begin{enumerate}
        \item Partendo da destra, utilizziamo il \textbf{bubble pushing} sull'output della porta NAND finale
        
        \begin{center}
            \begin{circuitikz}
                \ctikzset{nodes width=0.07}
                %nodes%
                \draw
                    (0,1) node (NOR_1) [anchor=east, nor port]{}
                    (3.5,-0.5) node (NAND_1) [anchor=east, nand port]{}
                    (7,-1.5) node (NAND_2) [anchor=east, and port]{};
                %connections%
                \draw
                    (NOR_1.out)  node  [anchor=west]{}
                    (NOR_1.in 1) node (A1)[anchor=east]{A}
                    (NOR_1.in 2) node (B1)[anchor=east]{B}
                    (NOR_1.out) -| (NAND_1.in 1)
                    
                    (NAND_1.in 2) -- ++(-3.5,0) node[left](C){C}
                    (NAND_1.out) -| (NAND_2.in 1)
                    
                    (NAND_2.in 2) -- ++(-7,0) node[left](D){D}
                    (NAND_2.out) node (Y)[anchor=west]{Y};
                \node at (NAND_2.bout) [ocirc, right, fill=red]{};
            \end{circuitikz}
        \end{center}
        
        \quad
        
        \item Successivamente, possiamo \textbf{semplificare} il NOT in uscita dalla porta NAND centrale con il NOT in entrata alla porta OR appena modificata. Inoltre, possiamo applicare nuovamente il \textbf{bubble pushing} sull'output della porta NOR iniziale.
        
        \begin{center}
            \begin{circuitikz}
                \ctikzset{nodes width=0.07}
                %nodes%
                \draw
                    (0,1) node (NOR_1) [anchor=east, or port]{}
                    (3.5,-0.5) node (NAND_1) [anchor=east, and port]{}
                    (7,-1.5) node (NAND_2) [anchor=east, or port]{};
                %connections%
                \draw
                    (NOR_1.out)  node  [anchor=west]{}
                    (NOR_1.in 1) node (A1)[anchor=east]{A}
                    (NOR_1.in 2) node (B1)[anchor=east]{B}
                    (NOR_1.out) -| (NAND_1.in 1)
                    
                    (NAND_1.in 2) -- ++(-3.5,0) node[left](C){C}
                    (NAND_1.out) -| (NAND_2.in 1)
                    
                    (NAND_2.in 2) -- ++(-7,0) node[left](D){D}
                    (NAND_2.out) node (Y)[anchor=west]{Y};
                    
                \node at (NOR_1.bout) [ocirc, right, fill=red]{};
                \node at (NAND_1.bout) [ocirc, right, fill=red]{};
                \node at (NAND_2.bin 1) [ocirc, left, fill=red]{};
                \node at (NAND_2.bin 2) [ocirc, left]{} ;
            \end{circuitikz}
        \end{center}
        
        \quad
        
        \item Una volta effettuati i passaggi, abbiamo ottenuto una versione semplificata del circuito, dove abbiamo applicato il \textbf{teorema di DeMorgan} in forma grafica
        
        \begin{center}
            \begin{circuitikz}
                \ctikzset{nodes width=0.07}
                %nodes%
                \draw
                    (0,1) node (NOR_1) [anchor=east, and port]{}
                    (3.5,-0.5) node (NAND_1) [anchor=east, and port]{}
                    (7,-1.5) node (NAND_2) [anchor=east, or port]{};
                %connections%
                \draw
                    (NOR_1.out)  node  [anchor=west]{}
                    (NOR_1.in 1) node (A1)[anchor=east]{A}
                    (NOR_1.in 2) node (B1)[anchor=east]{B}
                    (NOR_1.out) -| (NAND_1.in 1)
                    
                    (NAND_1.in 2) -- ++(-3.5,0) node[left](C){C}
                    (NAND_1.out) -| (NAND_2.in 1)
                    
                    (NAND_2.in 2) -- ++(-7,0) node[left](D){D}
                    (NAND_2.out) node (Y)[anchor=west]{Y};
                    
                \node at (NOR_1.bin 1) [ocirc, left]{};
                \node at (NOR_1.bin 2) [ocirc, left]{};
                \node at (NAND_2.bin 2) [ocirc, left]{} ;
            \end{circuitikz}
        \end{center}
    \end{enumerate}
    
    \subsubsection{Completezza delle porte}
    
    Una volta discussi tutti gli assiomi e teoremi fondanti dell'algebra di Boole, è possibile notare una sua particolare  caratteristica, ossia la \textbf{completezza funzionale} posseduta dalle porte \textbf{NAND} e \textbf{NOR}, poiché \textbf{tutte le porte} sono realizzabili tramite l'uso di solo queste due semplici porte e l'applicazione dei teoremi su di essi:
    
    \begin{center}
        \begin{tabular}{| c | c | c |}
            \hline
            \textbf{Porta} & \textbf{Soli NAND} & \textbf{Soli NOR} \\
            \hline
            $\overline{A}$ & $\overline{A \cdot A}$ & $\overline{A + A}$ \\
            $A \cdot B$ & $\overline{\overline{A \cdot B} \cdot \overline{A \cdot B}}$ & $\overline{\overline{A + A} + \overline{B + B}}$ \\
            $A + B$ & $\overline{\overline{A \cdot A} \cdot \overline{B \cdot B}}$ & $\overline{\overline{A + B} + \overline{A + B}}$ \\
            ... & ... & ... \\
            \hline
        \end{tabular}
    \end{center}
    
    \section{Dalla logica ai circuiti}
    
    \subsubsection{Regole di lettura}
    
    Nell'ambito dei circuiti, esistono alcune \textbf{regole di lettura generali} adottate come standard:
    
    \begin{itemize}
        \item Gli input partono da \textbf{sinistra} (o dall'alto)
        \item Gli output vanno verso \textbf{destra} (o verso il basso)
        \item Le porte vanno da \textbf{destra a sinistra}
        \item Si preferisce l'uso di fili \textbf{non curvi} per facilitare la lettura dei collegamenti
        \item I fili che formano un \textbf{incrocio a T} sono connessi tra loro
        \item I fili che formano un \textbf{incrocio normale} non sono connessi tra loro
        \item I fili che formano un \textbf{incrocio normale} ed hanno un \textbf{pallino} al centro sono connessi tra loro
    \end{itemize}
    
    \subsection{Output multipli, X e Z}
    
    Fin'ora abbiamo visto solo circuiti ad output singolo, tuttavia in elettronica digitale esiste una grande gamma di circuiti ad \textbf{output multiplo}.
    
    In particolare, di seguito vedremo il funzionamento di un \textbf{circuito prioritario}, il quale, dati \textbf{N input},  restituisce \textbf{N output}, dove però \textbf{solo un output} assume valore 1, mentre tutti gli altri assumono valore 0. Quale tra gli N output sarà vero viene stabilito in base al \textbf{valore vero più significativo} assunto dagli input.
    
    Immaginando un circuito composto dagli input $A_3$ $A_2$ $A_1$ $A_0$ e gli output $Y_3$ $Y_2$ $Y_1$ $Y_0$, nel caso in cui $A_3$ sia \textbf{vero} allora l'output $Y_3$ sarà \textbf{vero}, mentre tutti gli altri saranno \textbf{falsi}, poiché $A_3$ è il \textbf{valore vero più significativo} in input (dunque ha la precedenza sugli altri).
    
    Nel caso in cui $A_3$ sia \textbf{falso}, il controllo sul valore vero più significativo verrà effettuato sull'\textit{input successivo} nell'ordine di \textbf{precedenza}, ossia $A_2$, rendendo l'output $Y_2$ vero (e tutti gli altri falsi) nel caso in cui $A_2$ sia vero. Questo processo di selezione dell'output in base alla precedenza viene effettuato su ogni input, fino a raggiungere quello con precedenza più bassa (nel nostro esempio $A_0$).
    
    Per capire meglio l'esempio, vediamo una schematica del circuito assieme alla sua tabella della verità sviluppata in base al \textbf{funzionamento} stesso del circuito che abbiamo precedentemente descritto:    

    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c}
                \\\\
                \includegraphics{resources/images/chapter_2/priority_circ_4in_4out.png} 
            \end{tabular} &
            \quad\quad\quad &
            
            \begin{tabular}{c c c c|c c c c}
                $A_3$ & $A_2$ & $A_1$ & $A_0$ & $Y_3$ & $Y_2$ & $Y_1$ & $Y_0$  \\
                \hline
                \color{blue}\textbf{0} & \color{blue}\textbf{0} & \color{blue}\textbf{0} & \color{blue}\textbf{0} & 0 & 0 & 0 & 0\\
                
                \color{blue}\textbf{0} & \color{blue}\textbf{0} & \color{blue}\textbf{0} & \color{blue}\textbf{1} & 0 & 0 & 0 & \color{red}\textbf{1}\color{black}\\
                
                \color{blue}\textbf{0} & \color{blue}\textbf{0} & \color{blue}\textbf{1} & 0 & 0 & 0 & \color{red}\textbf{1}\color{black} & 0\\
                
                \color{blue}\textbf{0} & \color{blue}\textbf{0} & \color{blue}\textbf{1} & 1 & 0 & 0 & \color{red}\textbf{1}\color{black} & 0\\
                
                \color{blue}\textbf{0} & \color{blue}\textbf{1} & 0 & 0 & 0 & \color{red}\textbf{1}\color{black} & 0 & 0\\
                
                \color{blue}\textbf{0} & \color{blue}\textbf{1} & 0 & 1 & 0 & \color{red}\textbf{1}\color{black} & 0 & 0\\
                
                \color{blue}\textbf{0} & \color{blue}\textbf{1} & 1 & 0 & 0 & \color{red}\textbf{1}\color{black} & 0 & 0\\
                
                \color{blue}\textbf{0} & \color{blue}\textbf{1} & 1 & 1 & 0 & \color{red}\textbf{1}\color{black} & 0 & 0\\
                
                \color{blue}\textbf{1} & 0 & 0 & 0 & \color{red}\textbf{1}\color{black} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & 0 & 0 & 1 & \color{red}\textbf{1}\color{black} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & 0 & 1 & 0 & \color{red}\textbf{1}\color{black} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & 0 & 1 & 1 & \color{red}\textbf{1}\color{black} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & 1 & 0 & 0 & \color{red}\textbf{1}\color{black} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & 1 & 0 & 1 & \color{red}\textbf{1}\color{black} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & 1 & 1 & 0 & \color{red}\textbf{1}\color{black} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & 1 & 1 & 1 & \color{red}\textbf{1}\color{black} & 0 & 0 & 0\\
            \end{tabular}
        \end{tabular}
    \end{center}
    
    Per via del modo in cui vengono stabiliti i valori degli output, possiamo direttamente \textbf{ignorare} il valore assunto da tutti gli input \textbf{meno significativi} rispetto all'input con il valore vero più significativo. In questo caso, i valori ignorati vengono definiti con una \textbf{X} e vengono chiamati valori \textbf{don't care} (dall'inglese: di non interesse).
    
    Possiamo quindi riscrivere la tabella indicando anche quali siano i valori don't care presenti nella logica del circuito, per poi semplificarla in una sua versione ristretta:
    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c c c c|c c c c}
                $A_3$ & $A_2$ & $A_1$ & $A_0$ & $Y_3$ & $Y_2$ & $Y_1$ & $Y_0$  \\
                \hline
                0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
                
                0 & 0 & 0 & \color{blue}\textbf{1} & 0 & 0 & 0 & \color{red}\textbf{1}\\
                
                0 & 0 & \color{blue}\textbf{1} & X & 0 & 0 & \color{red}\textbf{1} & 0\\
                
                0 & 0 & \color{blue}\textbf{1} & X & 0 & 0 & \color{red}\textbf{1} & 0\\
                
                0 & \color{blue}\textbf{1} & X & X & 0 & \color{red}\textbf{1} & 0 & 0\\
                
                0 & \color{blue}\textbf{1} & X & X & 0 & \color{red}\textbf{1} & 0 & 0\\
                
                0 & \color{blue}\textbf{1} & X & X & 0 & \color{red}\textbf{1} & 0 & 0\\
                
                0 & \color{blue}\textbf{1} & X & X & 0 & \color{red}\textbf{1} & 0 & 0\\
                
                \color{blue}\textbf{1} & X & X & X & \color{red}\textbf{1} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & X & X & X & \color{red}\textbf{1} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & X & X & X & \color{red}\textbf{1} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & X & X & X & \color{red}\textbf{1} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & X & X & X & \color{red}\textbf{1} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & X & X & X & \color{red}\textbf{1} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & X & X & X & \color{red}\textbf{1} & 0 & 0 & 0\\
                
                \color{blue}\textbf{1} & X & X & X & \color{red}\textbf{1} & 0 & 0 & 0\\
            \end{tabular}
            
            & $\Rightarrow$ &
            
            \begin{tabular}{c}
                \\
                \begin{tabular}{c c c c|c c c c}
                    $A_3$ & $A_2$ & $A_1$ & $A_0$ & $Y_3$ & $Y_2$ & $Y_1$ & $Y_0$  \\
                    \hline
                    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
                    
                    0 & 0 & 0 & \color{blue}\textbf{1} & 0 & 0 & 0 & \color{red}\textbf{1}\\
                    
                    0 & 0 & \color{blue}\textbf{1} & X & 0 & 0 & \color{red}\textbf{1} & 0\\
                    
                    0 & \color{blue}\textbf{1} & X & X & 0 & \color{red}\textbf{1} & 0 & 0\\
                    
                    \color{blue}\textbf{1} & X & X & X & \color{red}\textbf{1} & 0 & 0 & 0\\
                \end{tabular}
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \subsubsection{Occhio alle X e alle Z!} \label{X_Z}
    
    Nell'ambito dei circuiti, una X \textbf{non} viene utilizzata \textbf{solo} nel caso in cui ci si trovi davanti ad un valore \textbf{don't care}, bensì viene utilizzata per indicare la presenza di un \textbf{valore conteso (o ignoto)} tra uno 0 ed un 1, ossia la presenza di un \textbf{errore} nella progettazione di un circuito.
    
    \begin{itemize}
        \item \textbf{Contesa}: il circuito tenta di generare in output sia uno 0 che un 1
        \item Il vero valore assunto è \textbf{tra 0 ed 1}, ma potrebbe essere interpretato come uno 0, un 1 oppure una zona proibita
        \item Il risultato potrebbe \textbf{cambiare} in base a voltaggio, temperatura, tempo e rumore magnetico
        \item Spesso causa un'eccessiva dissipazione di energia
    \end{itemize}
        
    \quad
    
    \begin{center}
         \begin{circuitikz}
            \draw
                (0,0) node (port1) [anchor=east, not port]{}
                (0,-2) node (port2) [anchor=east, not port]{}
                (2.5, -1) node (middle) [anchor=east]{Y = X}
                
                (port1.in) node (A1)[anchor=east]{A = 1}
                (port2.in) node (B1)[anchor=east]{B = 0};
            \draw (port1.out) |- (middle);
            \draw (port2.out) |- (middle);
        \end{circuitikz}
    \end{center}
    
    \quad
    
    Tuttavia, esiste anche \textbf{un'altra casistica} in cui un output può assumere un valore pari a 0, ad 1 o tra 0 ed 1, ossia nel caso in cui si presenti un \textbf{alta impedenza (o floating value)}, che viene indicata con il valore \textbf{Z}.
    
    A differenza del valore conteso, il valore assunto da una Z può essere \textbf{cambiato} nel caso in cui ci sia un \textbf{altro segnale} elettrico connesso ad esso (indicato con E). In questo caso, si parla di un \textbf{buffer tristate (o triplo stato)}, dove l'output può assumere valore 0, 1 o Z a seconda dello \textbf{stato del secondo segnale}:
    
    \begin{center}
        \begin{tabular}{c c c}
        \\
            \begin{tabular}{c}
            \\
                \begin{circuitikz}
                   \draw (0,0) node (port) [anchor=east, buffer]{}
                        node (E) [above of= port]{E}
                        node (E1) [above of= port, yshift=-23.25]{}
                        (port.in) node (A) [anchor=east]{A}
                        (port.out) node (Y) [anchor=west]{Y};
                    \draw (E) -- (E1);
                \end{circuitikz}
            \end{tabular}
            
            & \qquad\qquad\qquad\qquad &
            
            \begin{tabular}{c c |c}
                E & A & Y \\
                \hline
                0 & 0 & Z \\
                0 & 1 & Z \\
                1 & 0 & 0 \\
                1 & 1 & 1 \\
            \end{tabular}
            
            \\\\
        \end{tabular}
    \end{center}
    
    In un buffer tristate, quindi, nel caso in cui il segnale di controllo E \textbf{non sia attivo}, allora si avrà un \textbf{valore Z} come output, mentre nel caso in cui E \textbf{sia attivo}, allora l'output sarà uguale al \textbf{valore di input} (ossia A).
    
    \subsection{Le Mappe di Karnaugh (K-Maps)}
    
    Per facilitare l'applicazione dei due \textbf{teoremi dell'assorbimento} previsti dall'algebra booleana, il matematico Maurice Karnaugh inventò un metodo grafico costituito da una \textbf{mappatura} dei mintermini e dei maxtermini di un'equazione booleana, dove, seguendo delle semplici regole, è possibile semplificare ai minimi termini quest'ultima. Questa rappresentazione grafica viene chiamata \textbf{Mappa di Karnaugh (o K-Maps)}.
    
    La struttura delle K-map prevede la \textbf{traslazione} degli output di una funzione, descritti all'interno della sua tabella della verità, in una mappatura che mette a confronto i \textbf{termini simili tra loro}.
    
    \begin{center}
        \begin{tabular}{c c c c}
            \begin{tabular}{c c c | c}
                A & B & C & Y \\
                \hline
                0 & 0 & 0 & \color{blue}\textbf{1} \\
                0 & 0 & 1 & \color{blue}\textbf{1} \\
                0 & 1 & 0 & 0 \\
                0 & 1 & 1 & 0 \\
                1 & 0 & 0 & 0 \\
                1 & 0 & 1 & 0 \\
                1 & 1 & 0 & 0 \\
                1 & 1 & 1 & 0 \\
            \end{tabular}
             & 
             \qquad
             &
             \begin{tabular}{c}
                \\\\
                 \begin{karnaugh-map}[4][2][1][AB][C]
                    \terms{0,4}{\color{blue}\textbf{1}}
                    \autoterms[0]
                 \end{karnaugh-map}
             \end{tabular}
             &
             \begin{tabular}{c}
                \\\\
                 \begin{karnaugh-map}[4][2][1][AB][C] 
                     \terms{0}{\color{blue}\textbf{$\overline{A}\overline{B}\overline{C}$}}
                     \terms{4}{\color{blue}\textbf{$\overline{A}\overline{B}C$}}
                    \terms{1}{$\overline{A}B\overline{C}$}
                    \terms{3}{$AB\overline{C}$}
                    \terms{2}{$A\overline{B}\overline{C}$}
                    \terms{5}{$\overline{A}BC$}
                    \terms{7}{$ABC$}
                    \terms{6}{$A\overline{B}C$}
                 \end{karnaugh-map}
             \end{tabular}
        \end{tabular}
    \end{center}
    
    Normalmente, potremmo riscrivere questa funzione in \textbf{forma SOP} (o POS) utilizzando i mintermini (o maxtermini) descritti nella sua tabella della verità, ottenendo l'equazione $Y = \overline{A} \cdot \overline{B} \cdot \overline{C} + \overline{A} \cdot \overline{B} \cdot C$. Successivamente, potremmo applicare il \textbf{teorema dell'assorbimento} per semplificare l'equazione ottenuta, ottenendo l'equazione finale $Y = \overline{A} \cdot \overline{B}$.
    
    Guardando le K-map descritte sopra, possiamo notare la vicinanza tra i due mintermini che assumono valore 1, ossia i mintermini nelle posizioni (AB=00; C=0) e (AB=00, C=0). Confrontando questi due mintermini, possiamo notare come l'unica \textbf{differenza tra essi} sia il literal definito da C. Possiamo quindi \textbf{raggruppare} graficamente sulla mappa questi due mintermini e considerare \textbf{solo} la loro \textbf{parte in comune}, ossia l'\textbf{implicante} $\overline{A} \cdot \overline{B}$. Poiché esso è l'unico implicante presente nella mappa, possiamo direttamente scrivere l'equazione minima come $Y = \overline{A} \cdot \overline{B}$.
    
    \begin{center}
        \begin{tabular}{c c c}
             \begin{karnaugh-map}[4][2][1][AB][C]
                \terms{0,4}{\color{blue}\textbf{1}}
                \autoterms[0]
                \implicant{0}{4}
             \end{karnaugh-map}
             &
             \begin{karnaugh-map}[4][2][1][AB][C] 
                 \terms{0}{\color{blue}\textbf{$\overline{A}\overline{B}\overline{C}$}}
                 \terms{4}{\color{blue}\textbf{$\overline{A}\overline{B}C$}}
                \terms{1}{$\overline{A}B\overline{C}$}
                \terms{3}{$AB\overline{C}$}
                \terms{2}{$A\overline{B}\overline{C}$}
                \terms{5}{$\overline{A}BC$}
                \terms{7}{$ABC$}
                \terms{6}{$A\overline{B}C$}
                
             \end{karnaugh-map}
        \end{tabular}
    \end{center}
    
    In questo modo, abbiamo applicato il teorema dell'assorbimento in un modo estremamente semplificato, permettendoci di ottenere direttamente la \textbf{forma minima possibile} con cui è possibile rappresentare l'equazione descritta nella tabella della verità.
    
    
    \subsubsection{Regole per i raggruppamenti} \label{regole_kmap}
    
    \begin{itemize}
        \item Ogni 1 deve essere raggruppato \textbf{almeno una volta}, anche se solo con se stesso (implicante ad 1 variabile)
        \item Ogni raggruppamento può estendersi \textbf{solo} per una quantità di quadrati pari ad una \textbf{potenza di 2} (1, 2, 4, ...) in ogni direzione
        \item Ogni raggruppamento deve essere \textbf{il più grande possibile}, in modo da poter ridurre ai termini minimi possibili. Inoltre, il raggruppamento più grande presente in una K-map viene chiamato \textbf{implicante primo}.
        \item I raggruppamenti possono estendersi \textbf{oltre i bordi}, ad esempio in una mappa a 3 valori è possibile raggruppare le celle (AB=0; C=0) e (AB=10; C=0) se entrambe presentano degli 1
        \item Un valore \textbf{don't care (X)} può essere raggruppato, ma solo se è utile per minimizzare l'equazione, altrimenti può essere ignorato
    \end{itemize}
    
    Le K-map sono \textbf{duali}, dunque possono essere utilizzate non solo per le forme SOP, ma anche per le \textbf{forme POS}: i raggruppamenti vengono effettuati tra gli \textbf{0} ed ogni quadrato rappresenta un \textbf{maxterm}.
    
    \newpage

    \subsubsection{Esempi di semplificazioni tramite le K-map}
    
    Ovviamente, applicare manualmente il teorema dell'assorbimento nell'esempio precedentemente visto risulta molto banale, dunque utilizzare le K-map potrebbe essere visto come una perdita di tempo. Tuttavia, esse risultano \textbf{estremamente comode} nel caso in cui ci si trovi dinnanzi ad una funzione con molti output possibili, come nel seguente esempio:
    
    \begin{center}
        \begin{tabular}{c c c}
        \\
            \begin{tabular}{c c c c | c}
                A & B & C & D & Y \\
                \hline
                0 & 0 & 0 & 0 & 1 \\
                0 & 0 & 0 & 1 & 0 \\
                0 & 0 & 1 & 0 & 1 \\
                0 & 0 & 1 & 1 & 1 \\
                0 & 1 & 0 & 0 & 0 \\
                0 & 1 & 0 & 1 & 1 \\
                0 & 1 & 1 & 0 & 1 \\
                0 & 1 & 1 & 1 & 1 \\
                1 & 0 & 0 & 0 & 1 \\
                1 & 0 & 0 & 1 & 1 \\
                1 & 0 & 1 & 0 & 1 \\
                1 & 0 & 1 & 1 & 0 \\
                1 & 1 & 0 & 0 & 0 \\
                1 & 1 & 0 & 1 & 0 \\
                1 & 1 & 1 & 0 & 0 \\
                1 & 1 & 1 & 1 & 0 \\
            \end{tabular}
             & 
             \qquad\qquad\qquad
             &
             \begin{tabular}{c}
                 \begin{karnaugh-map}[4][4][1][AB][CD]
                    \minterms{0,2,5,6,8,9,10,12,13}
                    \autoterms[0]
                    
                    \implicantcorner
                    \implicant{12}{9}
                    \implicant{5}{13}
                    \implicant{2}{6}
                \end{karnaugh-map}
                \\
                $Y = \overline{B}\,\overline{D} + \overline{A}C + \overline{A}BD + A\overline{B}\,\overline{C}$
             \end{tabular}
        \end{tabular}
    \end{center}
    
    Per comprendere meglio i passaggi effettuati per ottenere gli implicanti che costituiscono l'equazione finale in base ai raggruppamenti effettuati, analizziamo quest'ultimi e i loro termini comuni:
    
    \begin{itemize}
        
        \item \color{red}\textbf{Raggruppamento 1}\color{black}: ognuno dei 4 implicanti raggruppati contiene $\overline{B}$ e $\overline{D}$, dunque l'implicante minimo corrispondente sarà $\overline{B}\,\overline{D}$
        
        \item \color{DarkGreen}\textbf{Raggruppamento 2}\color{black}: ognuno dei 4 implicanti raggruppati contiene $\overline{A}$ e $C$, dunque l'implicante minimo corrispondente sarà $\overline{A}C$
        
        \item \color{orange}\textbf{Raggruppamento 3}\color{black}: ognuno dei 2 implicanti raggruppati contiene $\overline{A}$, $B$ e $D$, dunque l'implicante minimo corrispondente sarà $\overline{A}BD$
        
        \item \color{teal}\textbf{Raggruppamento 4}\color{black}: ognuno dei 2 implicanti raggruppati contiene $A$, $\overline{B}$ e $\overline{C}$, dunque l'implicante minimo corrispondente sarà $A\overline{B}\,\overline{D}$
    \end{itemize}
    
    \newpage
    
    \subsubsection{K-Map con Don't care}
    
    Vediamo ora una situazione simile alla precedente, dove però alcuni output sono stati sostituiti ad un valore \textbf{don't care (X)}:
    
    \begin{center}
        \begin{tabular}{c c c}
        \\
            \begin{tabular}{c c c c | c}
                A & B & C & D & Y \\
                \hline
                0 & 0 & 0 & 0 & 1 \\
                0 & 0 & 0 & 1 & 0 \\
                0 & 0 & 1 & 0 & 1 \\
                0 & 0 & 1 & 1 & 1 \\
                0 & 1 & 0 & 0 & 0 \\
                0 & 1 & 0 & 1 & X \\
                0 & 1 & 1 & 0 & 1 \\
                0 & 1 & 1 & 1 & 1 \\
                1 & 0 & 0 & 0 & 1 \\
                1 & 0 & 0 & 1 & 1 \\
                1 & 0 & 1 & 0 & X \\
                1 & 0 & 1 & 1 & X \\
                1 & 1 & 0 & 0 & X \\
                1 & 1 & 0 & 1 & X \\
                1 & 1 & 1 & 0 & X \\
                1 & 1 & 1 & 1 & X \\\\
            \end{tabular}
             & 
             \qquad\qquad\qquad
             &
             \begin{tabular}{c}
                 \begin{karnaugh-map}[4][4][1][AB][CD]
                    \minterms{0,2,6,8,9,12,13}
                    \maxterms{1,4}
                    \autoterms[X]
                    
                    \implicantcorner
                    \implicant{3}{10}
                    \implicant{12}{10}
                \end{karnaugh-map}
                \\
                $Y = \overline{B}\,\overline{D} + A + C$
             \end{tabular}
        \end{tabular}
    \end{center}
    
    \quad
    
    Notiamo come in questo caso una X non sia stata raggruppata. Il motivo è semplice: nel caso in cui venisse raggruppata si andrebbe ad un \textbf{mintermine eccessivo}, poiché tutti gli 1 sono già stati coperti (vedi le regole nella sezione \ref{regole_kmap}). 
    
    
    \subsubsection{K-map con Maxtermini}
    
    Le K-map possono essere utilizzate non solo per semplificare un equazione in forma minima SOP, ma anche in \textbf{forma minima POS}.
    
    Le regole in gioco sono le stesse ma a parti invertite: \textbf{vengono raggruppati gli 0} e gli elementi in comune vengono riscritti \textbf{sottoforma di maxtermini} (ad esempio: AB = 10, CD = 00 verrà riscritto come $(\overline{A} + B + C + D)$.
    
    Nei casi in cui vi è una grande quantità di 1 all'interno della tavola della verità dell'equazione di cui vogliamo trovare la forma minima (come nell'esempio precedente), è conveniente utilizzare questa versione in forma POS delle K-map, poiché \textbf{più rapida}.
    
    
    \begin{center}
        \begin{tabular}{c c c}
        \\
            \begin{tabular}{c c c c | c}
                A & B & C & D & Y \\
                \hline
                0 & 0 & 0 & 0 & 1 \\
                0 & 0 & 0 & 1 & 0 \\
                0 & 0 & 1 & 0 & 1 \\
                0 & 0 & 1 & 1 & 1 \\
                0 & 1 & 0 & 0 & 0 \\
                0 & 1 & 0 & 1 & X \\
                0 & 1 & 1 & 0 & 1 \\
                0 & 1 & 1 & 1 & 1 \\
                1 & 0 & 0 & 0 & 1 \\
                1 & 0 & 0 & 1 & 1 \\
                1 & 0 & 1 & 0 & X \\
                1 & 0 & 1 & 1 & X \\
                1 & 1 & 0 & 0 & X \\
                1 & 1 & 0 & 1 & X \\
                1 & 1 & 1 & 0 & X \\
                1 & 1 & 1 & 1 & X \\\\
            \end{tabular}
             & 
             \qquad\qquad\qquad
             &
             \begin{tabular}{c}
                \begin{karnaugh-map}[4][4][1][AB][CD]
                    \minterms{0,2,6,8,9,12,13}
                    \maxterms{1,4}
                    \autoterms[X]
                    
                    
                    \implicant{4}{5}
                    \implicant{1}{7}
                \end{karnaugh-map}
                \\
                $Y = (\overline{B} + C)(A + C + \overline{D})$
             \end{tabular}
        \end{tabular}
    \end{center}
    
    \underline{\textbf{ATTENZIONE:}}, ricordiamo che la forma POS e la forma SOP sono \textbf{equivalenti}, dunque scegliere quale delle due "tecniche" applicare è indifferente sul risultato.
    
    Tuttavia, notiamo come provando a convertire la forma POS ricavata in una forma SOP, \textbf{non otteniamo la stessa SOP} ricavata nell'esempio precedente.
    
    \[(\overline{B} + C)(A + C + \overline{D}) = \overline{B}A + \overline{B}C + \overline{B} \, \overline{D} + CA + C + C\overline{D} = \overline{B}A + \overline{B}\,\overline{D} + C\]
    
    Ma come? Non dovrebbero essere equivalenti le due forme SOP e POS?
    
    Niente panico: l'\textbf{incongruenza} è dovuta all'uso di alcuni \textbf{don't care diversi} tra i due raggruppamenti. Il funzionamento dell'equazione, tuttavia, è lo stesso, poiché ricordiamo che, per definizione stessa, \textbf{possiamo ignorare i casi in cui si verifica un termine don't care}.
    
    
    \subsection{Logica combinazionale multi-livello}
    
    Nonostante siano molto semplici da realizzare, i circuiti con una \textbf{logica a due livelli} (ossia riducibili a forme SOP e POS) di grandi dimensioni richiedono molto più hardware per essere realizzati, dunque più costosi, rispetto a dei circuiti con \textbf{logica multi-livello}. Inoltre, tecniche come il \textit{bubble pushing} risultano molto più utili su quest'ultimi, piuttosto che sui primi.
    
    \newpage

    Basti immaginare come per costruire uno \textbf{XOR ad 8 input} servano 7 XOR a 2 input interconnessi tra loro, dove (ricordando che $Y = A \oplus B = \overline{A}B + A\overline{B}$) ognuno di quest'ultimi è composto a sua volta da \textbf{due AND} ed \textbf{un OR}. Per realizzare un singolo componente, dunque, la quantità di elementi necessari sarebbe \textbf{elevata} e poco gestibile.
    
    \quad
    
    \begin{center}
        \begin{circuitikz}
           \draw
           (0,0) node (xor1)[anchor=west, xor port]{}
           (xor1.in 1) node (A)[anchor=east]{A}
           (xor1.in 2) node (B)[anchor=east]{B}
           
           (0,-1.5) node (xor2)[anchor=west, xor port]{}
           (xor2.in 1) node (C)[anchor=east]{C}
           (xor2.in 2) node (D)[anchor=east]{D}
           
           (0,-3) node (xor3)[anchor=west, xor port]{}
           (xor3.in 1) node (E)[anchor=east]{E}
           (xor3.in 2) node (F)[anchor=east]{F}
           
           (0,-4.5) node (xor4)[anchor=west, xor port]{}
           (xor4.in 1) node (G)[anchor=east]{G}
           (xor4.in 2) node (H)[anchor=east]{H}
           
           (2.5, -0.75) node (xor5)[anchor=west, xor port]{}
           (xor1.out) |- (xor5.in 1)
           (xor2.out) |- (xor5.in 2)
           
           (2.5, -3.75) node (xor6)[anchor=west, xor port]{}
           (xor3.out) |- (xor6.in 1)
           (xor4.out) |- (xor6.in 2)
           
           (5, -2.25) node (xor7)[anchor=west, xor port]{}
           (xor7.out) node (Y)[anchor=west]{Y}
           (xor5.out) |- (xor7.in 1)
           (xor6.out) |- (xor7.in 2)
           ;
        \end{circuitikz}
        
        $Y = A \oplus B \oplus C \oplus D \oplus E \oplus F \oplus G \oplus H$
    \end{center}
    
    \quad
    
    Nei circuiti con \textbf{logica multi-livello}, i due componenti principali utilizzati che vedremo sono il \textbf{multiplexer} e il \textbf{decoder}.
    
    \subsubsection{Multiplexer}
    
    Il \textbf{multiplexer (o MUX)} è un componente che si occupa di \textbf{selezionare solo uno di N input}, collegandolo direttamente all'output. La selezione dell'input avviene tramite un ulteriore \textbf{input di controllo}, dove in base al suo stato viene deciso il valore assunto dall'output. 
    Per capire meglio, vediamo il funzionamento di un \textbf{MUX 2:1}:
    
    \begin{center}
        \begin{tabular}{c c c c c}
             \begin{tabular}{c}
                 \\
                \begin{circuitikz}
                   
                   
                   \draw (0,0) node (mux)[mux 2by1, anchor=west]{}
                   (mux.lpin 1) node (D1)[anchor=east]{$D_0$}
                   (mux.lpin 2) node (D2)[anchor=east]{$D_1$}
                   (mux.tpin 1) node (S)[anchor=south]{$S$}
                   (mux.rpin 1) node (Y)[anchor=west]{$Y$}
                   ;
                \end{circuitikz}
             \end{tabular}
             &
             \qquad\qquad
             & 
             \begin{tabular}{c c c | c}
                  S & $D_1$ & $D_0$ & Y \\
                  \hline
                  0 & 0 & 0 & 0 \\
                  0 & 0 & 1 & 1 \\ 
                  0 & 1 & 0 & 0 \\ 
                  0 & 1 & 1 & 1 \\ 
                  1 & 0 & 0 & 0 \\ 
                  1 & 0 & 1 & 0 \\ 
                  1 & 1 & 0 & 1 \\ 
                  1 & 1 & 1 & 1 
             \end{tabular}
             &
             \qquad\qquad
             &
             
             \begin{tabular}{c}
             
                 \begin{tabular}{c|c}
                      S & Y \\
                      \hline
                      0 & $D_0$ \\
                      1 & $D_1$
                 \end{tabular}
                 \\\\
                 
                 Se S = 0, allora $D_0$ viene scelto \\
                 Se S = 1, allora $D_1$ viene scelto \\
                 
                 \\
                 Dunque, $Y = \overline{S}D_0 + SD_1$
             \end{tabular}
        \end{tabular}
    \end{center}
    
    Come abbiamo visto, è possibile implementare un MUX 2:1 utilizzando \textbf{3 porte logiche}. Tuttavia, è possibile ridurre ancora il numero di componenti necessari, realizzando lo stesso MUX tramite \textbf{2 buffer tristate}:
    
    \begin{center}
        \begin{tabular}{c c c}
             \\
             \begin{circuitikz}
                \draw
                    (0.5,0) node (port1)[and port, anchor=west]{}
                    (port1.in 1) node (D0)[anchor=east]{$D_0$}
                    
                    (0.5,-2) node (port2)[and port, anchor=west]{}
                    (port2.in 2) node (D1)[anchor=east]{$D_1$}
                    
                    (0.25,-1) node (S)[anchor=east]{S}
                    (S) -| (port1.in 2)
                    (S) -| (port2.in 1)
                    
                    (3, -1) node (port3)[or port, anchor=west]{}
                    (port3.out) node (Y)[anchor=west]{Y}
                    (port1.out) -| (port3.in 1)
                    (port2.out) -| (port3.in 2)
                ;
                \node at (port1.bin 2)[ocirc, left]{};
             \end{circuitikz}
             
             &
             \qquad\qquad\qquad
             &
             
            \begin{circuitikz}
               \draw (0,0) node (port) [anchor=east, buffer]{}
                    (port.in) node (D0) [anchor=east]{$D_0$}
                    
                    node (S) [above of= port]{S}
                    node (S1) [ocirc, above of= port, yshift=-17.25]{}
                    (S) -- (S1)
                    
                    node (S2) [below of= port, yshift=23.25 ]{}
                    
                    (0,-2) node (port1) [anchor=east, buffer]{}
                    (port1.in) node (D1) [anchor=east]{$D_1$}
                    
                    node (S3) [above of= port1, yshift=-23.25]{}
                    (S2) -- (S3)
                    
                    (0.5,-1) node (Y0)[circ, anchor=east]{}
                    (1,-1) node (Y1)[anchor=west]{Y}
                    (port.out) -| (Y0)
                    (port1.out) -| (Y0)
                    (Y0) -- (Y1)
                    ;
            \end{circuitikz}
            \\\\\\
        \end{tabular}
    \end{center}
    
    Per via della sua semplicità come componente base, utilizzando tre MUX 2:1, possiamo realizzare ad esempio un \textbf{MUX 4:1}, dunque con 4 input ed 1 solo output:
    
    \begin{center}
    
        \begin{tabular}{c c c c c}
            \begin{tabular}{c}
                \begin{circuitikz}
                   \draw (0,0) node (mux)[mux 2by1, anchor=west]{}
                   (mux.lpin 1) node (D0)[anchor=east]{$D_0$}
                   (mux.lpin 2) node (D1)[anchor=east]{$D_1$}
                   (mux.tpin 1) node (S00)[anchor=south]{$S_0$}
                   (mux.rpin 1) node (Y1)[anchor=west]{}
                   
                   (0,-4) node (mux2)[mux 2by1, anchor=west]{}
                   (mux2.lpin 1) node (D2)[anchor=east]{$D_2$}
                   (mux2.lpin 2) node (D3)[anchor=east]{$D_3$}
                   (mux2.tpin 1) node (S01)[anchor=south]{$S_0$}
                   (mux2.rpin 1) node (Y2)[anchor=west]{}
                   
                   (2.5,-2) node (mux3)[mux 2by1, anchor=west]{}
                   (mux3.lpin 1) node (A)[anchor=east]{}
                   (mux3.lpin 2) node (B)[anchor=east]{}
                   (mux3.tpin 1) node (S1)[anchor=south]{$S_1$}
                   (mux3.rpin 1) node (Y3)[anchor=west]{Y}
                   
                   (mux.rpin 1) -| (mux3.lpin 1)
                   (mux2.rpin 1) -| (mux3.lpin 2)
                   ;
                \end{circuitikz}
                \\\\
            \end{tabular}
            &\quad$\Longrightarrow$\quad&
            
            \begin{tabular}{c}
                \begin{circuitikz}
                   \draw (0,0) node (mux)[mux 4by1, anchor=west]{}
                   (mux.lpin 1) node (D0)[anchor=east]{$D_0$}
                   (mux.lpin 2) node (D1)[anchor=east]{$D_1$}
                   (mux.lpin 3) node (D0)[anchor=east]{$D_2$}
                   (mux.lpin 4) node (D1)[anchor=east]{$D_3$}
                   (mux.tpin 1) node (S0)[anchor=south]{$S_0$}
                   (mux.tpin 2) node (S0)[anchor=south]{$S_1$}
                   (mux.rpin 1) node (Y)[anchor=west]{$Y$};
                \end{circuitikz}
            \end{tabular}
            &
            \qquad\qquad
            &
            \begin{tabular}{c c | c}
                $S_1$ & $S_0$ & Y \\
                \hline
                0 & 0 & $D_0$ \\
                0 & 1 & $D_1$ \\
                1 & 0 & $D_2$ \\
                1 & 1 & $D_3$ \\
            \end{tabular}
            \\\\
        \end{tabular}
    \end{center}
    
    Un'altra importante caratteristica intrinseca al MUX, sempre poiché componente base, è la sua \textbf{completezza} analoga a quella delle porte NAND e NOR. Dunque, è possibile realizzare ogni singola porta logica utilizzando un MUX:
    
    \begin{center}
        \begin{tabular}{c c c c c}
            \color{blue}\textsf{\textbf{NOT}}\color{black} && \color{blue}\textsf{\textbf{AND}}\color{black} && \color{blue}\textsf{\textbf{OR}}\color{black} \\
            
            \begin{circuitikz}
               
               
               \draw (0,0) node (mux)[mux 2by1, anchor=west]{}
               (mux.lpin 1) node (D1)[anchor=east]{$1$}
               (mux.lpin 2) node (D2)[anchor=east]{$0$}
               (mux.tpin 1) node (S)[anchor=south]{$S$}
               (mux.rpin 1) node (Y)[anchor=west]{$Y$}
               ; 
            \end{circuitikz}
            
            &&
            
            \begin{circuitikz}
               
               \draw (0,0) node (mux)[mux 2by1, anchor=west]{}
               (mux.lpin 1) node (D1)[anchor=east]{$0$}
               (mux.lpin 2) node (D2)[anchor=east]{$B$}
               (mux.tpin 1) node (S)[anchor=south]{$S$}
               (mux.rpin 1) node (Y)[anchor=west]{$Y$}
               ; 
            \end{circuitikz}
            
            &&
            \begin{circuitikz}
               \draw (0,0) node (mux)[mux 2by1, anchor=west]{}
               (mux.lpin 1) node (D1)[anchor=east]{$B$}
               (mux.lpin 2) node (D2)[anchor=east]{$1$}
               (mux.tpin 1) node (S)[anchor=south]{$S$}
               (mux.rpin 1) node (Y)[anchor=west]{$Y$}
               ; 
            \end{circuitikz}
            
            \\
            
            $Y = 1 \cdot \overline{S} + 0 \cdot S = \overline{S}$
            
            &\qquad\quad&
            $Y = 0 \cdot \overline{S} + B \cdot S = BS$
            
            &\qquad\quad&
            $Y = B \cdot \overline{S} + 1 \cdot S = B+S$
        \end{tabular}
    \end{center}
    
    \subsubsection{Decoder}
    
    Il \textbf{decoder} è un componente che si occupa di \textbf{selezionare solo uno tra $2^n$ output (codifica one-hot)} generati da  \textit{\textbf{n}} valori in input.
    Al contrario del MUX, la selezione non avviene tramite un aggiuntivo segnale di controllo, bensì essa è intrinseca al decoder stesso. Per capire meglio, vediamo il funzionamento di un \textbf{decoder 2:4}:
    
    \begin{center}
        \begin{tabular}{c c c}
            \\
            \begin{tabular}{c}
                \begin{circuitikz}
                       \draw (0,0) node (dec)[dec 2by4, anchor=west]{}
                       (dec.lpin 1) node (D1)[anchor=east]{$A_0$}
                       (dec.lpin 2) node (D2)[anchor=east]{$A_0$}
                       (dec.rpin 1) node (Y3)[anchor=west]{$Y_3$}
                       (dec.rpin 2) node (Y2)[anchor=west]{$Y_2$}
                       (dec.rpin 3) node (Y1)[anchor=west]{$Y_1$}
                       (dec.rpin 4) node (Y0)[anchor=west]{$Y_0$}
                       ; 
                \end{circuitikz}
            \end{tabular}
            &\qquad\qquad\qquad&
            \begin{tabular}{c c | c c c c}
                $A_1$ & $A_0$ & $Y_3$ & $Y_2$ & $Y_1$ & $Y_0$\\
                \hline
                0 & 0 & 0 & 0 & 0 & 1\\
                0 & 1 & 0 & 0 & 1 & 0\\
                1 & 0 & 0 & 1 & 0 & 0\\
                1 & 1 & 1 & 0 & 0 & 0\\
            \end{tabular}
            \\\\
        \end{tabular}
        
        \begin{tabular}{c c}
            \begin{tabular}{c}
                $
                \left.
                \begin{array}{r}
                    Y_0 = \overline{A_1}\,\overline{A_0} \\
                    Y_1 = \overline{A_1}\,A_0 \\
                    Y_2 = A_1 \,\overline{A_0} \\
                    Y_3 = A_1 \, A_0 \\
                \end{array}
                \right \}
                $
                \\\\\\
            \end{tabular}
            
            &
            \begin{tabular}{l}
                Possiamo notare come gli output del decoder corrispondano a \textbf{tutti}\\
                \textbf{i mintermini} ottenibili con le variabili $A_0$ e $A_1$. Per questo motivo,\\
                potremmo potenzialmente collegare una porta OR a due di questi\\
                output ed ottenere tutte le porte logiche \textbf{(completezza parziale)}
                \\\\
                \qquad\qquad
                es: $A_1 \oplus A_0 = Y_1 + Y_2 = \overline{A_1}\,A_0 + A_1 \,\overline{A_0}$
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \quad
    
    \subsubsection{Teorema di Shannon}
    
    Nell'ambito dei circuiti combinatori multilivello, il \textbf{Teorema di Shannon} afferma che data una funzione booleana \textit{f} di \textit{n} variabili, la seguente  uguaglianza risulta valida:
    
    \[ f(x_1, x_2, ..., x_n) = x_1 \cdot f(1, x_2, ..., x_n) + \overline{x_1} \cdot f(0, x_2, ..., x_n)\]
    
    Questo teorema può essere utilizzato per riscrivere una funzione di n variabili come \textbf{2 funzioni da n-1 variabili}, in modo da poter implementare la funzione originale tramite un \textbf{MUX 2:1}.

    \quad
    
    \subsubsection{Analisi e Sintesi}
    
    Giunti verso la fine del capitolo sui circuiti combinatori, è opportuno precisare due \textbf{terminologie}, in modo che non vengano confuse tra di loro:
    
    \begin{itemize}
        \item Per \textbf{analisi} di un circuito combinatorio si intende l'individuazione della funzione logica realizzata dal circuito, formulata come espressione booleana.
        
        \item Per \textbf{sintesi} di un circuito combinatorio si intende il disegno di un circuito combinatorio a partire da un’espressione booleana (o dalla tabella di verità).
    \end{itemize}

    \newpage
    
    \subsection{Timing dei circuiti}
    
    Fino ad ora abbiamo analizzato i vari circuiti combinatori solo da un punto di vista non del tutto realistico, ignorando un fattore molto importante, ossia il \textbf{tempo}.
    
    In ogni componente di un circuito, è possibile identificare un \textbf{delay}, ossia il tempo trascorso dal variare dell'input al variare dell'output. Questo delay può dipendere da effetti dell'ambiente esterno, come i limiti della velocità della luce, o dal modo in cui è stato costruito il componente stesso, come la sua capacità e la sua resistenza.
    
    \begin{center}
        \includegraphics{resources/images/chapter_2/delay1.png}
    \end{center}

    Possiamo distinguere due categorie di delay: \textbf{delay di contaminazione ($t_{cd}$)} e \textbf{delay di propagazione ($t_{pd}$)}. Il primo corrisponde al \textbf{delay minimo} che deve trascorrere affinché l'output possa essere considerato come variato (dunque non sappiamo ancora se sia effettivamente cambiato). Il secondo, invece, è il \textbf{delay massimo} che deve trascorrere affinché l'output sia considerabile come variato (dunque siamo sicuri al 100\% del suo avvenuto cambiamento)
    
    \begin{center}
        \begin{tabular}{c c}
            \includegraphics[scale=0.9]{resources/images/chapter_2/delay2.png}
            &
            \includegraphics[scale=0.9]{resources/images/chapter_2/delay3.png}
        \end{tabular}
    \end{center}
    
    Durante la progettazione di circuiti, quindi, vengono favoriti gli \textbf{short path}, ossia quei percorsi dove vanno ad accumularsi il minor numero di delay, in modo che il circuito possa essere il più veloce possibile. Nell'esempio sulla destra (non legato a quello sulla sinistra) possiamo notare come A e B passino per un due porte aggiuntive rispetto a D, risultando in un \textbf{critical path (o long path)}:
    \begin{itemize}
        \item Critical Path = $2 \cdot t_{pd_{AND}} + t_{pd_{OR}}$
        \item Short Path = $t_{pd_{AND}}$
    \end{itemize}
    
    %%%%%%%%%%%%%%%%%%%%%
    %%%% NEW CHAPTER %%%%
    %%%%%%%%%%%%%%%%%%%%%

    \chapter{Circuiti sequenziali}\label{circ_seq_def}
    
    Come abbiamo accennato nella sezione \ref{seq_circ_intro}, la caratteristica principale che distingue i \textbf{circuiti sequenziali} da quelli combinatori è la presenza di \textbf{memoria a breve termine}, ossia gli output del circuito dipendono sia dagli input correnti sia dagli output precedenti.
    
    Vediamo ora alcune definizioni che verranno utilizzate nelle sezioni successive:
    \begin{itemize}
        \item \textbf{Stato}: ogni informazione riguardo un circuito necessaria per poter descrivere il suo futuro comportamento
        \item \textbf{Latch e Flip-Flop}: elementi di stato che memorizzano un bit rappresentante lo stato attuale del circuito
        \item \textbf{Circuiti sequenziali sincroni}: circuiti combinatori seguiti da un banco (ossia un insieme) di flip-flop
    \end{itemize}
    
    \section{Elementi di stato}
    
    Gli \textbf{elementi di stato} sono quei componenti circuitali che si occupano di immagazzinare lo \textbf{stato attuale} di un circuito, in modo che quest'ultimo possa influenzare il futuro output del circuito stesso.
    
    In questa sezione analizzeremo i seguenti elementi:
    \begin{itemize}
        \item \textbf{Circuito bistabile}
        \item \textbf{SR Latch}
        \item \textbf{D Latch}
        \item \textbf{D Flip-Flop e le sue varianti}
        \item \textbf{Ring Oscillator}
    \end{itemize}
    
    \newpage
    
    \subsection{Circuito bistabile}
    
    Il \textbf{circuito bistabile} corrisponde al \textbf{blocco portante} tramite cui, imitando la sua logica, vengono realizzati gli altri elementi di stato. Questo circuito possiede \textbf{due output} ($Q$ e $\overline{Q}$) ma, tuttavia, esso \textbf{non possiede input}, dunque non è un reale componente utilizzabile (motivo per cui gli altri elementi di stato \textbf{imitano} la sua logica).
    
    Un circuito bistabile può essere implementato in due modi, in \textit{forma elementare} (sinistra) o in \textit{forma normale} (destra):
    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c}
                \begin{circuitikz}
                        \draw
                            (0,0) node (N1)[not port, anchor=east]{}
                            (2,0) node (N2)[not port, anchor=east]{}
                            node (F)[anchor=east, right of=N2, yshift=-25]{}
                            
                            (N1.out) node (notQ)[anchor=south]{$\overline{Q}$}
                            (N2.out) node (notQ)[anchor=south]{$Q$}
                            
                            (N1.out) -- (N2.in)
                            (N2.out) |- (F)
                            (F) -| (N1.in)
                        ;
                \end{circuitikz}
            \end{tabular}
            &\qquad\qquad\qquad\qquad&
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (0,0) node (N1)[not port, anchor=east]{}
                        ($(N1.out)+(1, 0)$) node (Q1)[anchor=east]{$Q$}
                        
                        (0,-2) node (N2)[not port, anchor=east]{}
                        ($(N2.out)+(1, 0)$) node (Q2)[anchor=east]{$\overline{Q}$}
                        
                        (N2.out) -- +(0, 0.75) -- ($(N1.in)+(0, -0.75)$) -- (N1.in)
                        (N1.out) -- +(0, -0.75) -- ($(N2.in)+(0, 0.75)$) -- (N2.in)
                        (N1.out) -- (Q1)
                        (N2.out) -- (Q2)
                    ;
                \end{circuitikz}
            \end{tabular}
            \\\\
        \end{tabular}
    \end{center}
    
    Immaginando che il segnale elettrico presente nel circuito sia un valore molto vicino a 5V (dunque 1), esso passerà attraverso i \textbf{due inverter} (le porte NOT), che lo renderanno prima pari a un valore molto vicino a 0V (dunque 0) e poi nuovamente un valore ancora più vicino a 5V (dunque sempre 1). Nel caso in cui il segnale elettrico sia un valore molto vicino a 0V, esso verrà prima trasformato in un valore molto vicino a 5V e poi nuovamente in un valore ancora più vicino a 0V.
    
    Poiché non vi sono interferenze esterne, questo ciclo di avvicinamento costante a 5V e 0V è \textbf{perpetuo}, rendendo il circuito bistabile in grado di conservare il suo \textbf{stato}.
    
    \subsection{SR Latch}
    
    Una volta vista la logica alla base degli elementi di stato, possiamo introdurre il primo elemento realmente utilizzabile, ossia il \textbf{Set/Reset Latch}. A differenza dei circuiti bistabili, questo componente è dotato di due porte NOR (al posto delle due porte NOT) e di \textbf{due input}, chiamati \textbf{Set} e \textbf{Reset}, che permettono di \textbf{modificare} lo stato del circuito.
    
    \quad
    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (0,0) node (N1)[nor port, anchor=east]{}
                        ($(N1.out)+(1, 0)$) node (Q1)[anchor=east]{$Q$}
                        ($(N1.in 1)+(-0.75, 0)$) node (R)[anchor=east]{$R$}
                        
                        (0,-2) node (N2)[nor port, anchor=east]{}
                        ($(N2.out)+(1, 0)$) node (Q2)[anchor=east]{$\overline{Q}$}
                        ($(N2.in 2)+(-0.75, 0)$) node (S)[anchor=east]{$S$}
                        
                        (N2.out) -- +(0, 0.5) -- ($(N1.in 2)+(0, -0.5)$) -- (N1.in 2)
                        (N1.out) -- +(0, -0.5) -- ($(N2.in 1)+(0, 0.5)$) -- (N2.in 1)
                        (N1.out) -- (Q1)
                        (N2.out) -- (Q2)
                        (S) -- (N2.in 2) 
                        (R) -- (N1.in 1) 
                    ;
                \end{circuitikz}
            \end{tabular}
            
            &\qquad\qquad$\Longrightarrow$\qquad\quad\qquad&
            
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (0,0) node (L)[latch SR, anchor=west]{}
                    ;
                \end{circuitikz}
            \end{tabular}
            \\\\
        \end{tabular}
    \end{center}
    
    Per capire il funzionamento di un SR Latch, analizziamo i seguenti \textbf{quattro casi}:
    \begin{itemize}
        \item Nel caso in cui \textbf{S valga 1 e R valga 0}, il valore della porta NOR \textit{inferiore} sarà \textbf{0}, indipendentemente dal valore assunto dal secondo input (ossia Q), mentre la porta NOR \textit{superiore} assumerà valore \textbf{1}, poiché entrambi gli input (R e $\overline{Q}$) valgono 0. 
        
        \item Nel caso in cui \textbf{S valga 0 e R valga 1}, il valore della porta NOR \textit{superiore} sarà \textbf{0}, indipendentemente dal valore assunto dal secondo input (ossia $\overline{Q}$), mentre la porta NOR \textit{inferiore} assumerà valore \textbf{1}, poiché entrambi gli input (S e Q) valgono 0. 
        
        \item Nel caso in cui \textbf{S valga 0 e R valga 0}, il valore della porta NOR \textit{inferiore} sarà \textbf{0} nel caso in cui Q valga 1, mentre sarà \textbf{1} nel caso in cui Q valga 0. Allo stesso modo, il valore della porta NOR \textit{superiore} sarà \textbf{0} nel caso in cui $\overline{Q}$ valga 1, mentre sarà \textbf{1} nel caso in cui $\overline{Q}$ valga 0. In questo caso, dunque, il circuito \textbf{conserva il suo stato}, poiché il valore di Q e $\overline{Q}$ dipendono strettamente dal loro valore precedente (che chiameremo $Q_p$).
        
        \item Nel caso in cui \textbf{S valga 1 e R valga 1}, il valore della porta NOR \textit{inferiore} sarà \textbf{0}, indipendentemente dal valore assunto dal secondo input (ossia Q). Allo stesso modo, il valore della porta NOR \textit{superiore} sarà \textbf{0}, indipendentemente dal valore assunto dal secondo input (ossia $\overline{Q}$).
        In questo caso, dunque, sia Q sia $\overline{Q}$ assumono valore 0, rendendo lo stato del circuito \textbf{illegale}, poiché l'imposizione logica $Q \neq \overline{Q}$ verrebbe violata.
    \end{itemize}
    
    Possiamo quindi riassumere il funzionamento del circuito in  \textbf{tavole della verità}:
    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c c c c | c c}
                S & R & $Q_p$ & $\overline{Q_p}$ & Q & $\overline{Q}$ \\
                \hline
                0 & 0 & 0 & 1 & 0 & 1 \\
                0 & 0 & 1 & 0 & 1 & 0 \\
                0 & 1 & X & X & 0 & 1 \\
                1 & 0 & X & X & 1 & 0 \\
                1 & 1 & X & X & \color{red}\textbf{0} & \color{red}\textbf{0} \\
            \end{tabular}
            
            &\qquad\qquad$\Longrightarrow$\qquad\quad\qquad&
            
            \begin{tabular}{c c | c}
                S & R & Q \\
                \hline
                0 & 0 & $Q_p$ \\
                0 & 1 & 0 \\
                1 & 0 & 1 \\
                1 & 1 & \color{red}\textbf{ILL}
            \end{tabular}
            \\\\
        \end{tabular}
    \end{center}
    
    \subsection{D Latch}
    
    Come abbiamo visto, l'SR Latch presenta una falla fondamentale al suo interno che genera uno \textbf{stato illegale}. Per prevenire ciò, è stata ideata un'evoluzione di questo componente, chiamata \textbf{D Latch}.
    
    Un D Latch è provvisto di \textbf{due input}:
    \begin{itemize}
        \item \textbf{D}: controlla \textit{come} lo stato del circuito deve cambiare
        \item \textbf{CLK}: controlla \textit{quando} lo stato del circuito deve cambiare
    \end{itemize}
    
    \begin{center}
        \begin{circuitikz}
            \draw (0,0) node[latch D]{};
        \end{circuitikz}
    \end{center}
    
    \newpage
    
    Nel caso in cui \textbf{CLK valga 1}, il circuito viene considerato \textbf{trasparente}, dunque il valore di D verrà lasciato passare a Q. Nel caso in cui \textbf{CLK valga 0}, il circuito viene considerato \textbf{opaco}, dunque non lascerà passare D e permetterà a Q di mantenere il suo precedente stato.
    
    Ma come possono questi due input prevenire la presenza di uno stato invalido? La risposta è semplice: \textbf{D} e \textbf{CLK} in realtà controllano il valore assunto da \textbf{S} e \textbf{R}:
    
    \begin{itemize}
        \item $S = CLK \cdot D$
        \item $R = CLK \cdot \overline{D}$
    \end{itemize}
    
    Dunque, un D Latch non è altro che un SR Latch connesso a due porte AND
    
    \quad
    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (3, -0.842) node (sr)[latch SR, anchor=west]{}
                        
                        ($(sr.pin 1) +(-2.5, 0)$) node (and1)[and port, anchor=west]{}
                        ($(sr.pin 3) +(-2.5, 0)$) node (and2)[and port, anchor=west]{}
                        
                        ($(and1.in 1) +(-1, 0)$) node (D)[anchor=east]{D}
                        ($(and2.in 2) +(-1, 0)$) node (CLK)[anchor=east]{CLK}
                        
                        (D) -- +(0.5, 0) -| (and2.in 1)
                        (CLK) -- +(1.25, 0) |- (and1.in 2)
                        ($(CLK)+(1.25, 0)$) -- (and2.in 2)
                        (and1.out) -- (sr.pin 1)
                        (and2.out) -- (sr.pin 3)
                    ;
                    \node at(and1.bin 1)[ocirc, anchor=east]{};
                \end{circuitikz}
            \end{tabular}
            
            &\qquad\qquad\qquad&
            
            \begin{tabular}{c c | c c | c}
                D & CLK & S & R & Q \\
                \hline
                X & 0 & 0 & 0 & $Q_p$ \\
                0 & 1 & 0 & 1 & 0 \\
                1 & 1 & 1 & 0 & 1 \\
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \quad
    \subsubsection{Esempio di forma d'onda di un D Latch}
    
    Proviamo ad analizzare il comportamento di un D Latch tramite la sua rappresentazione del suo stato in \textbf{forma d'onda}
    
    \begin{center}
        \includegraphics[scale=0.7]{resources/images/chapter_3/d_latch_wave1.png}
    \end{center}
    
    \begin{enumerate}
        \item Il Latch è in \textbf{hold state}. Non sappiamo ancora il valore di Q poiché abbiamo appena acceso l'alimentazione, dunque potrebbe valere \textbf{sia 0 che 1}
        \item Il Latch diventa trasparente ($CLK=1$), dunque $Q=D=0$
        \item D \textbf{varia} da $0$ ad $1$ e visto che $CLK=1$ allora $Q=D=1$
        \item D \textbf{varia} da $1$ ad $0$ e visto che $CLK=1$ allora $Q=D=0$
        \item D \textbf{varia} da $0$ ad $1$ e visto che $CLK=1$ allora $Q=D=1$
        \item D \textbf{varia} da $0$ ad $1$ e poco dopo da $1$ ad $0$, ma visto che \textbf{CLK=0} in entrambi i casi allora $Q=Q_p$ \textbf{(hold state)}
        \item D \textbf{varia} da $0$ ad $1$ e visto CLK=1 allora $Q=D=1$, tuttavia il valore di Q in realtà non cambia poiché $Q_p=1$
    \end{enumerate}
    
    
    \subsection{D Flip-Flop}
    
    L'elemento di stato più utilizzato è il \textbf{D Flip-Flo}p, ossia un'ulteriore evoluzione del D Latch. A differenza del suo antenato, lo stato di un D Flip-Flop cambia \textbf{solo sul fronte di salita (rising edge)}, ossia nell'esatto momento in cui CLK varia da $0$ ad $1$.
    
    Per questo motivo, un D flip-flop viene definito \textbf{edge-triggered} e, per distinguerlo graficamente da un D Latch, il segnale CLK viene rappresentato da un \textit{triangolino}. Inoltre, poiché uno dei componenti più utilizzati, spesso viene rappresentato in forma \textit{ridotta} (destra).
    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw (0,0) node[flipflop D]{};
                \end{circuitikz}
            \end{tabular}
            
            &\qquad$\Longrightarrow$\qquad\quad&
            
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw (0,0) node[small-FF]{};
                \end{circuitikz}
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \quad
    
    Un D flip-flop viene implementato tramite \textbf{due D Latch interconnessi} tra loro e controllati dallo stesso identico segnale \textbf{CLK}, dove tuttavia l'ingresso CLK del primo Latch ($L_1$) viene negato, mentre il secondo ($L_2$) no. In questo modo è possibile ottenere la seguente logica:
    
    \begin{itemize}
        \item Quando $\textbf{CLK=0}$:
        \begin{itemize}
            \item $L_1$ è \textbf{trasparente}
            \item $L_2$ è \textbf{opaco}
            \item D \textbf{passa} per $L_1$, dunque $K=D$
        \end{itemize}
        \item Quando $\textbf{CLK=1}$:
        \begin{itemize}
            \item $L_1$ è \textbf{opaco}
            \item $L_2$ è \textbf{trasparente}
            \item K \textbf{passa} per $L_2$, dunque $Q=K$
        \end{itemize}
    \end{itemize}
    
    \begin{center}
        \begin{circuitikz}
            \tikzset{L1-FF/.style={flipflop, flipflop def={t2=D, t6=K, tu=CLK, t4=\ctikztextnot{K}}}}
            \tikzset{L2-FF/.style={flipflop, flipflop def={t2=K, t6=Q, tu=CLK, t4=\ctikztextnot{Q}}}}

            \draw
                (0,0) node(L1)[L1-FF, anchor=west]{$L_1$}
                (4,0) node(L2)[L2-FF, anchor=west]{$L_2$}
                ($(L1.up)+(-3, 0.2)$) node (CLK)[anchor=west]{CLK}
                
                (CLK) -- ($(L1.up)+(0,0.2)$) -- (L1.up)
                ($(L1.up)+(0,0.2)$) -| (L2.up)
                (L1.pin 6) -- (L2.pin 2)
            ;
            \node at (L1.bup)[ocirc, anchor=south]{};
        \end{circuitikz}
    \end{center}
    
    \quad
    
    Nel caso in cui ad essere negato fosse $L_2$ al posto di $L_1$ ci troveremmo d'innanzi ad un \textbf{D flip-flop falling edge}, dove lo stato viene cambiato solo nell'esatto momento in cui CLK varia da $1$ ad $0$.
    
    \newpage
    
    \subsubsection{Banchi di Flip-Flop come Registri}
    
    Come abbiamo accennato nella sezione \ref{circ_seq_def}, spesso i flip-flop vengono utilizzati in \textbf{quantità multiple}, in modo che possano conservare più di soli due stati all'interno di una macchina, poiché un F-F è in grado di memorizzare \textbf{solo 1 bit} al suo interno (dunque 1 flip-flop = 2 possibili stati, 2 flip-flop = 4 possibili stati, ...).
    
    Perciò, a livello grafico viene usata la seguente \textbf{convenzione}, in modo da semplificare rappresentazione di circuiti richiedenti molti F-F controllati tutti dallo \textbf{stesso CLK}:
    
    \begin{center}
        \begin{tabular}{c c c}
            \\
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (0,0) node(F1)[small-FF]{}
                        (F1.pin 2) node[anchor=east]{$D_0$}
                        (F1.pin 5) node[anchor=west]{$Q_0$}
                        
                        (0,-3) node(F2)[small-FF]{}
                        (F2.pin 2) node[anchor=east]{$D_1$}
                        (F2.pin 5) node[anchor=west]{$Q_1$}
                        
                        (0,-6) node(F3)[small-FF]{}
                        (F3.pin 2) node[anchor=east]{$D_2$}
                        (F3.pin 5) node[anchor=west]{$Q_2$}
                        
                        (0,-9) node(F4)[small-FF]{}
                        (F4.pin 2) node[anchor=east]{$D_3$}
                        (F4.pin 5) node[anchor=west]{$Q_3$}
                        
                        ($(F1.up)+(0,0.5)$) node (CLK){CLK}
                        (CLK) -- (F4.up)
                    ;
                \end{circuitikz}
            \end{tabular}
            
            &\qquad$\Longrightarrow$\qquad\quad&
            
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (0,0) node (F)[small-FF]{}
                        
                        (F.pin 2) node {/}
                        ($(F.pin 2)+(-0.25,0)$) node(D)[anchor=east]{$D_{3:0}$}
                        ($(F.pin 2)+(0,0.5)$) node {4}
                        
                        (F.pin 5) node {/}
                        ($(F.pin 5)+(0.25,0)$) node(Q)[anchor=west]{$Q_{3:0}$}
                        ($(F.pin 5)+(0,0.5)$) node {4}
                        
                        (D) -- (F.pin 2)
                        (Q) -- (F.pin 5)
                    ;
                \end{circuitikz}
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \quad
    
    \subsection{Varianti di Flip-Flop}
    
    Poiché uno dei componenti più utilizzati in assoluto, è facile immaginare che nel corso degli anni siano state realizzare numerose varianti del classico D Flip-Flop. Di seguito vedremo le più comuni:
    
    \begin{itemize}
        \item \textbf{Enabled Flip-Flop}
        \item \textbf{Settable e Resettable Flip-Flop}
        \item \textbf{SR, JK e T Flip-Flop}
    \end{itemize}
    
    \newpage
    
    \subsubsection{Enabled Flip-Flop}
    
    Al contrario di un normale D Flip-Flop, un \textbf{segnale di
    Enable} controlla quando viene concesso a D di poter
    passare a Q.
    
    \begin{itemize}
        \item Se \textbf{Enable = 1} allora $D$ ad $Q$ quando CLK si attiva
        \item Se \textbf{Enable = 0} allora $Q_p$ ad $Q$ anche se CLK si attiva
    \end{itemize}
    
    \begin{center}
        \begin{tabular}{c c c}
            \\
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (0,0) node (F)[flipflop D, anchor=west]{}
                        ($(F.up)+(-3, 0)$) node (A)[and port, anchor=west]{}
                        (A.in 1) node[anchor=east]{CLK}
                        (A.in 2) node[anchor=east]{Enable}
                        
                        (F.up) -- (A.out)
                    ;
                \end{circuitikz}
            \end{tabular}
            &\qquad\qquad$\Longrightarrow$\quad\qquad
            \begin{tabular}{c}
                \\
                \begin{circuitikz}
                    \draw (0,0) node (F)[flipflop enabled, anchor=west]{};
                \end{circuitikz}
            \end{tabular}
            \\
        \end{tabular}
    \end{center}
    
    \subsubsection{Resettable Flip-Flop}
    
    \begin{tabular}{l c c}
        \begin{tabular}{l}
            Viene aggiunto un segnale di Reset in grado di \\ cambiare autonomamente lo stato di Q.\\
            \llap{\textbullet} Se \textbf{Reset = 1} allora Q viene forzato a 0 \\
            \llap{\textbullet}  Se \textbf{Reset = 0} allora il flip-flop si comporta normalmente \\
        \end{tabular}
        &\qquad\qquad&
        \begin{tabular}{c}
            \begin{circuitikz}
                \draw node[flipflop resettable]{};
            \end{circuitikz}
        \end{tabular}
        \\
    \end{tabular}
    
    A differenza della precedente variante di F-F, esistono due tipi di Resettable F-F:
    
    \begin{itemize}
        \item \textbf{Sincrono}: il reset avviene solo quando anche CLK si alza
        \item \textbf{Asincrono}: il reset avviene immediatamente ed indipendentemente
    \end{itemize}
    
    \begin{tabular}{l c}
        \\
        \textbf{Synchronous Resettable Flip-Flop} &\\
        \begin{tabular}{l}
            Poiché il valore di Q deve essere forzato a 0 (reset)\\ solo nel momento in cui \textbf{sia il segnale di reset che}\\
            \textbf{il segnale di clock sono pari ad 1}, possiamo\\ ottenere questa variante del F-F aggiungendo una\\ semplice porta AND tra $D$ e $\overline{Reset}$
        \end{tabular}
        &
        \begin{tabular}{c}
            \begin{circuitikz}
                \draw
                    (0,0) node (F)[flipflop D, anchor=west]{}
                    ($(F.pin 2)+(-2.5, 0)$) node (A)[and port, anchor=west]{}
                    (A.in 1) node[anchor=east]{D}
                    (A.in 2) node[anchor=east]{Reset}
                    
                    (F.pin 2) -- (A.out)
                ;
                \node at (A.bin 2)[ocirc, anchor=east]{};
            \end{circuitikz}
        \end{tabular}
        \\
    \end{tabular}
    
    \newpage
    
    \textbf{Asynchronous Resettable Flip-Flop}
    
    Nella variante asincrona, invece, è necessario modificare il \textbf{circuito interno} del F-F:
    
    \begin{center}
        \begin{circuitikz}
            \tikzset{L1-FF/.style={flipflop, flipflop def={t2=D, t6=K, tu=CLK, t4=\ctikztextnot{K}}}}
            \tikzset{L2-FF/.style={flipflop, flipflop def={t2=K, t6=Q, tu=CLK, t4=\ctikztextnot{Q}}}}

            \draw
                (0,0) node(L1)[L1-FF, anchor=west]{$L_1$}
                (4,0) node(L2)[L2-FF, anchor=west]{$L_2$}
                
                ($(L1.up)+(-3.5, 0.2)$) node (O)[or port, anchor=west]{}
                
                ($(O.in 1)+(-0.5, 0)$) node (CLK)[anchor=east]{CLK}
                ($(O.in 2)+(-0.5, -0.5)$) node (R)[anchor=east]{Reset}
                ($(A.in 2)+(-0.5, 0)$) node (D)[anchor=east]{D}
                
                ($(L1.pin 2)+(-2.5,0)$) node (A)[and port, anchor=west]{}
                
                (CLK) -- (O.in 1)
                (R) -- +(1, 0) |- (O.in 2)
                (R) -- +(1, 0) |- (A.in 1)
                (D) -- (A.in 2)
                (A.out) -- (L1.pin 2)
                (O.out) -- ($(L1.up)+(0,0.2)$) -- (L1.up)
                ($(L1.up)+(0,0.2)$) -| (L2.up)
                (L1.pin 6) -- (L2.pin 2)
            ;
            \node at (L1.bup)[ocirc, anchor=south]{};
            \node at (A.bin 1)[ocirc, anchor=east]{};
        \end{circuitikz}
    \end{center}
    
    \subsubsection{Settable Flip-Flop}
    
    \begin{tabular}{l c c}
        \begin{tabular}{l}
            Segue la stessa logica del Resettable, dove all'interno dei\\
            circuiti le porte $D \cdot \overline{Reset}$ vengono sostituite con $D + Set$.\\
            
            \llap{\textbullet} Se \textbf{Set = 1} allora Q viene forzato a 1 \\
            \llap{\textbullet}  Se \textbf{Set = 0} allora il flip-flop si comporta normalmente \\
        \end{tabular}
        &\qquad\qquad&
        \begin{tabular}{c}
            \begin{circuitikz}
                \draw node[flipflop settable]{};
            \end{circuitikz}
        \end{tabular}
        \\
    \end{tabular}
    
    \subsubsection{SR Flip-Flop}
    
    Esattamente uguale ad un SR Latch con l'\textbf{aggiunta di un segnale CLK} che controlla il momento della campionatura.
    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (3, -0.842) node (sr)[latch SR, anchor=west]{}
                        
                        ($(sr.pin 1) +(-2.5, 0)$) node (and1)[and port, anchor=west]{}
                        ($(sr.pin 3) +(-2.5, 0)$) node (and2)[and port, anchor=west]{}
                        
                        ($(and1.in 1) +(-1, 0)$) node (R)[anchor=east]{R}
                        (-0.8, -0.845) node (CLK)[anchor=east]{CLK}
                        ($(and2.in 2) +(-1, 0)$) node (S)[anchor=east]{S}
                        
                        (R) -- (and1.in 1)
                        (S) -- (and2.in 2)
                        (CLK) -| (and1.in 2)
                        (CLK) -| (and2.in 1)
                        (and1.out) -- (sr.pin 1)
                        (and2.out) -- (sr.pin 3)
                    ;
                \end{circuitikz}
            \end{tabular}
            
            &\qquad\qquad\qquad&
            
            \begin{tabular}{c c c | c}
                S & R & CLK & Q \\
                \hline
                X & X & 0 & $Q_p$ \\
                0 & 0 & 1 & $Q_p$ \\
                0 & 1 & 1 & 0 \\
                1 & 0 & 1 & 1 \\
                1 & 1 & 1 & \color{red}\textbf{ILL} \\
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \subsubsection{JK Flip-Flop}
    
    È una versione migliorata dell'SR Flip-Flop (infatti J corrisponde a S mentre K a R), dove \textbf{viene risolto} il problema dello \textbf{stato invalido}: se J e K valgono entrambi 1, allora il valore di Q diventa il \textbf{complementare del suo stato precedente}
    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (3, -0.842) node (jk)[latch SR, anchor=west]{}
                        
                        ($(jk.pin 1) +(-2.5, 0)$) node (and1)[and port, anchor=west]{}
                        ($(jk.pin 3) +(-2.5, 0)$) node (and2)[and port, anchor=west]{}
                        ($(and1.in 1)+(-2.5, 0)$) node (and3)[and port, anchor=west]{}
                        ($(and2.in 2)+(-2.5, 0)$) node (and4)[and port, anchor=west]{}
                        
                        (and3.in 2) node (K)[anchor=east]{K}
                        (-0.8, -0.845) node (CLK)[anchor=east]{CLK}
                        (and4.in 1) node (J)[anchor=east]{J}
                        
                        ($(jk.pin 6)+(1, 0)$) node (q1)[anchor=east]{$Q$}
                        ($(jk.pin 4)+(1, 0)$) node (q2)[anchor=east]{$\overline{Q}$}
                        
                        (and3.out) |- (and1.in 1)
                        (and4.out) |- (and2.in 2)
                        (CLK) -| (and1.in 2)
                        (CLK) -| (and2.in 1)
                        (and1.out) -- (jk.pin 1)
                        (and2.out) -- (jk.pin 3)
                        (jk.pin 6) -- (q1)
                        (jk.pin 4) -- (q2)
                        (jk.pin 6) -- +(0, 1) -| (and3.in 1)
                        (jk.pin 4) -- +(0, -1) -| (and4.in 2)
                    ;
                \end{circuitikz}
            \end{tabular}
            
            &\qquad\qquad\qquad&
            
            \begin{tabular}{c c c | c}
                J & K & CLK & Q \\
                \hline
                X & X & 0 & $Q_p$ \\
                0 & 0 & 1 & $Q_p$ \\
                0 & 1 & 1 & 0 \\
                1 & 0 & 1 & 1 \\
                1 & 1 & 1 & $\overline{Q_p}$ \\
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \subsubsection{T Flip-Flop}
    
    Si tratta di una modifica del JK Flip-Flop, dove gli input J e K sono controllati da un segnale T: se \textit{T = 1}, allora Q diventa il \textbf{complementare dello stato precedente}, altrimenti rimane uguale.
    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (3, -0.842) node (jk)[latch SR, anchor=west]{}
                        
                        ($(jk.pin 1) +(-2.5, 0)$) node (and1)[and port, anchor=west]{}
                        ($(jk.pin 3) +(-2.5, 0)$) node (and2)[and port, anchor=west]{}
                        ($(and1.in 1)+(-2.5, 0)$) node (and3)[and port, anchor=west]{}
                        ($(and2.in 2)+(-2.5, 0)$) node (and4)[and port, anchor=west]{}
                        
                        (-2.8, -0.845) node (T)[anchor=east]{T}
                        (-0.8, -0.845) node (CLK)[anchor=east]{CLK}
                        
                        ($(jk.pin 6)+(1, 0)$) node (q1)[anchor=east]{$Q$}
                        ($(jk.pin 4)+(1, 0)$) node (q2)[anchor=east]{$\overline{Q}$}
                        
                        (T) -| (and3.in 2)
                        (T) -| (and4.in 1)
                        (and3.out) |- (and1.in 1)
                        (and4.out) |- (and2.in 2)
                        (CLK) -| (and1.in 2)
                        (CLK) -| (and2.in 1)
                        (and1.out) -- (jk.pin 1)
                        (and2.out) -- (jk.pin 3)
                        (jk.pin 6) -- (q1)
                        (jk.pin 4) -- (q2)
                        (jk.pin 6) -- +(0, 1) -| (and3.in 1)
                        (jk.pin 4) -- +(0, -1) -| (and4.in 2)
                    ;
                \end{circuitikz}
            \end{tabular}
            
            &\qquad\qquad\qquad&
            
            \begin{tabular}{c c | c}
                T & CLK & Q \\
                \hline
                X & 0 & $Q_p$ \\
                0 & 1 & $Q_p$ \\
                1 & 1 & $\overline{Q_p}$ \\
            \end{tabular}
        \end{tabular}
    \end{center}
    
    Sviluppando per intero la tabella del T Flip-Flop, notiamo come essa corrisponda ad un semplice \textbf{XOR tra T e $Q_p$ dato in input ad un D Flip-Flop}:

    \begin{center}
        \begin{tabular}{c c c}
        \\
            \begin{tabular}{cc|c}
                T & $Q_p$ & Q \\
                \hline
                0 & 0 & 0\\
                0 & 1 & 1\\
                1 & 0 & 1\\
                1 & 1 & 0
            \end{tabular} 
            
            &\qquad$\implies$\qquad&
            
            \begin{tabular}{c}
                \begin{circuitikz}
                   \draw
                   (0,0) node (ff)[anchor=west, flipflop D]{}
                   
                   ($(ff.pin 2) +(-2.5, 0)$) node (xor)[anchor=west, xor port]{}
                   ($(xor.in 2) +(0, 0)$) node (n1)[anchor=east]{T}
                    
                    (xor.out) -- (ff.pin 2)
                    (ff.pin 6) -- ($(ff.pin 6) +(0, +1)$) -| (xor.in 1)
                    
                   ;
                \end{circuitikz}
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \quad
    
    \subsection{Ring Oscillator}
    
    Fino ad ora abbiamo parlato di segnali di clock, dove tuttavia in realtà non vi è un vero "orologio" ad inviare un \textbf{segnale periodico}. Tuttavia, utilizzando la logica sequenziale è possibile realizzare un \textbf{circuito instabile (o oscillante)} il cui valore \textbf{cambia} dopo un determinato periodo di tempo.
    
    Il modo più semplice per realizzare questa tipologia di circuiti sequenziali è tramite un \textbf{Ring Oscillator}, una variante del circuito bistabile:
    
    \quad
    
    \begin{center}
        \begin{circuitikz}
            \draw
                (0,0) node (A)[not port, anchor=west]{}
                (2,0) node (B)[not port, anchor=west]{}
                (4,0) node (C)[not port, anchor=west]{}
                
                ($(A.out)+(0, 0.15)$) node[anchor=south]{X}
                ($(B.out)+(0, 0.15)$) node[anchor=south]{Y}
                ($(C.out)+(0, 0.15)$) node[anchor=south]{Z}
                
                (C.out) -| +(1, -1) -- ($(A.in)+(-1, -1)$) |- (A.in)
                (A.out) -- (B.in)
                (B.out) -- (C.in)
            ;
        \end{circuitikz}
    \end{center}
    
    \quad
    
    Ipotizzando che per ognuno dei \textbf{tre inverter} valga $t_{cd} = t_{pd} = 1 \,ns$, possiamo facilmente notare come il segnale all'interno del circuito abbia il seguente \textbf{pattern}:
    
    \begin{enumerate}
        \item ($t_0 = 0 \,ns$) X = 0, Y = 1, Z = 0
        \item ($t_1 = 3 \,ns$) X = 1, Y = 0, Z = 1
        \item ($t_2 = 6 \,ns$) X = 0, Y = 1, Z = 0
        \item ($t_3 = 9 \,ns$) X = 1, Y = 0, Z = 1
        \item ...
    \end{enumerate}
    
    In questo modo abbiamo realizzato un \textbf{segnale variabile con periodo \textit{6 ns}}, ossia un clock di \textbf{frequenza} $f = \frac{1}{6 \,ns} = 166.\overline{666} \, MHz$.
    
    \begin{center}
        \includegraphics[scale=0.75]{resources/images/chapter_3/ring_freq.png}
    \end{center}
    

    \addtocontents{toc}{\protect\newpage}
    \section{Circuiti Sequenziali Sincroni}
    
    Una volta appresi i modi con cui è possibile memorizzare uno stato, possiamo introdurre questo concetto in sistemi più complessi.
    
    Questi sistemi sono \textbf{sincronizzati con un clock}, dunque il loro stato cambia ad ogni suo fronte di salita, sono dotati di \textbf{registri}, ossia un numero definito di elementi che ne possano conservare lo stato, e sono collegati a dei \textbf{circuiti combinatori} che calcolano gli output del sistema in base allo stato.
    
    In particolare, i \textbf{circuiti sequenziali sincroni} seguono il seguente set di regole:
    
    \begin{itemize}
        \item Ogni elemento del circuito è un \textbf{registro} o un \textbf{circuito combinatorio}
        \item \textbf{Almeno un elemento} del circuito è un registro
        \item Tutti i registri sono connessi allo \textbf{stesso segnale di clock}
        \item Ogni \textbf{percorso ciclico} contiene almeno un registro
    \end{itemize}
    
    Nelle sezioni successive vedremo i due tipi più comuni di CSS, ossia le \textbf{Macchine a Stato Finito (Finite State Machines)} e le \textbf{Pipeline}.
    
    \subsection{Macchine a Stato Finito}
    
    Le \textbf{Finite State Machine (FSM)} sono costituite da \textbf{tre blocchi} fondamentali:
    
    \begin{itemize}
        \item Un blocco combinatorio chiamato \textbf{Next State Logic}, che si occupa di calcolare il successivo stato del sistema in base agli input e allo stato attuale (e all'output precedente in alcuni casi)
        \item \textbf{Uno o più registri} che ne conservino lo stato attuale, corrispondenti ad un banco di flip-flop
        \item Un ulteriore blocco combinatorio chiamato \textbf{Output Logic}, che si occupa di calcolare l'output del sistema in base al suo stato attuale
    \end{itemize}
    
    \quad
    
    \begin{center}
        \begin{circuitikz}
             \draw
                (0,0) node (NSL)[square-1-1, anchor=west]{NSL}
                
                ($(NSL.lpin 1)+(-0.4,0)$) node (i)[anchor=east]{Inputs}
                
                ($(NSL.rpin 1)+(0.4,0)$) node (o)[anchor=west]{Next State}
                
                (NSL.lpin 1) node[]{/}
                (NSL.rpin 1) node[]{/}
                
                (i) -- (NSL.lpin 1)
                (o) -- (NSL.rpin 1)
            ;
            
            \draw
                (0.3, -3) node (F)[small-FF, anchor=west]{}   
                
                ($(F.pin 2)+(-0.4,0)$) node (i)[anchor=east]{Next State}
                
                ($(F.pin 5)+(0.4,0)$) node (o)[anchor=west]{Current State}
                
                (F.pin 2) node[]{/}
                (F.pin 5) node[]{/}
                
                (i) -- (F.pin 2)
                (o) -- (F.pin 5)
            ;
            

             \draw
                (0,-6) node (OL)[square-1-1, anchor=west]{OL}
                
                ($(OL.lpin 1)+(-0.4,0)$) node (i)[anchor=east]{Current State}
                
                ($(OL.rpin 1)+(0.4,0)$) node (o)[anchor=west]{Outputs}
                
                (OL.lpin 1) node[]{/}
                (OL.rpin 1) node[]{/}
                
                (i) -- (OL.lpin 1)
                (o) -- (OL.rpin 1)
            ;
         \end{circuitikz}
    \end{center}
    
    \subsubsection{Macchina di Moore e Macchina di Mealy}
    
    Esistono due principali tipologie di FSM:
    \begin{itemize}
        \item \textbf{Macchina di Moore}: gli output dipendono solo dallo \textbf{stato attuale}
    
        \quad
        
        \begin{center}
            \begin{circuitikz}
                \draw
                    (1,0) node (NSL)[square-2-1,anchor=west]{NSL}
                    (NSL.lpin 1) node[]{/}
                    ($(NSL.lpin 1)+(-0.4,0)$) node (i)[anchor=east]{Inputs}
                    
                    (8,0) node (OL)[square-1-1,anchor=west]{OL}
                    (OL.rpin 1) node[]{/}
                    ($(OL.rpin 1)+(0.4,0)$) node (o)[anchor=west]{Outputs}
                    
                    (4.3,0) node (F)[small-FF, anchor=west]{}   
                    (F.up) node [anchor=south]{CLK}
                    (F.pin 2) node[]{/}
                    (F.pin 5) node[]{/}
                    ($(F.pin 2)+(-0.1, 0.2)$) node [anchor=south]{D}
                    ($(F.pin 5)+(0.1, 0.15)$) node [anchor=south]{Q}
                    
                    (NSL.rpin 1) -- (F.pin 2)
                    (F.pin 5) -- (OL.lpin 1)
                    ($(F.pin 5)+(1,0)$) |- ($(NSL.lpin 2)+(0.75,-1.5)$) -| (NSL.lpin 2) 
                    (i) -- (NSL.lpin 1)
                    (o) -- (OL.rpin 1)
                ;
            \end{circuitikz}
        \end{center}
        
        \newpage
            
        \item \textbf{Macchina di Mealy}: gli output dipendono dallo \textbf{stato attuale} e dagli \textbf{input}
        
        \quad
        
        \begin{center}
            \begin{circuitikz}
                \draw
                    (1,0) node (NSL)[square-2-1,anchor=west]{NSL}
                    ($(NSL.lpin 1)+(-0.6,0)$) node[]{/}
                    ($(NSL.lpin 1)+(-1,0)$) node (i)[anchor=east]{Inputs}
                    
                    (8,0) node (OL)[square-2-1,anchor=west]{OL}
                    (OL.rpin 1) node[]{/}
                    ($(OL.rpin 1)+(0.4,0)$) node (o)[anchor=west]{Outputs}
                    
                    (4.3,0) node (F)[small-FF, anchor=west]{}   
                    (F.up) node [anchor=south]{CLK}
                    (F.pin 2) node[]{/}
                    (F.pin 5) node[]{/}
                    ($(F.pin 2)+(-0.1, 0.2)$) node [anchor=south]{D}
                    ($(F.pin 5)+(0.1, 0.15)$) node [anchor=south]{Q}
                    
                    (NSL.rpin 1) -- (F.pin 2)
                    (F.pin 5) -| (OL.lpin 2)
                    ($(NSL.lpin 1)+(-0.2,0)$) |- ($(OL.lpin 1)+(0,2)$) -- (OL.lpin 1)
                    ($(F.pin 5)+(1,0)$) |- ($(NSL.lpin 2)+(0.75,-1.5)$) -| ($(NSL.lpin 2)+(-0.2,0)$) -- (NSL.lpin 2)
                    (i) -- (NSL.lpin 1)
                    (o) -- (OL.rpin 1)
                ;
            \end{circuitikz}
        \end{center}
    \end{itemize}
    
    \quad
    
    \subsubsection{Diagramma delle Transizioni di Stato}
    
    Sappiamo dunque che le FSM sono delle macchine che hanno un \textbf{numero definito di stati}, in base al numero di registri presenti al loro interno, che \textbf{cambiano} a seconda dello stato attuale e/o degli input. Dobbiamo quindi trovare un modo per rappresentare graficamente le \textbf{transizioni} da uno stato all'altro:
    
    \begin{tabular}{l c c}
        \begin{tabular}{l}
            \llap{\textbullet} \textbf{Stati}: vengono rappresentati come cerchi con\\
            un etichetta centrale \\
            \llap{\textbullet} \textbf{Transizioni}: vengono rappresentati come archi\\
            (o frecce) che collegano uno stato ad un altro, ai\\
            quali vengono aggiunti tutti gli input legati alla\\
            Next State Logic\\
            \llap{\textbullet} \textbf{Output degli Stati}: nella FSM di Moore vengono\\
            rappresentati come un'ulteriore etichetta interna ai \\
            cerchi,  mentre nella FSM di Mealy vengono aggiunti \\
            agli archi, poiché necessari per calcolare il Next \\
            State assieme agli input
        \end{tabular}
        &\qquad&
        \begin{tabular}{c}
            \includegraphics[scale=0.9]{resources/images/chapter_3/state_diag1.png}
        \end{tabular}
        \\
    \end{tabular}
    
    
    \subsubsection{Codifica degli Stati}
    
    Poiché gli stati vengono memorizzati da un banco di flip-flop (dunque come un insieme di 0 ed 1), è necessario definire una \textbf{codifica} che possa associare dei \textbf{bit} ad ogni \textbf{stato}. Immaginiamo di voler rappresentare quattro stati: $S0$, $S1$, $S2$ e $S3$.
    
    \begin{itemize}
        \item \textbf{Codifica binaria}: possiamo utilizzare 2 bit (dunque 2 flip-flop) per rappresentare tutti i quattro stati
        
        \begin{center}
            \begin{tabular}{c | c c}
                Stato & \multicolumn{2}{c}{Registri} \\
                \hline
                $S0$ & 0 & 0 \\
                $S1$ & 0 & 1 \\
                $S2$ & 1 & 0 \\
                $S3$ & 1 & 1 \\
            \end{tabular}
        \end{center}
        
        \item \textbf{Codifica One-hot}: utilizziamo un registro per ogni stato, dunque solo un registro può essere attivo alla volta. In questo esempio, abbiamo quindi bisogno di 4 F-F.
        
        \begin{center}
            \begin{tabular}{c | c c c c}
                Stato & \multicolumn{4}{c}{Registri} \\
                \hline
                $S0$ & 0 & 0 & 0 & 1 \\
                $S1$ & 0 & 0 & 1 & 0 \\
                $S2$ & 0 & 1 & 0 & 0 \\
                $S3$ & 1 & 0 & 0 & 0 \\
            \end{tabular}
        \end{center}
    \end{itemize}
    
    \quad
    
    \subsection{Esempio di FSM di Moore e FSM di Mealy}
    
    Alyssa P. Hacker ha una lumaca che striscia su un nastro di carta su cui sono disegnati degli 0 e degli 1. La lumaca sorride solo quando le ultime due cifre su cui ha strisciato sono uno 0 seguito da un 1. Vogliamo progettare una FSM di Moore ed una FSM di Mealy corrispondenti al cervello della lumaca.
    
    \quad
        
    \textbf{Macchina di Moore - Stati di Transizione}
    
    \begin{itemize}
        \item $\textbf{S}\textbf{0}$: la lumaca ha letto un 1 preceduto da un 1. Se l'input sarà 0 allora lo stato attuale diventerà $S1$, altrimenti rimarrà $S0$
        \item $\textbf{S}\textbf{1}$: la lumaca ha letto uno 0 preceduto da un 1. Se l'input sarà 1 allora lo stato attuale diventerà $S2$, altrimenti rimarrà $S1$
        \item $\textbf{S}\textbf{2}$: la lumaca ha letto un 1 preceduto da uno 0. Se l'input sarà 1 allora lo stato attuale diventerà $S0$, altrimenti sarà $S1$
    \end{itemize}
    
    \begin{center}
        \includegraphics[scale=0.75]{resources/images/chapter_3/snail_moore.png}
    \end{center}
    
    \textbf{Macchina di Moore - Tabelle di Stato e di Output}
    
    \begin{center}
        \begin{tabular}{c c c}
            \\
            \begin{tabular}{c |c c}
                State & \multicolumn{2}{c}{Encoding}\\
                $S$ & $S_1$ & $S_0$\\
                
                \hline
                $S0$ & 0 & 0 \\
                $S1$ & 0 & 1 \\
                $S2$ & 1 & 0 \\
            \end{tabular}
            
            &\qquad\qquad\qquad\qquad&
            
            
            \begin{tabular}{c|c}
                Curr. State & Output\\
                \hline
                $S0$ & 0 \\
                $S1$ & 0 \\
                $S2$ & 1 \\
            \end{tabular}
            \\\\
        \end{tabular}
    \end{center}
    
     \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c c | c | c c}
                \multicolumn{2}{c}{Curr. State} & Inputs & \multicolumn{2}{c}{Next State}\\
                $S_1$ & $S_0$ & $A$ & $S'_1$ & $S'_0$ \\
                \hline
                0 & 0 & 0 & 0 & 1 \\
                0 & 0 & 1 & 0 & 0 \\
                0 & 1 & 0 & 0 & 1 \\
                0 & 1 & 1 & 1 & 0 \\
                1 & 0 & 0 & 0 & 1 \\
                1 & 0 & 1 & 0 & 0 \\
            \end{tabular}
            
            &\qquad$\Longrightarrow$\qquad\quad&
            
            \begin{tabular}{c c | c | c}
                $S$ & $A$ & $S'$ & $Y$\\
                \hline
                $S0$ & 0 & $S1$ & 0\\
                $S0$ & 1 & $S0$ & 0\\
                $S1$ & 0 & $S1$ & 0\\
                $S1$ & 1 & $S2$ & 0\\
                $S2$ & 0 & $S1$ & 1\\
                $S2$ & 1 & $S0$ & 1\\
            \end{tabular}
            \\\\
        \end{tabular}
    \end{center}
    
    \textbf{Macchina di Moore - Schematica del circuito}
    \begin{center}
        \begin{tabular}{l c c}
            \\
            
            \begin{tabular}{l}
                \llap{\textbullet} $S'_0 = \overline{A}$\\
                \llap{\textbullet} $S'_1 = S_0 \cdot A$\\
                \llap{\textbullet} $Y = S_1$
            \end{tabular}
            &\qquad\qquad\qquad\qquad&
            
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (0,0) node (R)[small-FF R 2-2, anchor=west]{}
                        ($(R.pin 3)+(-0.2,0)$) node[anchor=south]{$S'_0$}
                        ($(R.pin 4)+(0.2,0)$) node[anchor=south]{$S_0$}
                        ($(R.pin 1)+(-0.2,0)$) node[anchor=south]{$S'_1$}
                        ($(R.pin 6)+(0.2,0)$) node[anchor=south]{$S_1$}
                        (R.up) node[anchor=south]{$CLK$}
                        (R.down) node[anchor=north]{$Reset$}
                        
                        ($(R.pin 1)+(-3,0)$) node(A)[and port, anchor=west]{}
                        
                        ($(R.pin 3)+(-2.5,0)$) node(N)[not port, anchor=west]{}
                        
                        ($(A.in 1)+(-0.5,0.5)$) node(I)[anchor=south]{A}
                        
                        ($(R.pin 6)+(1,0)$) node(Y)[anchor=west]{Y}
                        
                        (I) |- (A.in 2)
                        (I) |- (N.in)
                        (A.out) -- (R.pin 1)
                        (N.out) -- (R.pin 3)
                        (R.pin 4) -- +(0.3,0) -- ($(R.pin 4)+(0.3,-1.5)$) -| ($(A.in 1)+(-1,0)$) -- (A.in 1)
                        (R.pin 6) -- (Y)
                    ;
                \end{circuitikz}
            \end{tabular}
            \\\\
        \end{tabular}
    \end{center}
    
    \textbf{Macchina di Mealy - Stati di Transizione}
    
    \begin{itemize}
        \item Ad ogni freccia di transizione di stato è associata una \textbf{lista di valori in input} tramite cui si verifica tale transizione e una \textbf{lista di output generati} al passaggio di stato. Tali liste vengono rappresentate con la \textbf{notazione} \texttt{inputs/outputs}.
        \item $\textbf{S}\textbf{0}$: Se l'input sarà 0 allora lo stato attuale diventerà $S1$ e l'output sarà 0 (indicato dalla freccia $0/0$ verso $S1$), altrimenti lo stato attuale rimarrà $S0$ e l'output sarà comunque 0 (indicato dalla freccia $1/0$ verso se stesso)
        \item $\textbf{S}\textbf{1}$: Se l'input sarà 1 allora lo stato attuale diventerà $S0$ e l'output sarà 1 (indicato dalla freccia $1/1$ verso $S1$), altrimenti lo stato attuale rimarrà $S1$ e l'output sarà 0 (indicato dalla freccia $0/0$ verso se stesso)
    \end{itemize}
    \begin{center}
        \includegraphics[scale=0.75]{resources/images/chapter_3/snail_mealy.png}
    \end{center}
    
    \newpage
    
    \textbf{Macchina di Mealy - Tabelle di Stato e di Output}
    
    \begin{center}
        \begin{tabular}{c c c}
            \\
            \begin{tabular}{c | c}
                State & Encoding\\
                $S$ & $S_0$\\
                
                \hline
                $S0$ & 0 \\
                $S1$ & 1 \\
            \end{tabular}
            
            &\qquad\qquad\qquad&
            
            \begin{tabular}{c | c | c | c}
                Curr. State & Inputs & Next State & Outputs\\
                $S_0$ & $A$ & $S'_0$ & $Y$\\
                \hline
                0 & 0 & 1 & 0 \\
                0 & 1 & 0 & 0 \\
                1 & 0 & 1 & 0 \\
                1 & 1 & 0 & 1 \\
            \end{tabular}
            \\\\
        \end{tabular}
    \end{center}
    
    \textbf{Macchina di Mealy - Schematica del circuito}
    \begin{center}
        \begin{tabular}{l c c}
            \begin{tabular}{l}
                \llap{\textbullet} $S'_0 = \overline{A}$\\
                \llap{\textbullet} $\textbf{Y} = S_0 \cdot A$\\\\
                Notiamo che questa FSM di Mealy cicla\\
                una volta in meno attraverso i registri,\\
                dunque l'output viene definito \textbf{un colpo}\\
                \textbf{di clock prima} rispetto alla FSM di\\
                Moore che abbiamo realizzato prima
            \end{tabular}
            
            &\qquad&
            
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (0,0) node (R)[small-FF R, anchor=west]{}
                        ($(R.pin 2)+(-0.2,0)$) node[anchor=south]{$S'_0$}
                        ($(R.pin 5)+(0.2,0)$) node[anchor=south]{$S_0$}
                        (R.up) node[anchor=south]{$CLK$}
                        (R.down) node[anchor=north]{$Reset$}
                        
                        ($(R.pin 5)+(1,0.25)$) node(A)[and port, anchor=west]{}
                        
                        ($(R.pin 2)+(-2,0)$) node(N)[not port, anchor=west]{}
                        
                        ($(N.in)+(-0.5,2.75)$) node(I)[anchor=south]{A}
                        
                        (A.out) node(Y)[anchor=west]{Y}
                        
                        (I) |- (N.in)
                        (I) |- ($(A.in 1)+(0,1.75)$) -- (A.in 1)
                        (R.pin 5) -- (A.in 2)
                        (N.out) -- (R.pin 2)
                    ;
                \end{circuitikz}
            \end{tabular}
            \\\\
        \end{tabular}
    \end{center}
    
    \textbf{Confronto tra i diagrammi temporali}
    
    \begin{center}
        \includegraphics[scale=0.820]{resources/images/chapter_3/clock_moore_mealy.png}
    \end{center}
    
    \newpage
    \subsection{Da FSM di Moore a FSM di Mealy e viceversa}
    
    Una proprietà particolare di queste due tipologie di FSM è la totale intercambiabilità tra di loro. Infatti, ogni \textbf{FSM di Moore} può essere \textbf{trasformata} in una \textbf{FSM di Mealy} \textbf{associando l’uscita} appartenente a uno stato \textbf{a tutte le transizioni} che entrano in tale stato.  Nel caso in cui vadano a crearsi degli stati completamente uguali, è possibile semplificarli tra di loro mantenendone solo uno.
    
    \quad
    
    \begin{center}
        \includegraphics[scale=0.65]{resources/images/chapter_3/moore_to_mealy.png}
    \end{center}
    
    Allo stesso modo, una \textbf{FSM di Mealy} può essere \textbf{trasformata} in una \textbf{FSM di Moore} replicando lo stato della macchina di Moore compiendo il \textbf{processo inverso}, dunque associando l'output delle transizioni agli stati generati. Se le transizioni che portano a tale stato hanno delle \textbf{uscite differenti}, allora lo stato verrà \textbf{replicato}, in modo da avere \textbf{una sola} combinazione di transizioni/output per ogni stato.
    
    \begin{center}
        \includegraphics[scale=0.65]{resources/images/chapter_3/mealy_to_moore.png}
    \end{center}
    
    Inoltre, nel caso in cui sia necessario \textbf{replicare} uno stato, le sue \textbf{uscite} originali verranno attribuite ad \textbf{entrambi gli stati replicati}.
    
    \begin{center}
        \includegraphics[scale=0.65]{resources/images/chapter_3/mealy_to_moore2.png}
    \end{center}

    \subsubsection{Inizializzazione delle FSM e Stati indefiniti}
    
    Poiché lo stato iniziale di un flip-flop appena acceso è indeterminato, dunque potrebbe contenere sia uno 0 che un 1, anche lo \textbf{stato della FSM è indeterminato}.

    Per evitare questo problema si dotano sempre le FSM di un \textbf{segnale di Reset} che forza la macchina in uno \textbf{stato noto} (tipicamente tutti 0) da cui può partire l’elaborazione.
    
    Inoltre, una FSM può avere degli \textbf{stati irraggiungibili}, ossia degli stati che non possono essere raggiunti con nessuna sequenza di valori di ingresso. L’\textbf{irraggiungibilità dipende dallo stato iniziale} della FSM (quindi lo stato deciso dal Reset). Spesso questi stati sono presenti nelle FSM che non hanno un numero di stati esattamente pari ad una potenza di 2.

    Infatti, gli stati non utilizzati contribuiscono comunque a generare i output della NSL, ma non sono mai raggiunti, ossia l’output della NSL \textbf{non corrisponde mai} alla codifica di questi
    stati.
    
    \subsubsection{Procedura per un design corretto delle FSM}
    
    \begin{enumerate}
        \item Identificare gli input e gli output
        \item Disegnare il diagramma delle transizioni
        \item Estrapolare la tabella delle transizioni
        \item Scegliere un encoding per gli stati
        \item Scrivere la tabella degli output
        \item Estrapolare le equazioni booleane della NSL e della OL
        \item Disegnare il circuito
    \end{enumerate}
    
    
    \subsubsection{Ricavare il funzionamento di una FSM dal suo circuito}
    
    \begin{enumerate}
        \item Esaminare il circuito, individuandone input, output e bit di stato
        \item Scrivere le equazioni booleane della NSL e della OL
        \item Estrapolare la tabella delle transizioni e degli output, scartando eventuali stati irraggiungibili
        \item Scegliere un encoding per gli stati
        \item Disegnare il diagramma delle transizioni
        \item Descrivere a parole il funzionamento della FSM
    \end{enumerate}
    
    \newpage
    
    \subsection{Temporizzazioni sequenziali}
    
    Come abbiamo visto, i circuiti sequenziali sincroni utilizzano dei D Flip-Flop, i quali \textbf{campionano} il valore in ingresso D quando il clock è in \textbf{rising-edge}. Per questo motivo, viene logico pensare che i valori in ingresso \textbf{debbano rimanere stabili} nel momento in cui il clock si alza, altrimenti la loro campionatura potrebbe non andare a buon fine (metastabilità).
    
    Dobbiamo quindi analizzare alcuni \textbf{periodi temporali} necessari affinché gli \textbf{input} possano rimanere \textbf{stabili}, permettendo una campionatura corretta:
    
    \begin{tabular}{l c c}
        \begin{tabular}{l}
            \llap{\textbullet} \textbf{Tempo di setup ($\textbf{t}_{\textbf{setup}}$)}: periodo di tempo\\
            \textit{precedente} alla salita del clock in cui D deve\\
            rimanere stabile\\
            \llap{\textbullet} \textbf{Tempo di hold ($\textbf{t}_{\textbf{hold}}$)}: periodo di tempo\\
            \textit{successivo} alla salita del clock in cui D deve\\
            rimanere stabile\\
            \llap{\textbullet} \textbf{Tempo di apertura ($\textbf{t}_{\textbf{a}}$)}: periodo di tempo\\ \textit{totale} in cui D deve rimanere stabile\\
            ($t_a = t_{setup} + t_{hold}$)\\
        \end{tabular}
        &\quad&
            \begin{tabular}{c}
            \includegraphics[scale=0.75]{resources/images/chapter_3/fsm_timing1.png}
        \end{tabular}
        \\\\
    \end{tabular}
    
    Analogamente, è necessario assicurarsi che \textbf{anche gli output siano stabili}, poiché non possiamo essere completamente sicuri che il valore Q venga generato immediatamente al momento della campionatura:
    
    \begin{tabular}{l c c}
        \begin{tabular}{l}
            \llap{\textbullet} \textbf{Delay di contaminazione ($\textbf{t}_{\textbf{pcq}}$)}: periodo\\
            di tempo \textit{successivo} alla salita del clock in cui\\
            il valore di Q potrebbe essere instabile\\
            \llap{\textbullet} \textbf{Delay di propagazione ($\textbf{t}_{\textbf{ccq}}$)}: periodo\\
            di tempo \textit{successivo} alla salita del clock dopo\\
            cui il valore di Q è sicuramente stabile
        \end{tabular}
        &&
            \begin{tabular}{c}
            \includegraphics[scale=0.75]{resources/images/chapter_3/fsm_timing2.png}
        \end{tabular}
        \\
    \end{tabular}
    
    
    \subsubsection{Disciplina dinamica}
    
    Immaginando un circuito composto da due registri $R_1$ e $R_2$ connessi tra di loro da un circuito combinatorio, è facile trovare una problematica intrinseca ai registri stessi: essi vengono attivati dallo \textbf{stesso segnale di clock} allo stesso istante. Tuttavia, affinché il \textbf{registro} $\textbf{R}_\textbf{2}$ possa campionare in modo stabile il valore in entrata, è necessario \textbf{calcolare} accuratamente il suo \textbf{tempo di setup}.
    
    \begin{center}
        \includegraphics[scale=0.75]{resources/images/chapter_3/fsm_timing3.png}
    \end{center}
    
    Da questo diagramma temporale possiamo notare come \textbf{vincolo temporale ($\textbf{T}_\textbf{c}$))} dipenda dal \textbf{delay massimo} affinché il valore in uscita da $R_1$ possa essere campionato stabilmente da $R_2$, passando attraverso il circuito combinatorio. L'\textbf{input} di $R_2$ dovrà dunque essere stabile \textbf{prima del clock edge} per un periodo $t_{setup}$ \textbf{(Vincolo temporale di setup)}.
    
    Il vincolo temporale $T_c$ sarà quindi \textbf{maggiore o uguale} al delay massimo, corrispondente alla somma tra il delay di propagazione di $R_1$ ($t_{pcq}$), il delay di propagazione del circuito combinatorio ($t_{pd}$) e il tempo di setup di $R_2$ ($t_{setup}$).
    \[ T_c \geq t_{pcq} + t_{pd} + t_{setup}\]
    
    Tuttavia, è necessario considerare anche il \textbf{delay minimo} per cui il valore in uscita da $R_1$ debba rimanere stabile. Di conseguenza, ricaviamo che anche l'\textbf{input} di $R_2$ debba rimanere stabile \textbf{dopo il clock edge} per almeno $t_{hold}$ affinché esso possa essere campionato correttamente \textbf{(Vincolo temporale di hold)}.
    
    \begin{center}
        \includegraphics[scale=0.75]{resources/images/chapter_3/fsm_timing4.png}
    \end{center}
    \[ t_{hold} < t_{ccq} + t_{cd}\]
    
    \newpage

    \subsubsection{Esempio di analisi temporale}
    
    Consideriamo i seguenti valori e il seguente circuito, verificando che i vincoli temporali di setup e di hold siano rispettati:
    \begin{itemize}
        \item $t_{ccq} = 30 \textit{ps}$
        \item $t_{pcq} = 50 \textit{ps}$
        \item $t_{pd} = 35 \textit{ps}$ (per tutte le porte)
        \item $t_{cd} = 25 \textit{ps}$ (per tutte le porte)
        \item $t_{setup} = 60 \textit{ps}$
        \item $t_{hold} = 70 \textit{ps}$
    \end{itemize}
    
    \quad
    
    \begin{center}
        \begin{circuitikz}
            \draw
                
                (0,0) node(F1)[small-FF, anchor=west]{}
                (0,-3) node(F2)[small-FF, anchor=west]{}
                (0,-6) node(F3)[small-FF, anchor=west]{}
                (0,-9) node(F4)[small-FF, anchor=west]{}
                
                (2.5, -1.5) node(A)[and port, anchor=west]{}
                (5, -4.5) node(O)[or port, anchor=west]{}
                (7.5, -7.5) node(N)[nor port, anchor=west]{}
                
                ($(O)+(5, 0)$) node(F5)[small-FF, anchor=west]{}
                ($(N)+(2.5, 0)$) node(F6)[small-FF, anchor=west]{}
                
                (F1.up) node[anchor=south]{CLK}
                (F5.up) node[anchor=south]{CLK}
                
                (F1.up) -- (F4.up)
                (F5.up) -- (F6.up)
                (F1.pin 5) -| (A.in 1)
                (F2.pin 5) -| (A.in 2)
                (A.out) -| (O.in 1)
                (F3.pin 5) -| (O.in 2)
                (O.out) -| (N.in 1)
                (F4.pin 5) -| (N.in 2)
                (O.out) -- (F5.pin 2)
                (N.out) -- (F6.pin 2)
            ;
        \end{circuitikz}
    \end{center}
    
    \begin{tabular}{c c c}
        \\
        \begin{tabular}{l}
            \textbf{Vincolo temporale di setup}\\
            \hline
            $t_{pd} = 3 \cdot 35 \textit{ps} = 105 \textit{ps}$\\
            $T_c \geq (50+105+60) \textit{ps} = 215 \textit{ps}$\\
            $f_c = 1/T_c = 4.65 \textit{GHz}$\\
        \end{tabular}
        
        &\qquad\qquad\qquad&
        
        \begin{tabular}{l}
            \textbf{Vincolo temporale di hold}\\
            \hline
            $t_{cd} = 25 \textit{ps}$\\
            $t_{hold} < t_{ccq} + t_{cd} \Rightarrow 70 < (30+25) \textit{ps}$\\
            \color{red}\textbf{Il vincolo non viene rispettato}\\
        \end{tabular}
    \end{tabular}
    
    \newpage
    
    Notiamo che il vincolo temporale di hold viene violato, rendendo instabile la campionatura del valore in entrata dei registri secondari. Per risolvere il problema, è necessario \textbf{aggiungere dei buffer} agli \textbf{short path}, in modo che il vincolo possa essere nuovamente rispettato senza alterare il vincolo temporale di setup: 
    
    \quad
    
    \begin{center}
        \begin{circuitikz}
            \draw
                
                (0,0) node(F1)[small-FF, anchor=west]{}
                (0,-3) node(F2)[small-FF, anchor=west]{}
                (0,-6) node(F3)[small-FF, anchor=west]{}
                (0,-9) node(F4)[small-FF, anchor=west]{}
                
                (2.5, -1.5) node(A)[and port, anchor=west]{}
                (5, -4.5) node(O)[or port, anchor=west]{}
                (7.5, -7.5) node(N)[nor port, anchor=west]{}
                ($(F3.pin 5)+(2.5, 0)$) node(B1)[buffer port]{}
                ($(F4.pin 5)+(2.5, 0)$) node(B2)[buffer port]{}
                ($(O)+(5, 0)$) node(F5)[small-FF, anchor=west]{}
                ($(N)+(2.5, 0)$) node(F6)[small-FF, anchor=west]{}
                
                (F1.up) node[anchor=south]{CLK}
                (F5.up) node[anchor=south]{CLK}
                
                (F1.up) -- (F4.up)
                (F5.up) -- (F6.up)
                (F1.pin 5) -| (A.in 1)
                (F2.pin 5) -| (A.in 2)
                (A.out) -| (O.in 1)
                (F3.pin 5) -- (B1.in)
                (B1.out) -| (O.in 2)
                (O.out) -| (N.in 1)
                (F4.pin 5) -- (B2.in)
                (B2.out) -| (N.in 2)
                (O.out) -- (F5.pin 2)
                (N.out) -- (F6.pin 2)
            ;
        \end{circuitikz}
    \end{center}
    
    \begin{tabular}{c c c}
        \\
        \begin{tabular}{l}
            \textbf{Vincolo temporale di setup}\\
            \hline
            $t_{pd} = 3 \cdot 35 \textit{ps} = 105 \textit{ps}$\\
            $T_c \geq (50+105+60) \textit{ps} = 215 \textit{ps}$\\
            $f_c = 1/T_c = 4.65 \textit{GHz}$\\
        \end{tabular}
        
        &\qquad\qquad\qquad&
        
        \begin{tabular}{l}
            \textbf{Vincolo temporale di hold}\\
            \hline
            $t_{cd} = 2 \cdot 25 \textit{ps} = 50 \textit{ps}$\\
            $t_{hold} < t_{ccq} + t_{cd} \Rightarrow 70 < (30+50) \textit{ps}$\\
            \color{blue}\textbf{Il vincolo viene rispettato}\\
        \end{tabular}
        \\
    \end{tabular}
    
    \newpage

    \subsubsection{Sfasamento del clock}
    
    Fino ad ora, non abbiamo considerato un ultimo fattore in grado di influenzare la campionatura di valori in sequenza, ossia lo \textbf{sfasamento del segnale di clock}: poiché si tratta pur sempre di un segnale elettrico, il segnale di clock \textbf{non arriva contemporaneamente} a tutti i vari registri. Perciò, nel definire il \textbf{tempo di apertura} di un registro in modo che rispetti i vincoli della disciplina dinamica, è necessario considerare anche i \textbf{due casi peggiori}:
    
    \begin{itemize}
        \item Il registro $R_2$ è in \textit{anticipo} rispetto al registro $R_1$
        
        \item Il registro $R_2$ è in \textit{ritardo} rispetto al registro $R_1$
    \end{itemize}
    
    Per ovviare questo problema, quindi, è necessario considerare anche il \textbf{tempo di sfasamento del clock (clock skew)} nelle due equazioni dei vincoli temporali di \textit{setup} e di \textit{hold}:
    
    \begin{center}
        \begin{tabular}{c c}
        
            \textbf{Vincolo temporale di setup} &
            \textbf{Vincolo temporale di hold}\\
            \includegraphics[scale=0.8]{resources/images/chapter_3/fsm_timing5.png}
            &
            \includegraphics[scale=0.8]{resources/images/chapter_3/fsm_timing6.png}
            \\\\
            $T_c \geq t_{pcq} + t_{pd} + t_{setup} + t_{skew}$
            &
            $t_{hold} + t_{skew} < t_{ccq} + t_{cd}$
            \\\\\\
        \end{tabular}
    \end{center}
    
    \newpage

    \subsection{Pipelines e parallelismo}
    
    Prima di poter parlare della seconda tipologia di circuiti sequenziali sincroni, ossia le \textbf{pipeline}, è necessario enunciare alcune \textbf{definizioni}:
    
    \begin{itemize}
        \item \textbf{Token}: un insieme di input processati per generare un insieme di output
        \item \textbf{Latenza}: tempo impiegato da un token per passare dall'inizio alla fine del circuito
        \item \textbf{Portata (Throughput)}: numero di token processati per unità di tempo
    \end{itemize}
    
    Ciò che ci interessa particolarmente, è \textbf{aumentare il throughput} di un circuito. Per ottenere ciò, possiamo utilizzare una tecnica chiamata \textbf{parallelismo}, che si divide in due tipologie:
    \begin{itemize}
        \item \textbf{Parallelismo spaziale}: \textbf{duplicare l'hardware} del circuito in modo effettuare lo stesso compito multiple volte contemporaneamente
        \item \textbf{Parallelismo temporale}: il compito viene \textbf{diviso in più fasi} svolte simultaneamente (anche chiamato \textbf{pipelining}), proprio come avverrebbe in una \textit{catena di montaggio}
    \end{itemize}
    
    \subsubsection{Funzionamento del parallelismo}
    
    Ben Bitdiddle sta cucinando dei biscotti per i suoi amici, impiegando 5 minuti per impastare una teglia di biscotti e 15 minuti per cuocerli nel forno. Qual è la \textit{latenza} con cui Ben riesce a sfornare una teglia di biscotti? \textit{Quante teglie} riesce a sfornare in un'ora?
    
     \[ \textbf{Latenza} = 5 \textit{min} + 15 \textit{min} = 20 \textit{min} = \frac{1}{3} \textit{ ore} \]
    \[ \textbf{Throughput} = \frac{1 \textit{ teglia}}{\frac{1}{3} \textit{ ore}} = 3 \textit{ teglie/ora}\]
    
    Poiché ha molti amici, Ben vorrebbe aumentare la quantità di biscotti sfornati in un'ora in modo da poter raggiungere prima la quantità necessaria di biscotti. Ben decide di chiedere ad Alyssa di aiutarlo ad impastare, facendosi prestare anche il suo forno (\textbf{parallelismo spaziale}).
    
    \begin{center}
        \includegraphics[scale=0.85]{resources/images/chapter_3/parallelism1.png}
    \end{center}
     \[ \textbf{Latenza} = 5 \textit{min} + 15 \textit{min} = 20 \textit{min} = \frac{1}{3} \textit{ ore} \]
    \[ \textbf{Throughput} = 2 \cdot \frac{1 \textit{ teglia}}{\frac{1}{3} \textit{ ore}} = 6 \textit{ teglie/ora}\]
    
    Con l'aiuto di Alyssa, Ben è riuscito a raddoppiare la quantità di teglie sfornate in un'ora. Tuttavia, Ben pensa anche ad un'altra opzione, ossia impastare i biscotti dell'infornata successiva mentre aspetta che l'infornata attuale sia cotta (\textbf{parallelismo temporale}).
    
    \begin{center}
        \includegraphics[scale=0.85]{resources/images/chapter_3/parallelism2.png}
    \end{center}
    
    \textbf{ATTENZIONE}: è opportuno ricordare che con \textbf{latenza} si intende il tempo impiegato da un token per passare dall'inizio alla fine del circuito. Escludendo la prima, possiamo notare dal grafico come ogni infornata sia costituita da 5 minuti di tempo di impasto, 10 minuti di tempo di attesa affinché il forno sia libero e 15 minuti di tempo di cottura, per un totale di 30 minuti.
    
    Analogamente, ricordiamo che per \textbf{throughput} si intende il numero di token processati per unità di tempo. Dunque, escludendo ancora la prima infornata, possiamo notare come dal forno esca una teglia ogni 15 minuti, dunque 4 teglie all'ora.
    
     \[ \textbf{Latenza} = 5 \textit{min} + 10 \textit{min} + 15 \textit{min} = 30 \textit{min} = \frac{1}{2} \textit{ ore} \]
    \[ \textbf{Throughput} = \frac{1 \textit{ teglia}}{\frac{1}{4} \textit{ ore}} = 4 \textit{ teglie/ora}\]
    
    Combinando \textbf{entrambe le tecniche} di parallelismo, Ben e Alyssa riuscirebbero a sfornare 8 teglie all'ora con una latenza di 30 minuti.
    
    \newpage
    
    \subsubsection{Parallelismo nei circuiti}
    
    Una volta capita la differenza tra i due parallelismi, vediamo \textbf{un esempio più concreto} in cui è possibile velocizzare un circuito applicando il parallelismo temporale:
    
    \begin{center}
        \includegraphics{resources/images/chapter_3/parallelism3.png}
    \end{center}
    
    Sapendo che $t_{pcq} = 15 \textit{ps}$, $t_{setup} = 65 \textit{ps}$ e $t_{pd} = 40 \textit{ps}$ per ogni porta, calcoliamo:
     \[ \textbf{Latenza} = \textit{1 colpo di clock} \]
     \[ \textbf{Periodo} = 15 \textit{ps} + 3 \cdot 40 \textit{ps} + 65 \textit{ps} = 200 \textit{ps}\]
     \[ \textbf{Frequenza} = \frac{1}{200 \textit{ps}} = 5000000000 \textit{Hz} = 5 \textit{GHz}  \]
    \[ \textbf{Throughput} = \frac{1 \textit{ operazione}}{5 \textit{GHz}} = 5Goperazioni/sec\]
    
    Per velocizzare il circuito precedente, decidiamo di aggiungere una \textbf{catena di flip-flop}, dividendolo in 2 fasi richiedenti, dunque, due colpi di clock:
    
    \begin{center}
        \includegraphics{resources/images/chapter_3/parallelism4.png}
    \end{center}
    
    Avendo spezzato l'esecuzione in due fasi, il colpo di clock avverrà dopo un periodo di tempo pari a quello della \textbf{fase più lunga} (in questo caso la prima fase).
    Sapendo sempre che $t_{pcq} = 15 \textit{ps}$, $t_{setup} = 65 \textit{ps}$ e $t_{pd} = 40 \textit{ps}$ per ogni porta, calcoliamo:
     \[ \textbf{Latenza} = \textit{2 colpi di clock} \]
     \[ \textbf{Periodo} = 15 \textit{ps} + 2 \cdot 40 \textit{ps} + 65 \textit{ps} = 160 \textit{ps}\]
     \[ \textbf{Frequenza} = \frac{1}{160 \textit{ps}} = 6250000000 \textit{Hz} = 6.25 \textit{GHz}  \]
    \[ \textbf{Throughput} = \frac{1 \textit{ operazione}}{6.25 \textit{GHz}} = 6.25Goperazioni/sec\]
    
    Aggiungendo una singola catena di registri, abbiamo \textbf{aumentato} il numero di operazioni al secondo del \textbf{25\%}, rendendo però necessari due colpi di clock. E se aggiungessimo \textbf{un'altra catena di registri}?
    
    \begin{center}
        \includegraphics{resources/images/chapter_3/parallelism5.png}
    \end{center}
     \[ \textbf{Latenza} = \textit{3 colpi di clock} \]
     \[ \textbf{Periodo} = 15 \textit{ps} + 1 \cdot 40 \textit{ps} + 65 \textit{ps} = 120 \textit{ps}\]
     \[ \textbf{Frequenza} = \frac{1}{120 \textit{ps}} = 8333333333.\overline{3} \textit{Hz} = 8.\overline{3} \textit{GHz}  \]
    \[ \textbf{Throughput} = \frac{1 \textit{ operazione}}{8.\overline{3} \textit{GHz}} = 8.\overline{3}Goperazioni/sec\]
    
    %%%%%%%%%%%%%%%%%%%%%
    %%%% NEW CHAPTER %%%%
    %%%%%%%%%%%%%%%%%%%%%
    \chapter{Blocchi costruttivi digitali}
    
    Per \textbf{blocchi costruttivi digitali} si intende l'insieme di \textbf{elementi digitali più semplici}, situati alla base della gerarchia dei componenti digitali: porte logiche, mux, decoder, registri, circuiti aritmetici, contatori, vettori di memoria e vettori logici.
    
    Questi elementi hanno delle interfacce e funzioni ben definite (\textbf{modularità}) e la loro struttura regolare (\textbf{regolarità}) permette di estenderli facilmente in formati più grandi (ad esempio, una porta 8-AND è molto semplice da realizzare utilizzando 8 porte 1-AND). Tramite questi blocchi digitali vengono realizzati dispositivi complessi, come un microprocessore.
    
    \section{Blocchi aritmetici}
    
    La prima tipologia di blocchi costruttivi digitali che vedremo è l'insieme di elementi che si occupano di compiere le principali \textbf{operazioni aritmetiche} della matematica:
    \begin{itemize}
        \item Sommatori
        \item Sottrattori
        \item Comparatori
        \item Shifter
        \item Moltiplicatori
    \end{itemize}
    
    \quad
    
    \subsection{Sommatori}
    
    Vediamo le due tipologie più semplici di sommatori ad 1 bit: \textbf{half-adder} e \textbf{full-adder}. Entrambi si occupano di \textbf{sommare due bit} ricevuti in ingresso, restituendo in output il risultato della somma e il riporto generato da essa (carry). Tuttavia il secondo riceve un \textbf{ulteriore} ingresso da sommare agli altri due, ossia l'ingresso del riporto.
    
    Ovviamente, è facile immaginare come per effettuare somme tra sequenze di bit siano necessari più sommatori ad 1-bit (successivamente vedremo come).
    
    \begin{center}
        \begin{tabular}{c c c}
            \textbf{Half-Adder} && \textbf{Full-Adder}\\
            
            \begin{circuitikz}
                \draw node[half-adder]{+};
            \end{circuitikz}
            &&
            \begin{circuitikz}
                \draw node[full-adder]{+};
            \end{circuitikz}
            \\\\
            $S = A \oplus B$ && $S = A \oplus B \oplus C_{in}$\\
            $C_{out} = AB$ && $C_{out} = AB + AC_{in} + BC_{in}$
            \\
            \begin{tabular}{c c | c c}
                A & B & S & $C_{out}$\\
                \hline
                0 & 0 & 0 & 0 \\
                0 & 1 & 1 & 0 \\
                1 & 0 & 1 & 0 \\
                1 & 1 & 0 & 1 \\
            \end{tabular}
            &&
            \begin{tabular}{c c c | c c}
            \\
                $C_{in}$ & A & B & S & $C_{out}$\\
                \hline
                0 & 0 & 0 & 0 & 0 \\
                0 & 0 & 1 & 1 & 0 \\
                0 & 1 & 0 & 1 & 0 \\
                0 & 1 & 1 & 0 & 1 \\
                1 & 0 & 0 & 1 & 0 \\
                1 & 0 & 1 & 0 & 1 \\
                1 & 1 & 0 & 0 & 1 \\
                1 & 1 & 1 & 1 & 1 \\
            \end{tabular}
            \\\\
        \end{tabular}
    \end{center}
    
    A riprova dell'\textbf{elevata regolarità} di tali componenti, possiamo puntualizzare come un full-adder possa essere realizzato concatenando due half-adder:
    
    \begin{center}
        \begin{circuitikz}
            \draw
                (0,0) node(A)[half-adder, anchor=west]{+}
                ($(A.lpin 1)+(0, -2)$) node(B)[half-adder, anchor=west]{+}
                (-2, -1.5) node(C)[or port, anchor=west, rotate=180]{}
                
                (A.lpin 2) node[anchor=south]{$A$}
                (A.lpin 1) node[anchor=south]{$B$}
                (B.lpin 1) node[anchor=south]{$C_{in}$}
                (B.rpin 1) node[anchor=north]{$S$}
                (C.out) node[anchor=east]{$C_{out}$}
                
                (A.rpin 1) -- (B.lpin 2)
                (A.bpin 1) -| (C.in 2)
                (B.bpin 1) -| (C.in 1)
            ;
        \end{circuitikz}
    \end{center}
    
    \newpage 

    \subsubsection{Sommatori a più bit}
    
    I sommatori a più bit, anche chiamati \textit{sommatori a propagazione del riporto} (\textbf{Carry Propagate Adders o CPA}), si dividono in più tipologie. Tuttavia, noi ne vedremo solo due:
    \begin{itemize}
        \item \textbf{Ripple-carry Adders}, una versione più lenta
        \item \textbf{Carry-lookahead Adders}, una versione più veloce
    \end{itemize}
    
    \begin{center}
        \begin{circuitikz}
            \draw
                (0,0) node(A)[full-adder, anchor=west]{+}
                (A.tpin 1) node[anchor=west]{$C_{in}$}
                (A.bpin 1) node[anchor=east]{$C_{out}$}
                
                ($(A.lpin 1)+(0, 0.25)$) node(n1)[anchor=south]{B}
                ($(A.lpin 2)+(0, 0.25)$) node(n2)[anchor=south]{A}
                ($(A.rpin 1)+(0, -0.3)$) node(n3)[anchor=north]{S}
                
                (A.lpin 1) node[anchor=east]{n}
                (A.lpin 2) node[anchor=east]{n}
                (A.rpin 1) node[anchor=east]{n}
                
                (A.lpin 1) node[rotate=45]{\_\_}
                (A.lpin 2) node[rotate=45]{\_\_}
                (A.rpin 1) node[rotate=45]{\_\_}
                
                (A.lpin 1) -- (n1)
                (A.lpin 2) -- (n2)
                (A.rpin 1) -- (n3)
            ;
        \end{circuitikz}
    \end{center}
    
    \subsubsection{Ripple-carry Adder}
    
    Vengono concatenati \textbf{N sommatori ad 1-bit}. Di conseguenza, ogni riporto in uscita di un sommatore M sarà il carry in ingresso del sommatore M+1 (difatti, il termine \textbf{ripple}, in questo caso traducibile come "propagazione", evidenzia proprio questo aspetto).
    
    Tuttavia, ciò necessita di \textbf{un ritardo notevole}, poiché è richiesto che il \textbf{riporto} venga \textit{trasportato} per tutta la catena di sommatori, dunque ogni sommatore dovrà attendere che il suo predecessore abbia effettuato la somma. Di seguito vediamo un esempio di \textbf{RCA a 32-bit}:
    
    \begin{center}
        \begin{circuitikz}
            \draw
                (0,0) node(A)[full-adder, anchor=west]{+}
                (A.lpin 1) node[anchor=south]{$B_0$}
                (A.lpin 2) node[anchor=south]{$A_0$}
                (A.rpin 1) node[anchor=north]{$S_0$}
                (A.tpin 1) node[anchor=west]{$C_{in}$}
                
                (-3.25,0) node(B)[full-adder, anchor=west]{+}
                (B.lpin 1) node[anchor=south]{$B_1$}
                (B.lpin 2) node[anchor=south]{$A_1$}
                (B.rpin 1) node[anchor=north]{$S_1$}
                
                (-8,0) node(C)[full-adder, anchor=west]{+}
                (C.lpin 1) node[anchor=south]{$B_{30}$}
                (C.lpin 2) node[anchor=south]{$A_{30}$}
                (C.rpin 1) node[anchor=north]{$S_{30}$}
                
                (-11.25,0) node(D)[full-adder, anchor=west]{+}
                (D.lpin 1) node[anchor=south]{$B_{31}$}
                (D.lpin 2) node[anchor=south]{$A_{31}$}
                (D.rpin 1) node[anchor=north]{$S_{31}$}
                (D.bpin 1) node[anchor=east]{$C_{out}$}
                
                (A.bpin 1) -- (B.tpin 1)
                (C.bpin 1) -- (D.tpin 1)
            ;
            
            \draw [dotted] (B.bpin 1) -- (C.tpin 1);
        \end{circuitikz}
    \end{center}
    
    \[ t_{ripple} = N \cdot t_{FA} \text{ - dove } t_{FA} \text{ è il delay di un full-adder}\]
    
    \subsubsection{Carry-lookahead Adder}
    
    Poiché utilizzare un RCA per somme tra sequenze di un elevato numero bit necessiterebbe di un ritardo enorme per ottenere il riporto finale, viene implementato un metodo che permette di \textbf{spezzare in blocchi di K sommatori} l'intera catena di sommatori, \textbf{calcolando preventivamente il riporto di ogni blocco} (\textbf{lookahead}, ossia "previsione"): se calcolo preventivamente il riporto del blocco M, il blocco M+1 potrà calcolare le sue somme in contemporanea al blocco M.
    
    \newpage

    \textbf{Definizioni}:
    \begin{itemize}
        \item A livello logico, un sommatore \textit{i} in una catena di N sommatori può \textbf{generare} un riporto di uscita nella sua somma oppure \textbf{propagare} il riporto in ingresso verso quello di uscita
        \item Possiamo quindi calcolare preventivamente i \textbf{segnali generatori} e i \textbf{segnali propagatori} di ogni sommatore, per poi andare a calcolare il suo \textbf{riporto in uscita}:
        \begin{itemize}
            \item \textbf{Generatore}: un sommatore \textit{i} può generare un riporto solo se $A_i$ \textbf{e} $B_i$ valgono entrambi 1
            \[ G_i = A_i B_i\]
            
            \item \textbf{Propagatore}: un sommatore \textit{i} può propagare un riporto solo se $A_i$ \textbf{o} $B_i$ valgono 1
            \[ P_i = A_i + B_i\]
            
            \item \textbf{Carry out}: il riporto di un sommatore \textit{i} è:
            
            \[ C_i = G_i + P_i C_{i-1} = A_i B_i + (A_i + B_i) C_{i-1}\]
        \end{itemize}
    \end{itemize}
    
    Una volta calcolati i generatori e i propagatori di ogni sommatore \textit{i} in un blocco \textit{k}, possiamo ora calcolare se il \textbf{blocco stesso} sarà un generatore e/o un propagatore.
    
    Immaginiamo di aver suddiviso la catena RCA di 32-bit mostrata precedentemente in \textbf{blocchi da 4 bit}. Scriviamo le equazioni booleane che descrivono il comportamento del blocco 3:0 (ossia dal sommatore 0 al sommatore 3).
    \[ P_{3:0} = P_3 \cdot P_2 \cdot P_1 \cdot P_0\]
    \[ G_{3:0} = G_3 + P_3 (G_2 + P_2 (G_1 + P_1 \cdot G_0 ))\]
    \[ C_{3} = G_{3:0} + P_{3:0} \cdot C_{in}\]
    
    Poiché ogni blocco della catena segue lo stesso comportamento, definiamo le seguenti \textbf{equazioni generali}:
    \[ P_{i:j} = P_i \cdot P_{i-1} \cdot P_{i-2} \cdot P_j\]
    \[ G_{i:j} = G_i + P_i (G_{i-1} + P_{i-1} (G_{i-2} + P_{i-2} \cdot G_j ))\]
    \[ C_{i} = G_{i:j} + P_{i:j} \cdot C_{j-1}\]
    
    \begin{center}
        \includegraphics[scale=0.85]{resources/images/chapter_4/carry_lookahead.png}
    \end{center}
    
    Il \textbf{percorso critico} del sistema viene quindi \textbf{ridotto} a $\textbf{t}_{\textbf{AND-OR}}$
    
    
    Possiamo quindi riassumere l'addizione tramite blocchi CSA in:
    
    \begin{enumerate}
        \item Calcolare $G_i$ e $P_i$ per \textbf{ogni sommatore} del blocco
        \item Calcolare $G_{i:j}$ e $P_{i:j}$ per \textbf{ogni blocco} della catena
        \item Mentre vengono calcolate le somme dei \textbf{blocchi intermedi}, $C_{in}$ si \textbf{propaga} in base alle logiche di generazione/propagazione dei blocchi stessi
        \item Viene calcolata la somma dell'\textbf{ultimo blocco}
    \end{enumerate}
    
    In questo modo, il \textbf{ritardo della catena} viene notevolmente diminuito: per una catena di N bit suddivisa in blocchi di K bit avremo che:
    
    \[ t_{CLA} = t_{pg} + t_{pg-block} + \left ( \frac{N}{K} - 1 \right ) \cdot t_{AND-OR} + k \cdot t_{FA} \]
    
    dove:
    \begin{itemize}
        \item $t_{pg}$ è il delay necessario per calcolare tutti i $G_i$ e $P_i$ di ogni sommatore
        \item $t_{pg-block}$ è il delay necessario per calcolare tutti i $G_{i:j}$ e $P_{i:j}$ di ogni blocco
        \item $t_{AND-OR}$ è il delay impiegato da ogni $C_{j-1}$ per passare nelle ultime due porte AND ed OR fino ad arrivare a $C_{i}$ (il percorso critico)
    \end{itemize}
    
    Generalmente, un sommatore CLA risulta \textbf{più veloce} di un sommatore RCA quando il numero di bit è \textbf{maggiore di 16}.
    
    \quad
    
    \subsection{Sottrattori e Comparatori} \label{subtractor}
    
    Ricordando il funzionamento dei numeri in \textbf{Complemento a 2} (vedi \ref{Ca2}), è facile immaginare come possa essere realizzato un sottrattore partendo da un sommatore: basta \textbf{negare} i bit della sequenza B (ed ottenere il Ca1) per poi \textbf{aggiungere 1} tramite il $C_{in}$ (ed ottenere il Ca2). Una volta ottenuto il Ca2 di B, possiamo sommare A e $B_{Ca2}$ per ottenere $A-B$, scartando il $C_{out}$ generato.
    
    \begin{center}
        \begin{circuitikz}
            \draw
                (-8,0) node(D)[subtractor, anchor=west]{}
                (D.narrow center) node[scale=1.5]{-}
                ($(D.lpin 1)+(0, 0.5)$) node(d1)[anchor=south]{B}
                ($(D.lpin 2)+(0, 0.5)$) node(d2)[anchor=south]{A}
                ($(D.rpin 1)+(0, -0.25)$) node(d3)[anchor=north]{S}
                
                (D.lpin 1) node[anchor=east]{n}
                (D.lpin 2) node[anchor=east]{n}
                (D.rpin 1) node[anchor=east]{n}
                
                (D.lpin 1) node[rotate=45]{\_\_}
                (D.lpin 2) node[rotate=45]{\_\_}
                (D.rpin 1) node[rotate=45]{\_\_}
                
                (D.lpin 1) -- (d1)
                (D.lpin 2) -- (d2)
                (D.rpin 1) -- (d3)
            ;
            \draw (-4, 0) node[]{$\Longrightarrow$};
            \draw
                (0,0) node(A)[full-adder, anchor=west]{+}
                (A.tpin 1) node[anchor=west]{1}
                (A.tpin 1) node{|}
                (A.bpin 1) node[anchor=east]{X}
                
                ($(A.lpin 1)+(-0.275, 0.65)$) node(n)[not port, scale=0.5, rotate=-90, anchor=south]{}
                ($(A.lpin 1)+(0, 1.5)$) node(n1)[anchor=south]{B}
                ($(A.lpin 2)+(0, 1.5)$) node(n2)[anchor=south]{A}
                ($(A.rpin 1)+(0, -0.25)$) node(n3)[anchor=north]{S}
                
                (A.lpin 1) node[anchor=east]{n}
                (A.lpin 2) node[anchor=east]{n}
                (A.rpin 1) node[anchor=east]{n}
                ($(n1)+(0, -0.5)$) node[anchor=east]{n}
                
                (A.lpin 1) node[rotate=45]{\_\_}
                (A.lpin 2) node[rotate=45]{\_\_}
                (A.rpin 1) node[rotate=45]{\_\_}
                ($(n1)+(0, -0.5)$) node[rotate=45]{\_\_}
                
                (n1) -- (n.in)
                (A.lpin 1) -- (n.out)
                (A.lpin 2) -- (n2)
                (A.rpin 1) -- (n3)
            ;
        \end{circuitikz}
    \end{center}
    
    Nel caso in cui volessimo \textbf{comparare due sequenze di N bit} per vedere se siano \textbf{esattamente uguali}, possiamo utilizzare una porta logica che possiede già questa funzione, ossia la porta \textbf{XNOR}. Basterebbe quindi implementare un numero N di XNOR che possano comparare a coppie gli N bit, per poi far passare tutti gli output attraverso una porta AND.
    
    \begin{center}
        \begin{circuitikz}
            \draw
                (-5,0) node(D)[comparator, anchor=west]{}
                (D.narrow center) node[scale=1.5]{=}
                ($(D.lpin 1)+(0, 0.5)$) node(d1)[anchor=south]{B}
                ($(D.lpin 2)+(0, 0.5)$) node(d2)[anchor=south]{A}
                ($(D.rpin 1)+(0, -0.25)$) node(d3)[anchor=north]{Equal}
                
                (D.lpin 1) node[anchor=east]{n}
                (D.lpin 2) node[anchor=east]{n}
                
                (D.lpin 1) node[rotate=45]{\_\_}
                (D.lpin 2) node[rotate=45]{\_\_}
                
                (D.lpin 1) -- (d1)
                (D.lpin 2) -- (d2)
                (D.rpin 1) -- (d3)
            ;
            \draw (-2.5, 0) node[]{$\Longrightarrow$};
            \draw
                (0,1.5) node(X1)[xnor port, anchor=west, rotate=-90]{}
                (X1.in 2) node[anchor=south]{$A_n$}
                (X1.in 1) node[anchor=south]{$B_n$}
                
                (3,1.5) node(X2)[xnor port, anchor=west, rotate=-90]{}
                (X2.in 2) node[anchor=south]{$A_1$}
                (X2.in 1) node[anchor=south]{$B_1$}
                
                (4.5,1.5) node(X3)[xnor port, anchor=west, rotate=-90]{}
                (X3.in 2) node[anchor=south]{$A_0$}
                (X3.in 1) node[anchor=south]{$B_0$}
                
                (5, -1.25) node(and)[and port,number inputs=3, anchor=west, scale=1.25]{}
                (and) node{n-AND}
                (and.in 3) node{/}
                ($(and.in 3)+(0,-0.2)$) node[anchor=north]{n-2}
                (and.out) node[anchor=west]{Equal}
                
                (X3.out) |- (and.in 1)
                (X2.out) |- (and.in 2)
                (X1.out) |- (and.in 3)
            ;
            \draw[dotted] ($(X1)+(1,0)$) -- +(1,0);
        \end{circuitikz}
    \end{center}
    
    \quad
    
    Se invece volessimo sapere se la s\textbf{equenza A è un valore minore della sequenza B}, ci basterebbe \textbf{sottrarre B ad A}, per poi andare a prendere \textbf{solo il bit più significativo} del risultato, poiché si tratta comunque di un risultato espresso in Ca2: se l'\textbf{MSB è 1}, allora $A < B$, altrimenti $A \geq B$.
    
    \begin{center}
        \begin{circuitikz}
            \draw
                (-8,0) node(D)[comparator, anchor=west]{}
                (D.narrow center) node[scale=1.5]{<}
                ($(D.lpin 1)+(0, 0.5)$) node(d1)[anchor=south]{B}
                ($(D.lpin 2)+(0, 0.5)$) node(d2)[anchor=south]{A}
                ($(D.rpin 1)+(0, -0.25)$) node(d3)[anchor=north]{Less}
                
                (D.lpin 1) node[anchor=east]{n}
                (D.lpin 2) node[anchor=east]{n}
                
                (D.lpin 1) node[rotate=45]{\_\_}
                (D.lpin 2) node[rotate=45]{\_\_}
                
                (D.lpin 1) -- (d1)
                (D.lpin 2) -- (d2)
                (D.rpin 1) -- (d3)
            ;
            \draw (-4, 0) node[]{$\Longrightarrow$};
            \draw
                (0,0) node(A)[subtractor, anchor=west]{}
                (A.narrow center) node[scale=1.5]{-}
                
                ($(A.lpin 1)+(0, 0.25)$) node(n1)[anchor=south]{B}
                ($(A.lpin 2)+(0, 0.25)$) node(n2)[anchor=south]{A}
                ($(A.rpin 1)+(0, -0.25)$) node(n3)[anchor=north]{$S_{MSB} \to Less$}
                
                (A.lpin 1) node[anchor=east]{n}
                (A.lpin 2) node[anchor=east]{n}
                
                (A.lpin 1) node[rotate=45]{\_\_}
                (A.lpin 2) node[rotate=45]{\_\_}
                
                (A.lpin 1) -- (n.out)
                (A.lpin 2) -- (n2)
                (A.rpin 1) -- (n3)
            ;
        \end{circuitikz}
    \end{center}
    
    \quad
    
    \subsection{Shifter}
    
    \textit{\textbf{Attenzione}: prima di studiare questa sezione è consigliato ripassare le sezioni \ref{shift1} e \ref{shift2}}
    
    \begin{itemize}
        \item \textbf{Shift logico}: il valore viene shiftato a sinistra o destra, riempiendo gli spazi vuoti con degli 0
        
        $\qquad 11011 >> 2 = \color{red}00\color{black}110
        \qquad\qquad\qquad\qquad\qquad\qquad\quad
        11011 << 2 = 011\color{red}00$
        
        \item \textbf{Shift aritmetico}: uguale allo shift logico, tuttavia durante uno shift a destra gli spazi vengono riempiti con il precedente MSB
        
        $\qquad 11011 >>> 2 = \color{red}11\color{black}110
        \qquad\qquad\qquad\qquad\qquad\qquad
        11011 <<< 2 = 011\color{red}00$
        
        \item \textbf{Rotazione}: i bit vengono ruotati in circolo verso destra o sinistra, in modo che i bit shiftati "rientrino" dal lato opposto
        
        $\qquad 11011 \textit{ ROR } 2 = \color{red}11\color{black}110
        \qquad\qquad\qquad\qquad\qquad\qquad
        11011 \textit{ ROL } 2 = 011\color{red}11$
    \end{itemize}
    
    \newpage
    
    Per implementare uno \textbf{shifter da N bit}, è necessario implementare \textbf{un mux N:1 per ogni bit}, dove i selettori dei mux corrispondono alla quantità di bit da shiftare.
    
    Vediamo l'implementazione di uno \textbf{shifter logico a destra da 4 bit}:
    
    \begin{center}
        \begin{circuitikz}
            \tikzset{mux 4by1 connected/.style={muxdemux, muxdemux def={Lh=4.5, Rh=3, NL=4, NT=2, NB=2, w=2, square pins=1}}}
            \draw
                (-2,5) node(S)[shifter]{$>>$}
                
                ($(S.tpin 1)+(0, 0.5)$) node(shift)[anchor=south]{Shift}
                ($(S.lpin 1)+(-0.5, 0)$) node(A)[anchor=east]{A}
                ($(S.rpin 1)+(0.5, 0)$) node(Y)[anchor=west]{Y}
                
                ($(S.tpin 1)+(0.25, 0.25)$) node[anchor=west]{2}
                ($(S.lpin 1)+(0, 0.25)$) node[anchor=south]{4}
                ($(S.rpin 1)+(0, 0.25)$) node[anchor=south]{4}
                
                ($(S.tpin 1)+(0, 0.25)$) node[rotate=45]{\_\_}
                (S.lpin 1) node{/}
                (S.rpin 1) node{/}
                
                (S.tpin 1) -- (shift)
                (S.lpin 1) -- (A)
                (S.rpin 1) -- (Y)
            ;
            \draw (2.4,5) node{$\Rightarrow$};
            \draw
                (5,10.5) node(a0)[anchor=south]{$A_3$}
                (5.5,10.5) node(a1)[anchor=south]{$A_2$}
                (6,10.5) node(a2)[anchor=south]{$A_1$}
                (6.5,10.5) node(a3)[anchor=south]{$A_0$}
                
                (8.5, 9) node(m1)[mux 4by1 connected]{}
                (8.5, 6) node(m2)[mux 4by1 connected]{}
                (8.5, 3) node(m3)[mux 4by1 connected]{}
                (8.5, 0) node(m4)[mux 4by1]{}
                
                (m1.rpin 1) node[anchor=west]{$Y_3$}
                (m1.tpin 1) node[anchor=south]{$S_1$}
                (m1.tpin 2) node[anchor=south]{$S_0$}
                (m1.lpin 2) node[anchor=east]{$0$}
                (m1.lpin 3) node[anchor=east]{$0$}
                (m1.lpin 4) node[anchor=east]{$0$}
                
                (m2.rpin 1) node[anchor=west]{$Y_2$}
                (m2.lpin 3) node[anchor=east]{$0$}
                (m2.lpin 4) node[anchor=east]{$0$}
                
                (m3.rpin 1) node[anchor=west]{$Y_1$}
                (m3.lpin 4) node[anchor=east]{$0$}
                
                (m4.rpin 1) node[anchor=west]{$Y_0$}
                
                (a0) |- (m1.lpin 1)
                (a0) |- (m2.lpin 2)
                (a0) |- (m3.lpin 3)
                (a0) |- (m4.lpin 4)
                
                (a1) |- (m2.lpin 1)
                (a1) |- (m3.lpin 2)
                (a1) |- (m4.lpin 3)
                
                (a2) |- (m3.lpin 1)
                (a2) |- (m4.lpin 2)
                
                (a3) |- (m4.lpin 1)
            ;
        \end{circuitikz}
    \end{center}
    
    \subsection{Moltiplicatori}
    
    Proprio come accade normalmente nel sistema binario (sezione \ref{mul_bin}), nell'ambito dei circuiti le moltiplicazioni possono essere svolte come una \textbf{somma di prodotti parziali}, dove ogni prodotto parziale corrisponde ad una \textbf{fila di sommatori}:
    
    
    \begin{center}
        \begin{tabular}{c c c}
            \\
            \begin{tabular}{ r r r r r r r c }
                  &   &   &   & 1 & 0 & 1 & x \\
                  &   &   & 1 & 1 & 1 & 1 & = \\
                \hline
                  &   &   &   & 1 & 0 & 1 & + \\
                  &   &   & ${}^{1}$1 & 0 & 1 &   & + \\
                  &   & ${}^{1}$1 & 0 & 1 &   &   & + \\
                  & ${}^{1}$1 & 0 & 1 &  &   &   & = \\
                \hline
                 1 & 0 & 0 & 1 & 0 & 1 & 1 &  \\
            \end{tabular}
            
            &\qquad\quad$\Rightarrow$ \qquad\qquad&
            
            Abbiamo bisogno di \textbf{3 file di sommatori}
        \end{tabular}
    \end{center}
    
    \begin{center}
        \includegraphics[scale=0.8]{resources/images/chapter_4/multiplier.png}
    \end{center}
    
    \section{Blocchi utilitari}
    
    Vediamo ora due tipologie di blocchi costruttivi digitali \textbf{utilitari}, ossia estremamente comodi in molte situazioni:
    
    \begin{itemize}
        \item Contatori
        \item Registri con shift
    \end{itemize}
    
    \subsection{Contatore}
    
    Un \textbf{contatore} è un blocco digitale il cui valore memorizzato all'interno viene \textbf{incrementato} ad ogni colpo di clock. Viene utilizzato per \textbf{ciclare tra un set di numeri} definiti in base alla quantità di flip-flop contenuti al suo interno (es: con 3 flip-flop avremo la sequenza 000, 001, 010, 011, 100, 101, 110, 111, 000, 001, ...).
    
    \quad
    
    \begin{center}
        \begin{circuitikz}
            \draw
                (0,0) node(C)[counter]{}
                ($(C.pin 5)+(0, 0.25)$) node[anchor=south]{N}
                (C.pin 5) node{/}
                (C.pin 5) -- +(0.25, 0)
                
                (4, 0) node{$\Rightarrow$}
                
                (10,0) node(F)[small-FF R]{}
                (F.up) node[anchor=south]{CLK}
                ($(F.pin 5)+(0, 0.25)$) node[anchor=south]{N}
                ($(F.pin 5)+(0.5, 0.25)$) node[anchor=south]{N}
                ($(F.pin 5)+(0.75, 0)$) node[anchor=west]{Q}
                ($(F.pin 5)+(0.5, 0)$) node{/}
                (F.pin 5) node{/}
                
                ($(F.pin 2)+(-1, 0)$) node(A)[full-adder, anchor=east, rotate=90]{+}
                ($(A.lpin 1)+(0, 0.25)$) node[anchor=south]{N}
                ($(A.lpin 2)+(0, 0.25)$) node[anchor=south]{N}
                ($(A.lpin 1)+(-0.5, 0)$) node[anchor=east]{}
                ($(A.lpin 2)+(-0.5, 0)$) node[anchor=east]{1}
                (A.lpin 1) node{/}
                (A.lpin 2) node{/}
                
                (A.lpin 1) -- ($(A.lpin 1)+(-0.5, 0)$) -- +(0, 2) -| ($(F.pin 5)+(0.25, 0)$)
                (A.lpin 2) -- ($(A.lpin 2)+(-0.5, 0)$)
                (F.pin 5) -- +(0.75, 0)
                (A.rpin 1) -- (F.pin 2)
            ;
        \end{circuitikz}
    \end{center}
    
    \textbf{NB}: nonostante l'input secondario in ingresso al sommatore sia \textbf{un semplice 1}, ricordiamo che per effettuare una somma siano necessari comunque \textbf{N bit} (si veda la figura), dunque il valore in ingresso corrisponderà a $000...001$.
    
    \subsection{Shift Register}
    
    Una particolare tipologia di registri sono i \textbf{registri con shift}, dove ad ogni colpo di clock un bit viene \textbf{trasferito} da un registro all'altro. Poiché è connesso un output ad ogni registro, questo blocco digitale viene chiamato anche \textbf{serial-to-parallel converter}, dove l'input seriale $\textbf{S}_\textbf{in}$ viene convertito in $N$ output paralleli.
    
    \begin{center}
        \begin{circuitikz}
            \draw
                (0,0) node(S)[shift register]{}
                (S.pin 6) node[anchor=south]{N}
                (S.pin 6) node{/}
                (S.pin 6) -- +(0.25,0)
                
                (3,0) node{$\Rightarrow$}
                
                (6,0) node(f1)[small-FF]{}
                (f1.pin 2) node[anchor=east]{$S_{in}$}
                
                (7.75,0) node(f2)[small-FF]{}
                (9.5,0) node(f3)[small-FF]{}
                
                (13,0) node(f4)[small-FF]{}
                ($(f4.pin 5)+(0.5, 0)$) node[anchor=west]{$S_{out}$}
                
                ($(f1.up)+(-1, 0)$) node(CLK)[anchor=east]{CLK}
                ($(f1.pin 5)+(0, -2)$) node(q1)[anchor=north]{$Q_0$}
                ($(f2.pin 5)+(0, -2)$) node(q2)[anchor=north]{$Q_1$}
                ($(f3.pin 5)+(0, -2)$) node(q3)[anchor=north]{$Q_2$}
                ($(f4.pin 5)+(0, -2)$) node(q4)[anchor=north]{$Q_{N-1}$}
                
                (CLK) -- (f4.up)
                (f1.pin 5) -- (q1)
                (f2.pin 5) -- (q2)
                (f3.pin 5) -- (q3)
                (f4.pin 5) -- (q4)
                
                (f1.pin 5) -- (f2.pin 2)
                (f2.pin 5) -- (f3.pin 2)
                (f4.pin 5) -- ($(f4.pin 5)+(0.5, 0)$)
            ;
            \draw[dotted] (10.5, 0) -- (12, 0);
        \end{circuitikz}
    \end{center}
    
    Esiste anche una variante del normale shift register, ossia uno \textbf{shift register con carico parallelo}, dove ad ogni registro viene \textbf{aggiunto un mux} che vada a selezionare uno solo tra l'input seriale (dunque l'output del registro precedente ad esso) ed un input esterno.
    
    Tutti i mux vengono controllati dallo stesso segnale, chiamato \textbf{Load}. Se Load = 1 allora i registri vengono caricati con il loro rispettivo "input esterno", mentre se Load = 0 essi si comportano come un normale shift register.
    
    \begin{center}
        \includegraphics[scale=0.95]{resources/images/chapter_4/shift_register.png}
    \end{center}
    
    Per via del suo doppio comportamento, questo blocco può agire sia come un \textbf{serial-to-parallel converter} ($S_{in} \to Q_{[N-1], 0}$) sia come un \textbf{parallel-to-serial converter}($D_{[N-1:0]} \to S_{out}$).
    
    \newpage
    
    \section{Memorie}
    
    Gli \textbf{array di memoria} costituiscono un modo efficiente per immagazzinare granti quantità di dati.
    Ogni array di memoria possiede $\textbf{N}$ \textbf{input} con cui è possibile codificare $\textbf{2}^\textbf{N}$ \textbf{indirizzi univoci}. Ad ogni indirizzo corrisponde una \textbf{parola di $\textbf{M}$ bit}, in cui vengono effettivamente memorizzati i dati.
    
    Una memoria, quindi, corrisponde ad una \textbf{matrice} di $\textbf{2}^\textbf{N}$ \textbf{righe} (profondità) e $\textbf{M}$ \textbf{colonne} (larghezza). 
    
    \begin{center}
        \includegraphics[scale=0.75]{resources/images/chapter_4/memory.png}
    \end{center}
    
    \textbf{ATTENZIONE}: è necessario puntualizzare come gli M bit \textbf{Data} siano sia di input, sia di output, poiché essi vengono usati \textbf{sia per la scrittura che per la lettura}. A scegliere quale delle due operazioni venga effettuata, è un ulteriore bit chiamato \textbf{WE}, abbreviativo di \textbf{write enable}, ossia "abilita scrittura".
    
    \begin{center}
        \includegraphics[scale=0.75]{resources/images/chapter_4/memory2.png}
    \end{center}
    
    Esistono \textbf{tre tipologie comuni di memorie}:
    \begin{itemize}
        \item \textbf{Static Random Access Memory (SRAM)}
        \item \textbf{Dynamic Random Access Memory (DRAM)}
        \item \textbf{Read-only Memory (ROM)}
    \end{itemize}
    
    Le prime due vengono definite \textbf{memorie volatili}, poiché i dati memorizzati al loro interno vengono persi una volta scollegata l'alimentazione elettrica, mentre la terza viene definita \textbf{non volatile}, poiché in grado di memorizzare permanentemente l'informazione al suo interno. Inoltre, quest'ultima è una memoria di \textbf{sola lettura}, dunque non è possibile sovrascrivere ciò che è memorizzato.
    
    \textbf{PS}: attualmente si è un po' perso il significato di Read-only in quanto, fatta eccezione di alcune tipologie, tutte le moderne ROM sono riscrivibili (ad esempio le \href{https://it.wikipedia.org/wiki/EEPROM}{EEPROM})
    
    \subsection{Celle di bit delle memorie}
    
    Abbiamo quindi detto che una memoria corrisponde a nient'altro che una \textbf{matrice di bit}, dove ogni bit viene memorizzato in una \textbf{cella}.
    
    Ogni parola all'interno della memoria è costituita da M celle. Per leggere i valori contenuti nelle parole, ad ogni cella viene collegato un segnale chiamato \textbf{bitline}, che ne trasporta il valore fino all'output della memoria.
    
    Abbiamo inoltre detto che ogni parola viene identificata da un \textbf{indirizzo di memoria}, codificato da $N$ bit in ingresso per un totale di $2^N$ indirizzi. Ogni indirizzo corrisponde ad una \textbf{wordline}, ossia un segnale connesso a tutte le celle costituenti la parola identificata dall'indirizzo stesso. Possiamo quindi dire che il segnale di wordline funzioni come un \textbf{segnale di enable lungo tutta la parola}, dove solo una wordline può essere attiva alla volta (one-hot).
    
    Ricapitolando, se la wordline della parola è attiva, allora il valori contenuti nelle celle della parola vengono \textbf{letti/scritt}i, altrimenti verrà dato un segnale di \textbf{alta impedenza (Z)} sulla bitline, in modo che solo la parola selezionata sia in grado di dettarne il valore.
    
    \begin{center}
        \begin{tabular}{c c c}
            \begin{tabular}{c}
                \begin{circuitikz}
                    \draw
                        (0,0) node(C)[bit-cell]{$bit$}
                        
                        ($(C.tpin 1)+(-1.5, 0)$) node(A)[anchor=east]{$wordline_n$}
                        ($(C.rpin 1)+(0, 1.5)$) node(B)[anchor=south]{$bitline_m$}
                        
                        (A) -- (C.tpin 1) -- +(2,0)
                        (B) -- (C.rpin 1) -- +(0,-1)
                    ;
                \end{circuitikz}
            \end{tabular}
            &\qquad\qquad\qquad&
            \begin{tabular}{c c | c}
                wordline & bit & bitline \\
                \hline
                0 & X & Z \\
                1 & 0 & 0 \\
                1 & 1 & 1 \\
            \end{tabular}
            \\
        \end{tabular}
    \end{center}
    
    Poiché \textbf{solo una wordline} deve essere attiva alla volta, viene logico immaginare come sia possibile implementare un \textbf{decoder $\textbf{N:2}^\textbf{N}$} come elemento in grado di selezionare una sola (ricordiamo che il decoder sfrutta una codifica \textbf{one-hot}) determinata wordline in base all'indirizzo di input dato:
    
    \begin{center}
        \includegraphics[scale=1]{resources/images/chapter_4/memory3.png}
    \end{center}
    
    
    \subsection{DRAM, SRAM e ROM}
    \begin{itemize}
        \item \textbf{Dynamic RAM (DRAM)}
        \begin{itemize}
            \item Il dato viene conservato in un \textbf{condensatore}. Se il condensatore è carico allora il bit varrà 1, altrimenti varrà 0
            \item Viene definita \textbf{dinamica} poiché i valori memorizzati devono essere \textbf{rinfrescati} dopo una determinata quantità di tempo, poiché i condensatori \textbf{perdono le cariche} al loro interno sia col passare del tempo sia durante ogni operazione di lettura
        \end{itemize}
        
        \item \textbf{Static RAM (SRAM)}
        \begin{itemize}
            \item Il dato viene conservato da un \textbf{simil circuito bistabile}
            \item Richiedono \textbf{molti più transistor} rispetto ad una DRAM, per un totale di 6 transistor (2 nel circuito più 2 nel circuito interno di ogni inverter). Tuttavia, al contrario della DRAM, il dato viene conservato in modo \textbf{statico}, dunque \textbf{non è necessario rinfrescare} il dato periodicamente
        \end{itemize}
    \end{itemize}
    
    \begin{tabular}{c c}
        \\
        \color{blue}\textbf{Dynamic RAM} & \color{blue}\textbf{Static RAM} \\
        \includegraphics[scale=0.8]{resources/images/chapter_4/dram_bit.png} &
        \includegraphics[scale=0.7]{resources/images/chapter_4/sram_bit.png}
    \end{tabular}
        
    \begin{tabular}{m{0.62\textwidth} p{0.01\textwidth} p{0.4\textwidth}}
        \begin{itemize}
            \item \textbf{ROM}
            
            \begin{itemize}
                \item Il dato non viene realmente "conservato", poiché in realtà \textbf{ogni cella} contenente un \textbf{bit uguale a 0} corrisponde ad un \textbf{un cavo fisicamente collegato alla terra della corrente (ground)}. In questo modo, \textbf{ogni altra cella} non connessa alla terrà verrà identificata come \textbf{un bit uguale ad 1}.
                
                \quad
                
                \item In questo modo, ogni volta che viene accesa l'alimentazione, la ROM avrà già "al suo interno" gli \textbf{stessi identici dati} delle volte precedenti (per questo motivo le ROM non sono riscrivibili, ma solo leggibili)
            \end{itemize}
        \end{itemize}
        & &
        \begin{tabular}{c}
            \includegraphics[scale=0.9]{resources/images/chapter_4/rom_bit.png}
        \end{tabular}
    \end{tabular}
    
    \newpage
    
    Per via del modo in cui sono costruite, i dati all'interno delle ROM possono essere rappresentati anche tramite quella che viene chiamata \textbf{Dot Notation}, dove viene inserito un \textbf{pallino} al posto di ogni cella contenente \textbf{un bit uguale ad 1}:
    
    \begin{center}
        \includegraphics[scale=0.9]{resources/images/chapter_4/dot_notation.png}
    \end{center}
    
    Inoltre, ogni memoria può essere utilizzata per \textbf{compiere operazioni logiche}: considerando gli \textbf{output Data} come degli \textbf{output di un equazione booleana}, possiamo effettuare tale equazione tramite i bit in memoria sulla \textbf{colonna} stessa dell'output, poiché ad ogni riga corrisponde un \textbf{mintermine}. Di conseguenza, le memorie possono essere usate anche come un modo per conservare le \textbf{tabelle della verità}.
    
    \begin{center}
        \begin{tabular}{c c}
            \begin{tabular}{c}
                \includegraphics[scale=0.9]{resources/images/chapter_4/rom_logic.png}
            \end{tabular}
            &
            
            \begin{tabular}{c}
                \begin{tabular}{l}
                    \\
                    $Data_2 = Address_1 \oplus Address_0$\\
                    $Data_1 = \overline{Address_1} + Address_0$\\
                    $Data_0 = \overline{Address_1} \, \overline{Address_0}$\\
                \end{tabular}
                \\\\
                
                \begin{tabular}{c c | c c c}
                    $A_1$ & $A_0$ & $D_2$ & $D_1$ & $D_0$ \\
                    \hline
                    
                    1 & 1 & 0 & \color{blue}\textbf{1} & 0 \\ 
                    1 & 0 & \color{blue}\textbf{1} & 0 & 0 \\ 
                    
                    0 & 1 & \color{blue}\textbf{1} & \color{blue}\textbf{1} & 0 \\ 
                    0 & 0 & 0 & \color{blue}\textbf{1} & \color{blue}\textbf{1} \\ 
                \end{tabular}
            \end{tabular}
        \end{tabular}
    \end{center}
    
    \newpage
    
    \section{Array Logici}
    
    Gli \textbf{array logici} sono dei componenti al cui interno vengono effettuate \textbf{operazioni logiche in serie}. Vengono suddivisi in due categorie principali:
    \begin{itemize}
        \item \textbf{Programmable Logic Array (PLA)}
        \item \textbf{Field Programmable Gate Array (FPGA)}
    \end{itemize}
    
    \subsection{Programmable Logic Array}
    
    Una PLA è una \textbf{rete combinatoria} con \textbf{M ingressi}, \textbf{N implicanti} e \textbf{P uscite}, costituita da \textbf{tre piani interni}:
    \begin{itemize}
        \item Un \textbf{piano NOT}, dove tutti gli \textit{M ingressi} vengono invertiti, in modo da avere ogni ingresso e il suo complementare (dunque ottenendo tutti i literals)
        \item Un \textbf{piano AND}, in cui alcuni literals generano \textit{N implicanti} passando attraverso degli AND connessi in modo fisso
        \item Un \textbf{piano OR}, in cui alcuni implicanti generano \textit{P output} passando attraverso degli OR connessi in modo fisso
    \end{itemize}
    
    Ad ogni output corrisponde una \textbf{funzione logica}, espressa in \textbf{forma SOP} (poiché viene effettuato un OR tra degli AND).
    
    Nella seguente immagine, viene mostrata una PLA rappresentante le funzioni  $X = \overline{A} \, \overline{B} C + AB\overline{C}$ e $Y = A\overline{B}$
    
    \begin{center}
        \includegraphics[scale=1]{resources/images/chapter_4/pla.png}
    \end{center}
    
    \newpage
    
    \subsection{Field Programmable Gate Array}
    
    Una \textbf{Field Programmable Gate Array} è una \textbf{rete combinatoria e sequenziale} composta da un insieme di \textbf{tre tipologie di componenti}:
    
    \begin{itemize}
        \item \textbf{Elementi logici o Logic Element (LE)}, che si occupano della parte logica
        \item \textbf{Blocchi I/O}, ossia elementi di input/output che si interfacciano col mondo esterno
        \item \textbf{Interconnessioni programmabili}, che connettono i LE ai blocchi I/O
        
        \qquad\qquad\includegraphics[scale=0.75]{resources/images/chapter_4/fpga.png}
    \end{itemize}
    
    \subsubsection{Logic Element}
    
    Ogni \textbf{Logic Element} è a sua volta composto da un insieme di \textbf{tre elementi}:
    \begin{itemize}
        \item \textbf{Lookup Table (LUT)}, ossia una tabella della verità memorizzata per poter svolgere operazioni di \textbf{logica combinatoria}
        \item \textbf{Flip Flop}, per poter svolgere operazioni di \textbf{logica sequenziale}. Solitamente si tratta di un \textbf{registro programmabile}
        \item \textbf{Multiplexer}, per connettere le LUT ai FF
    \end{itemize}
    
    \begin{center}
        \begin{circuitikz}
            \draw
                (7, 0) node(m)[mux 2by1, anchor=west]{}
                
                ($(m.lpin 2)+(-7, 0)$) node(l)[LUT short, anchor=west]{LUT}
                ($(l.lpin 1)+(-0.25, 0)$) node(d)[anchor=east]{data}
                (l.lpin 1) node[anchor=south]{N}
                (l.lpin 1) node{/}
                
                ($(m.lpin 2)+(-3, 0)$) node(f)[small-FF R, anchor=west]{}
                (m.rpin 1) node[anchor=west]{Y}
                (m.tpin 1) node[anchor=south]{S}
                
                (l.rpin 1) -| +(1, 2) -- +(4,2) |- (m.lpin 1)
                (m.lpin 2) -- (f.pin 5)
                (l.rpin 1) -- (f.pin 2)
                (d) -- (l.lpin 1)
            ;
        \end{circuitikz}
    \end{center}
    
    \section{Arithmetic Logic Unit (ALU)}
    
    L'\textbf{ALU} è uno dei blocchi digitali \textbf{fondamentali}. Dati \textbf{due input da N bit}, si occupa di svolgere \textbf{tutte le operazioni logiche ed aritmetiche di base} su di essi, i particolare:
    \begin{itemize}
        \item \textbf{Addizione}
        \item \textbf{Sottrazione}
        \item \textbf{AND}
        \item \textbf{OR}
    \end{itemize}
    
    Poiché si tratta di un \textbf{unico blocco} in grado di svolgere \textbf{4 operazioni}, è ovviamente necessario implementare un segnale, chiamato \textbf{ALUControl}, che possa andare a \textbf{selezionare quale operazione} andare ad effettuare sui due segnali in input:
    
    \begin{tabular}{m{0.5\textwidth} p{0.6\textwidth}}
        \begin{tabular}{c | c}
            $\textbf{ALUControl}_{\textbf{[1:0]}}$ & $\textbf{Operazione}$ \\
            \hline
            00 & Addizione \\
            01 & Sottrazione \\
            10 & AND\\
            11 & OR\\
        \end{tabular}
        &
        \begin{tabular}{c}
            \\\\
            \begin{circuitikz}
                \draw
                    (0,0) node(ALU)[ALU]{}
                    (ALU.narrow center) node{ALU}
                    
                    (ALU.lpin 2) node[anchor=south]{$A_{[N:0]}$} (ALU.lpin 1) node[anchor=south]{$B_{[N:0]}$} (ALU.tpin 1) node[anchor=west]{$ALUControl_{[1:0]}$} (ALU.rpin 1) node[anchor=north]{$Result_{[N:0]}$}
                ;
            \end{circuitikz}
        \\
        \end{tabular}
    \end{tabular}
    
    \begin{tabular}{m{0.45\textwidth} p{0.6\textwidth}}
        Sulla destra vediamo il \textbf{circuito interno di un'ALU}. Nonostante esso sembri a prima vista complesso, in realtà può essere scomposto in \textbf{3 blocchi}: un \textbf{blocco OR}, un \textbf{blocco AND} ed un \textbf{blocco Sommatore}.
        
        Notiamo tuttavia l'\textbf{assenza} di un \textbf{blocco Sottrattore}, poiché (come visto nella sezione \ref{subtractor}) per effettuare una sottrazione in realtà utilizziamo comunque un sommatore. Dunque, possiamo implementare un \textbf{MUX 2:1 interno}, controllato dal segnale $ALUControl_0$, che vada a selezionare se svolgere un'addizione o una sottrazione (si noti anche che tale bit viene dato in input anche come carry, poiché, in caso si scelga di effettuare una sottrazione, esso varrebbe 1, in modo da convertire B in Ca2).
        
        Infine, viene implementato un \textbf{MUX 4:1 esterno} che vada a selezionare \textbf{solo una delle 4 operazioni}.
        &
        \begin{tabular}{c}
            \includegraphics[scale=0.95]{resources/images/chapter_4/alu1.png}
        \end{tabular}
    \end{tabular}
    
    \newpage
    
    \subsection{ALU con Flag di stato}
    
    Le moderne ALU sono dotate anche di 4 output aggiuntivi chiamati \textbf{Flag di stato} che danno \textbf{informazioni aggiuntive relative al risultato} dell'operazione logica/matematica appena effettuata:
    \begin{itemize}
        \item \textbf{N} - Il risultato è un numero \textbf{negativo}, dunque l'\textbf{MSB del risultato vale ad 1}.
        
        \item \textbf{Z} - Il risultato è uno \textbf{zero}, dunque  \textbf{tutti i bit del risultato sono 0}. 
        
        \item \textbf{C} - L'operazione ha generato un \textbf{riporto} (carry), dunque il $\textbf{C}_\textbf{out}$ \textbf{del sommatore vale 1} \underline{\textbf{\textit{e}}} l'operazione svolta dall'ALU è un'\textbf{addizione} o una \textbf{sottrazione}
        
        \item \textbf{V} - L'operazione ha generato un \textbf{overflow}, dunque è stata svolta svolta una \textbf{somma tra due numeri di segno uguale} (oppure una \textbf{sottrazione tra due numeri di segno opposto}) in cui il \textbf{risultato} generato è di \textbf{segno opposto}.
        
        ATTENZIONE: ricordiamo che il sommatore effettua calcoli in \textbf{Ca2}, dunque:
        \begin{itemize}
            \item[$\to$] $\color{red}0\color{black}111 + \color{red}0\color{black}001 = \color{red}1\color{black}000$ equivale a $7+1 = -8$
            \item[$\to$] $\color{red}0\color{black}111 - \color{red}1\color{black}010 = \color{red}0\color{black}111 + \color{red}0\color{black}110 =     \color{red}1\color{black}101$ equivale a $7-(-6) = -3$
        \end{itemize} 
    \end{itemize}
    
    \begin{center}
        \includegraphics[scale=0.9]{resources/images/chapter_4/alu_flags.png}
    \end{center}
    
    \quad
    
    \textbf{NB}: Lo schema riporta un'\textbf{ALU a 32 bit}, dunque ogni bit 31 corrisponde sempre ad un \textbf{MSB}. Infatti, $Sum_{31}$ corrisponde all'MSB risultato della somma tra A e B, dunque $Sum_{31} = Result_{31}$. Inoltre, da questo schema possiamo dedurre che $ALUControl_0$ si occupi di \textbf{selezionare} se svolgere un operazione logica o matematica, mentre $ALUControl_1$ si occupi di \textbf{selezionare} se svolgere un AND/Addizione oppure un OR/Sottrazione.
    
    \newpage
    
    \chapter{Linguaggi descrittivi dell'Hardware}
    
    I linguaggi descrittivi dell'hardware, in inglese \textbf{Hardware Descriptive Language (HDL)}, sono linguaggi in grado di interpretare del codice scritto descrivente i comportamenti e la struttura di un circuito, \textbf{sintetizzandolo} e producendone un modello \textbf{schematizzato}. I due HDL più utilizzati a livello commerciale sono il \textbf{SystemVerilog} (che vedremo in questo corso) e il \textbf{VHDL 2008}.
    
    I vantaggi principali degli HDL prevedono la possibilità di poter effettuare \textbf{simulazioni} del circuito, permettendo ai progettisti di risparmiare enormi quantità di tempo e denaro, e di calcolare automaticamente il \textbf{minor numero di porte} necessarie
    
    \section{Moduli Comportamentali e Strutturali}
    
    Nel linguaggi SystemVerilog, i moduli (ossia i componenti) possono essere descritti secondo due modalità:
    
    \begin{itemize}
        \item \textbf{Comportamentale}, ossia descrivendo le operazioni che il modulo deve eseguire
        \item \textbf{Strutturale}, ossia descrivendo il modo in cui i sotto-moduli al suo interno sono interconnessi tra loro, in modo da formare il modulo esterno
    \end{itemize}
    
    \subsection{Moduli Comportamentali}
    
    La sintassi prevista dal SystemVerilog per poter descrivere le operazioni svolte da un modulo è \textbf{molto simile} a quella di un normale linguaggio di programmazione, dove un modulo può essere interpretato come una \textbf{funzione} alla quale vengono passati degli \textbf{argomenti} (ossia gli input del modulo) per poi \textbf{restituire dei valori} (ossia gli output del modulo) dopo aver effettuato \textbf{operazioni} su di essi:
    
    \newpage
    
    \begin{verbatim}
    module example(input logic a, b, c, output logic y);

        assign y = ~a & ~b & ~c | a & ~b & ~c | a & ~b & c;

    endmodule
    \end{verbatim}
    
    \textbf{Legenda:}
    \begin{itemize}
        \item \textbf{module/endmodule}: indicano l'inizio e la fine del modulo. Tutto ciò che vi è all'interno farà parte del modulo.
        \item \textbf{example}: è il nome del modulo e viene deciso dal progettista che scrive il codice
        \item \textbf{input/output}: descrivono le liste di valori in input e in output
        \item \textbf{Operatori Logici}:
            \begin{itemize}
                \item \textbf{\~}: NOT
                \item \textbf{\&}: AND
                \item \textbf{|}: OR
            \end{itemize}
    \end{itemize}
    
    Il codice descritto sopra, dunque, corrisponde ad un modulo chiamato \textbf{example} con i valori \textbf{A, B} e \textbf{C} in input e il valore \textbf{Y} in output. All'interno di questo modulo viene svolta solo un'operazione di logica combinatoria, corrispondente all'equazione booleana:
    \[ Y = \overline{A} \, \overline{B} \, \overline{C} +  A \overline{B} \, \overline{C} +  A \overline{B} C\]
    
    Una volta descritto il nostro modulo, il codice verrà letto dall'interprete del SystemVerilog, generando una versione del circuito con il \textbf{minor numero di porte possibile}, ottenuta \textbf{semplificando} le equazioni booleane descritte, ed una \textbf{simulazione} di esso:
    
    \begin{center}
        \includegraphics[scale=0.7]{resources/images/chapter_5/sysver_1.png}
        
        \includegraphics[scale=0.6]{resources/images/chapter_5/sysver_2.png}
    \end{center}
    
    \newpage
    
    Altre regole sintattiche previste dal SystemVerilog sono:
    \begin{itemize}
        \item Ogni parola è \textbf{case sensitive}: \textit{reset} e \textit{Reset} non sono la stessa cosa
        \item I nomi dei moduli non possono cominciare con un \textbf{numero}: \textit{2mux} è un nome invalido
        \item I \textbf{commenti del codice} vengono indicati con
        \begin{itemize}
            \item \textbf{//} $\to$ Commento a linea singola
            \item \textit{/* ... */} $\to$ Commento multi-linea
        \end{itemize}
    \end{itemize}
    
    \subsection{Moduli Strutturali}
    
    Una volta definiti dei moduli comportamentali semplici, è possibile utilizzarli per poter creare un modulo strutturale:
    
    \quad
    
    \begin{verbatim}
    module and3(input logic a, b, c,
                output logic y);

        assign y = a & b & c;
    endmodule

    module inv(input logic a,
               output logic y);

        assign y = ~a;
    endmodule

    module nand3(input logic a, b, c
                 output logic y);

        logic n1;
        /* è un segnale interno e serve
        a creare l'interconnessione tra
        il modulo and3 e il modulo inv /*

        and3 andgate(a, b, c, n1);      //istanza di and3

        inv inverter(n1, y);    //istanza di inv
    endmodule
    \end{verbatim}
    
    In questo modo, abbiamo creato un modulo strutturale chiamato \textbf{nand3} composto da due \textbf{instanze} (ossia delle "copie") dei due moduli comportamentali \textbf{and3} e \textbf{inv} interconnessi tra loro.
    
    \newpage
    
    \section{Convenzioni del SystemVerilog}
    
    Di seguito vedremo le numerose \textbf{convenzioni} fornite dal SystemVerilog per poter progettare circuiti di larga dimensione:
    
    \begin{itemize}
        \item \textbf{Operazioni su vettori di bit}
        \item \textbf{Operatori di riduzione}
        \item \textbf{Assegnamenti condizionali}
        \item \textbf{Variabili interne}
    \end{itemize}
    
    \subsection{Operazioni su vettori di bit}
    
    Nel linguaggio SysVerilog, è possibile indicare un \textbf{vettore di bit} con la notazione $A[i:j]$, indicando una quantità di bit che vanno da \textit{j} ad \textit{i} (es: la notazione  $A[3:0]$ indica un \textbf{vettore di 4 bit})
    
    Nel caso in cui venga svolta un \textbf{operazione} su un vettore di bit, essa verrà svolta su \textbf{ogni bit} appartenente al vettore.
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item La \textbf{forma ridotta}:
    \begin{verbatim}
    module and_as_array(input logic [2:0] a, b,
                     output logic [2:0] y);
        
        assign y = a & b;
    endmodule
    \end{verbatim}
        
        \item Corrisponde alla \textbf{forma estesa}:
    \begin{verbatim}
    module and_as_bits(input logic a0, a1, a2, b0, b1, b2
                       output logic y0, y1, y2);
        
        assign y0 = a0 & b0;
        assign y1 = a1 & b1;
        assign y2 = a2 & b2;
    endmodule
    \end{verbatim}
    \end{itemize}
    
    L'uso di questa sintassi ci permette notevolmente di \textbf{velocizzare} la scrittura di componenti che eseguono operazioni con un grande numero di bit in ingresso e in uscita
    
    \newpage
    
    \textbf{Esempio}
    
    Questo \textbf{breve codice} corrisponde ad un componente che svolge tutte le operazioni logiche su due vettori di 4 bit:
    
    \begin{verbatim}
    module gates(input logic [3:0] a, b,
                 output logic [3:0] y1, y2, y3, y4, y5);

        assign y1 = a & b;    // AND
        assign y2 = a | b;    // OR
        assign y3 = a ^ b;    // XOR
        assign y4 = ~(a & b); // NAND
        assign y5 = ~(a | b); // NOR
    endmodule
    \end{verbatim}
    
    \begin{center}
        \includegraphics[scale=0.8]{resources/images/chapter_5/sysver_3.png}
    \end{center}
    
    \subsection{Operatori di riduzione}
    
    Nel caso in cui si debba eseguire un'operazione \textbf{tra} (e non su) \textbf{tutti i bit di un vettore}, è possibile utilizzare la seguente convenzione:
    
    \begin{verbatim}
    module and8(input logic [7:0] a,
                output logic y);

        assign y = &a;
        /* è molto più rapido che scrivere
        assign y = a[7] & a[6] & a[5] & a[4] &
                   a[3] & a[2] & a[1] & a[0];
        */
    endmodule\end{verbatim}
    
    \subsection{Assegnamenti condizionali}
    
    Nel caso in cui si debba andare a svolgere un assegnamento condizionale, ossia selezionare uno solo tra due valori possibili in base ad una condizione (come nel caso di un \textbf{mux}) è possibile utilizzare quello che viene chiamato \textbf{operatore ternario}:
    
    \begin{center}
        assign \textit{output} = \textit{condizione} \textbf{?} \textit{valore\_se\_vera} \textbf{:} \textit{valore\_se\_falsa}
    \end{center}
    
    Vediamo l'implementazione di un modulo \textbf{mux2} utilizzando un operatore ternario:
    
    \begin{tabular}{m{0.5 \textwidth} p{0.5 \textwidth}}
        \\
        \begin{verbatim}
      module mux2(input logic [3:0] d0, d1,
                input logic s,
                output logic [3:0] y);
                    
        assign y = s ? d1 : d0;
    endmodule
        \end{verbatim}
        &
        \begin{tabular}{c}
            \includegraphics[scale=0.9]{resources/images/chapter_5/sysver_4.png}
        \end{tabular}
    \end{tabular}
    
    \subsection{Variabili interne}
    
    Il SysVerilog permette anche la creazione di variabili interne ad un modulo, ossia dei \textbf{nodi interni} che non corrispondono agli input ed output del modulo stesso, ma sono tuttavia utilizzati al suo interno:
    
    \begin{verbatim}
    module fulladder(input logic a, b, cin,
                     output logic s, cout);

        logic p, g;     //nodi interni
        
        assign p = a ^ b;
        assign g = a & b;
        assign s = p ^ cin;
        assign cout = g | (p & cin);
    endmodule
    \end{verbatim}
    
    \begin{center}
        \includegraphics[scale=1.1]{resources/images/chapter_5/sysver_5.png}
    \end{center}
    
    \section{Numeri e Manipolazione di bit}
    
    Ovviamente, vi sono casi in cui è necessario indicare dei valori non come segnale o variabile ma come numeri veri e propri. In SystemVerilog, i numeri vengono rappresentati con la seguente forma:
    \[ N'Bvalore\]
    
    Dove \textbf{N} corrisponde al \textbf{numero di bit}, \textbf{B} alla \textbf{base} e \textbf{valore} al valore effettivo del numero
    
    \textbf{ATTENZIONE}: la clausola $N'B$ è \textbf{opzionale}, tuttavia è estremamente \textbf{raccomandata}, poiché altrimenti verrebbe sempre interpretato come un \textbf{numero decimale di dimensione massima}. Inoltre, i \_ vengono ignorati dall'interprete, dunque possono essere utilizzati come separatore di \textbf{comodità}
    
    \begin{center}
        \begin{tabular}{r | c | c | c | l}
            \\
            \textbf{Numero} & \textbf{N Bit} & \textbf{Base} & \textbf{Val. Decimale} & \textbf{Bit reali}\\
            \hline
            3'b101 & 3 & 2 & 5 & 101 \\
            'b11 & unsized & 2 & 3 & 00…0011 \\
            8'b11 & 8 & 2 & 3 & 00000011 \\
            8'b1010\_1011 & 8 & 2 & 171 & 10101011 \\
            3'd6 & 3 & 10 & 6 & 110 \\
            6'o42 & 6 & 8 & 34 & 100010 \\
            8'hAB & 8 & 16 & 171 & 10101011 \\
            42 & Unsized & 10 & 42 & 00…0101010 \\
            \\
        \end{tabular}
    \end{center}
    
    \subsubsection{Manipolazione di Bit}
    
    In SysVerilog è possibile manipolare i vettori di bit utilizzando molte convenzioni:
    
    \begin{verbatim}
    
    // { } indicano sempre un vettore di bit
    // se un numero è presente davanti a {},
    // allora quel vettore viene ripetuto per N
    
    assign y = {a[2:1], {3{b[0]}}, a[0], 6'b100_010};

    // se y è un segnale a 12-bit, l'istruzione qua sopra produce:
    
    y = { a[2] a[1] b[0] b[0] b[0] a[0] 1 0 0 0 1 0 }
    
    // inoltre, possiamo modificare anche
    // un singolo bit di un vettore
    
    Y[0] = 1’b1;
    Y[1] = 1’b0;
    \end{verbatim}
    
    \newpage
    
    \section{Datatype logici del SystemVerilog}
    
    Con il termine \textbf{DataTypes logici} intendiamo l'insieme dei \textbf{valori logici} che possono essere assunti da un componente. Nella sezione precedente abbiamo visto i \textbf{numeri}, che tuttavia corrispondono tutti a due soli datatype, ossia \textbf{0 ed 1}, poiché ogni numero viene convertito sempre in binario. Tuttavia, sappiamo dell'esistenza anche di due altri valori assumibili: \textbf{Z e X}.
    
    \begin{itemize}
        \item \textbf{X} indica un \textbf{valore logico invalido o sconosciuto} (e non un \textbf{don't care}), ossia una \textbf{contesa tra 0 ed 1} (sezione \ref{X_Z})
        \item \textbf{Z} indica un \textbf{valore fluttuante}, ossia un'\textbf{alta impedenza}
        \item All'inizio di ogni simulazione, gli output dei \textbf{nodi di stato}, come i flip-flop, vengono inizializzati come uno \textbf{stato sconosciuto (X)}, rappresentato graficamente come un segnale nel mezzo (vedere sezione successiva)
    \end{itemize}
    
    \section{Delay}
    
    In SystemVerilog è anche possibile definire il \textbf{delay} di un componente, indicato con un \# seguito da un numero indicante il numero di colpi di clock di ritardo. L'unità di misura viene specificata esternamente dal progettista (solitamente 1ns).
    
    \begin{verbatim}
    module example(input logic a, b, c,
                   output logic y);

        logic ab, bb, cb, n1, n2, n3;

        assign #1 {ab, bb, cb} = ~{a, b, c};
        assign #2 n1 = ab & bb & cb;
        assign #2 n2 = a & bb & cb;
        assign #2 n3 = a & bb & c;
        assign #4 y = n1 | n2 | n3;
    endmodule
    \end{verbatim}
    
    \begin{center}
        \includegraphics[scale=0.9]{resources/images/chapter_5/sysver_6.png}
    \end{center}
    
    \textbf{N.B.}: guardando l'inizio della simulazione è possibile notare facilmente i delay dei singoli componenti, poiché tutti i componenti vengono inizializzati come X per poi cambiare non appena tutte le condizioni necessarie vengono soddisfatte.
    
    
    \section{Logica Sequenziale}
    
    Per descrivere il funzionamento dei componenti che sfruttano la logica sequenzale, in SystemVerilog è possibile utilizzare l'istruzione \textbf{always} alla quale è possibile accodare una lista di \textbf{valori sensibili}, ossia quei segnali che, al loro \textbf{cambio di valore}, definiscono il momento in cui il componente deve \textbf{aggiornare} il suo valore (es: il segnale CLK in un flip-flop).
    
    \begin{center}
    \begin{verbatim}
    always @ (valori_sensibili)
        istruzione;
    \end{verbatim}
    \end{center}
    
    Dunque, le istruzioni inserite nel blocco \textbf{always} verranno eseguite \textbf{ogni volta} in cui uno degli \textbf{eventi} nella lista dei valori sensibili si verifica.
    
    Tuttavia, l'istruzione \textbf{always} è \textbf{generica}, ossia non possiede una sua vera e propria logica di controllo riguardo alle istruzioni che avvengono al suo interno. Dunque, all'interno di esso la gestione delle istruzioni viene affidata al progettista.
    
    Per aggirare questo problema, sono stati creati degli \textbf{idiomi} del SystemVerilog, ossia delle sue piccole varianti che aggiungono altre tipologie di istruzione \textbf{always} che invece possiedono una logica di controllo, segnalando un errore al progettista nel caso in cui non vengano rispettate le regole definite:
    \begin{itemize}
        \item \textbf{always\_ff}: utilizzato per i flip-flop
        \item \textbf{always\_latch}: utilizzato per i latch
        \item \textbf{always\_comb}: utilizzato per la logica combinatoria
    \end{itemize}
    
    In questo modo, se utilizzassimo l'istruzione \textbf{always\_ff} ma andassimo a definire una logica interna corrispondente a quella di un \textbf{latch}, il software segnalerebbe un'\textbf{incongruenza} tra la logica richiesta e quella definita.
    
    \newpage

    \subsection{Elementi di Stato in SysVerilog}
    
    Di seguito vedremo una carrellata di moduli con cui è possibile definire tutti i vari \textbf{elementi di stato} della logica sequenziale:
    
    \subsubsection{D Flip-Flop}
    
    \begin{verbatim}
    module flop(input logic clk,
                input logic [3:0] d,
                output logic [3:0] q);

        //posedge è abbreviativo di "positive-edge",
        //indicando quindi il rising edge del clock
        
        always_ff @(posedge clk)
            q <= d;     // pronunciato “Q prende D”

    endmodule
    \end{verbatim}  
    
    \subsubsection{Resettable D Flip-Flop (Sincrono)}
    
    \begin{verbatim}
    module r_flop_sync(input logic clk,
                       input logic reset,
                       input logic [3:0] d,
                       output logic [3:0] q);
        
        always_ff @(posedge clk)
        
            if(reset)
                q <= 4'b0;
                
                // 4'b0 viene automaticamente
                // convertito in 4'b0000 
            else
                q <= d;
    endmodule
    \end{verbatim}  
    
    \newpage
    \subsubsection{Resettable D Flip-Flop (Asincrono)}
    
    \begin{verbatim}
    module r_flop_async(input logic clk,
                        input logic reset,
                        input logic [3:0] d,
                        output logic [3:0] q);
        
        always_ff @(posedge clk, posedge reset)
        
            if(reset)   q <= 4'b0;
            else        q <= d;
    endmodule
    \end{verbatim}  
    
    
    \subsubsection{Enabled Resettable D Flip-Flop}
    
    \begin{verbatim}
    module en_r_flop_async(input logic clk,
                           input logic enable,
                           input logic reset,
                           input logic [3:0] d,
                           output logic [3:0] q);
        
        always_ff @(posedge clk, posedge reset)
        
            if(reset)         q <= 4'b0;
            else if(enable)   q <= d;
    endmodule
    \end{verbatim}  
    
    
    \subsubsection{D Latch}
    
    \begin{verbatim}
    module latch(input logic clk,
                 input logic [3:0] d,
                 output logic [3:0] q);
        
        always_latch
            if(clk)   q <= d;
            
    endmodule
    \end{verbatim}
    
    \newpage
    
    \subsection{Case e Casez}
    
    Oltre all'if, è possibile utilizzare l'istruzione \textbf{case} per definire una lunga serie di possibilità a seconda del \textbf{valore assunto da un segnale}. Sotto vediamo un modulo \textbf{sevenseg} corrispondente ad un \textbf{display a 7 segmenti}, il cui valore cambia a seconda del valore assunto dal segnale \textbf{data}:
    
    \begin{tabular}{m{0.6 \textwidth} p{0.05 \textwidth} p{0.5 \textwidth}}
    \begin{verbatim}
 module sevenseg(input logic [3:0] data,
                    output logic [6:0] segments);

        always_comb
            case (data)
                              // abc_defg
                
                0: segments = 7'b111_1110;
                1: segments = 7'b011_0000;
                2: segments = 7'b110_1101;
                3: segments = 7'b111_1001;
                4: segments = 7'b011_0011;
                5: segments = 7'b101_1011;
                6: segments = 7'b101_1111;
                7: segments = 7'b111_0000;
                8: segments = 7'b111_1111;
                9: segments = 7'b111_0011;
          default: segments = 7'b000_0000;
                
                // il caso di default è obbligatorio poichè
                // abbiamo utilizzato l'istruzione always_comb,
                // altrimenti il software segnalerebbe
                // una logica corrispondente ad un latch
                
            endcase
    endmodule
    \end{verbatim}
    
    &&
    
    \includegraphics[scale=0.75]{resources/images/chapter_5/sevenseg.jpeg}
    \end{tabular}
    
    \newpage
    
    A differenza dell'istruzione case, l'istruzione \textbf{casez} permette al valore da comparare con le varie possibilità di assumere anche dei valori \textbf{Z} o \textbf{?} (ossia il modo in cui vengono rappresentati i don't care in SysVerilog).
    Ad esempio, utilizzando il casez potremmo realizzare un \textbf{circuito prioritario}:
    
    \begin{verbatim}
        module priority_casez(input logic [3:0] a,
                              output logic [3:0] y);

            always_comb
                casez(a)

                    // ? è un don't care
    
                    4'b1???: y = 4'b1000;
                    4'b01??: y = 4'b0100;
                    4'b001?: y = 4'b0010;
                    4'b0001: y = 4'b0001;
                    default: y = 4'b0000;
                endcase
        endmodule
    \end{verbatim}
    
    \subsection{Assegnamento Bloccante e Non-bloccante}
    
    In SystemVerilog esistono due tipologie di \textbf{operatore di assegnamento}, \textbf{<=} e \textbf{=}.
    
    Il primo viene detto \textbf{non-bloccante}, poiché tutte le operazioni presenti all'interno di un blocco di codice che utilizzano questo operatore vengono eseguite \textbf{in sincrono}. Il secondo, invece, viene detto \textbf{bloccante}, presenti all'interno di un blocco di codice che utilizzano questo operatore vengono eseguite \textbf{in successione}, dunque nell'esatto ordine in cui sono scritte.
    
    L'\textbf{utilizzo scorretto} di questi due operatori spesso porta ad una \textbf{logica sequenziale errata}. Vediamo due esempi dello stesso codice ma con i due operatori diversi:
    \begin{verbatim}
    
    module syncronizer(input logic d, clk,
                       output logic q);
                       
        logic n1;

        always_ff @(posedge clk)
            begin
                n1 <= d;    // non-bloccante
                q  <= n1;   // non-bloccante
                
                //vengono eseguiti in sincrono
            end
    endmodule\end{verbatim}
    
    \begin{verbatim}
    module syncronizer(input logic d, clk,
                       output logic q);
                       
        logic n1;

        always_ff @(posedge clk)

            begin
                n1 = d;    // bloccante
                q  = n1;   // bloccante
                
                //vengono eseguiti in successione
            end
    endmodule
    \end{verbatim}
    
    Nel \textbf{primo caso}, verranno generati \textbf{due flip-flop}, in modo che possano conservare il valore di n1 e q, restituendo q in output. Dunque, il valore di n1 e q viene aggiornato \textbf{in sincrono}, dove il valore di q diventerà il \textbf{precedente valore di n1} (dunque del colpo di clock precedente).
    
    \begin{center}
        \includegraphics[scale=1.1]{resources/images/chapter_5/non-blocking.png}
    \end{center}
    
    Nel \textbf{secondo caso}, invece, verrà generato \textbf{un solo flip-flop}, in modo che possa conservare il valore di q, restituendo q in output. Poiché i due assegnamenti avvengono \textbf{in successione}, il valore di q diventerà l'\textbf{attuale valore di n1} (dunque del colpo di clock attuale), ossia d.
    
    \begin{center}
        \includegraphics[scale=1]{resources/images/chapter_5/blocking.png}
    \end{center}
    
    \newpage
    
    \subsubsection{Errori nell'ordine delle operazioni}
    
    Tuttavia, bisogna considerare anche un \textbf{caso particolare}, ossia il caso in cui si vada a \textbf{scrivere} su un valore \textbf{dopo} aver \textbf{letto} il valore stesso utilizzando degli \textbf{assegnamenti bloccanti}:
    
    \begin{verbatim}
        
    module syncronizer(input logic d, clk,
                       output logic q);
                       
        logic n1;

        always_ff @(posedge clk)

            begin
                q  = n1;   // bloccante
                n1 = d;    // bloccante
                
                //viene generato un latch per conservare n1
            end
    endmodule
    \end{verbatim}
    
    In questo esempio andiamo \textbf{prima leggere} il valore di n1 per \textbf{poi andarlo a modificare}. La conseguenza di questo ordine di operazioni è la \textbf{generazione di un latch aggiuntivo} che possa conservare il \textbf{precedente valore di n1}, il quale verrà assegnato a q. Il risultato, quindi, è lo \textbf{stesso circuito} del primo caso con operatori \textbf{non-bloccanti} che abbiamo visto precedentemente.
    
    \section{Macchine a Stati Finiti}
    
    Come sappiamo, le FSM sono composte da \textbf{tre blocchi}: NSL, registri e OL. Per poter descrivere una FSM in SystemVerilog, quindi, ci basta definire attentamente questi stessi tre blocchi.
    Di seguito vediamo l'esempio di una FSM di cui \underline{non} definiremo le funzionalità, ma definiremo \textbf{solo i suoi stati} e le loro transizioni:
    
    \begin{center}
        \includegraphics[scale=0.6]{resources/images/chapter_5/fsm_verilog.png}
    \end{center}
    
    \newpage
    \begin{verbatim}
    module threeStatesFSM (input logic clk, reset,
                           output logic q);

        // definiamo i tre stati della FSM
        typedef enum logic [1:0] {S0, S1, S2} statetype;

        statetype [1:0] state, nextstate;

        // registri della FSM
        always_ff @ (posedge clk, posedge reset)

            if (reset)  state <= S0;
            else        state <= nextstate;

        // NSL della FSM
        always_comb
            case (state)
                     S0: nextstate = S1;
                     S1: nextstate = S2;
                     S2: nextstate = S0;
                default: nextstate = S0;
            endcase

        // OL della FSM
        assign q = (state == S0);

        // q è il risultato della condizione (Vero o Falso)
        // se lo stato attuale è S0, allora q = 1, altrimenti q = 0
    endmodule\end{verbatim}
    
    \section{Moduli di Testbench}
    
    Nel SystemVerilog, esiste un'altra tipologia di moduli, ossia dei moduli che \textbf{non svolgono alcuna funzione interna}, ma si occupano solo di \textbf{fornire degli input} ad altri moduli per poi \textbf{leggerne l'output} e verificarne la \textbf{correttezza}. Questi moduli vengono detti \textbf{testbench} e vengono utilizzati per verificare il corretto funzionamento di un modulo, che viene a sua volta chiamato \textbf{DUT (Device Under Testing)}, ossia dispositivo in via di verifica.
    
    Immaginiamo di aver progettato il seguente \textbf{modulo}:
    
    \begin{verbatim}
    module sillyfunction(input logic a, b, c,
                         output logic y);

        assign y = ~b & ~c | a & ~b;
    endmodule
    \end{verbatim}
    
    Vogliamo ora verificare il corretto funzionamento del modulo. Per fare ciò, realizziamo un \textbf{modulo di testbench} che passerà dei valori in input al nostro DUT:
    
    \begin{verbatim}
    module testbench1();
        logic a, b, c;
        logic y;

        // definizione del DUT
        sillyfunction dut(a, b, c, y);

        // applicazione degli input al DUT
        
        initial begin
            a = 0; b = 0; c = 0; #10;
            c = 1; #10;
            b = 1; c = 0; #10;
            c = 1; #10;
            
            // il # indica un delay da aspettare
            // prima di testare un nuovo input
        
            a = 1; b = 0; c = 0; #10;
            c = 1; #10;
            b = 1; c = 0; #10;
            c = 1; #10;
            
            // guardando bene i valori assegnati,
            // possiamo notare come venga testata l'intera
            // tavola della verità di A, B e C
        end
    endmodule
    \end{verbatim}
    
    Tuttavia, questo modulo non è ancora in grado di verificare la \textbf{correttezza dell'output}. Per fare ciò, aggiungiamo un \textbf{controllo dopo ogni input}:
    
    \begin{verbatim}
    module testbench2();
        logic a, b, c;
        logic y;

        sillyfunction dut(a, b, c, y);

        initial begin
            // $display() mostra a schermo un messaggio
            
            a = 0; b = 0; c = 0; #10;
            if (y !== 1)    $display("000 fallito!");

            c = 1; #10;
            if (y !== 0)    $display("Test 001 fallito!");
            
            b = 1; c = 0; #10;
            if (y !== 0)    $display("Test 010 fallito!");
            
            c = 1; #10;
            if (y !== 0)    $display("Test 011 fallito!");
            
            a = 1; b = 0; c = 0; #10;
            if (y !== 1)    $display("Test 100 fallito!");
            
            c = 1; #10;
            if (y !== 1)    $display("Test 101 fallito!");
            
            b = 1; c = 0; #10;
            if (y !== 0)    $display("Test 110 fallito!");
            
            c = 1; #10;
            if (y !== 0)    $display("Test 111 fallito!");
        end
    endmodule\end{verbatim}
    
    \subsubsection{Testbench con dei Testvector}
    
    Come visto sopra, per testare \textbf{ogni input} è necessario definire numerose volte lo \textbf{stesso codice}. Possiamo facilmente immaginare come nel caso in cui si debba testare un DUT con un elevato numero di input ciò diventi un'enorme perdita di tempo.
    
    Per ovviare tale problema, è possibile definire un \textbf{file testvector} (con estensione .tv) contenente gli input e gli output da testare sul DUT.
    
    Vediamo un file corrispondente agli input passati al DUT precedentemente realizzato (le colonne corrispondono a \textit{a}, \textit{b}, \textit{c} e \textit{$y_{expected}$})
    
    \begin{verbatim}
    Contenuto del file "example.tv"
    
        000_1
        001_0
        010_0
        011_0
        100_1
        101_1
        110_0
        111_0
    \end{verbatim}
    
    In questa tipologia più complessa di testbench, il valore in output viene confrontato durante la \textbf{discesa del clock}, dunque \textbf{falling edge} e non rising edge.
    Successivamente viene riportato l'intero codice del modulo testbench per verificare il DUT progettato precedentemente. Si consiglia una \textbf{lettura lenta del codice}, poiché a prima vista potrebbe sembrare \textit{più complesso di quanto sia}:
    
\begin{verbatim}
module testbench3();
    logic clk, reset;
    logic a, b, c, yexpected;
    logic y;
    
    logic [31:0] vectornum, errors;
    // vectornum = contatore della partizione del vettore
    // errors    = contatore del numero di errori generati
    
    logic [3:0] testvectors[10000:0];
    // array contenente i valori letti dal file .tv
    
    sillyfunction dut(a, b, c, y);

    // generazione di un clock
    always
        begin
            clk = 1; #5; clk = 0; #5;
        end
        
    // all'inizio del testing, resetta il modulo
    // e leggi il file .tv
    initial
        begin
            $readmemb("example.tv", testvectors);
            // leggi il file e memorizzalo in testvectors
            
            vectornum = 0; errors = 0;
            reset = 1; #27; reset = 0;
        end
        
    // ad ogni rising edge, testa un nuovo input
    always @(posedge clk)
        begin
            #1; {a, b, c, yexpected} = testvectors[vectornum];
        end
        
    // ad ogni falling edge, controlla l'output del test
    always @(negedge clk)
    
        if (~reset) begin
        // se il reset è 1, salta la verifica
        
            if (y !== yexpected) begin
            
                $display("Errore: Val. Input = %b", {a, b, c});
                $display("Val. Output = %b (Val. atteso: %b)", y, yexpected);
                
                errors = errors + 1;
        
            // incrementa il valore di vectornum
            // e leggi il testvector successivo
            
            vectornum = vectornum + 1;
            
            // === e !== permettono di confrontare tra 1, 0, Z e X
            if (testvectors[vectornum] === 4'bx)
                begin
                    $display("%d test completati con %d errori",
                    vectornum, errors);
                    $finish;
                end
        end
endmodule
\end{verbatim}
    
    \section{Moduli parametrizzati}
    
    Fino ad ora, abbiamo visto dei moduli con degli input ed output di \textbf{dimensioni definite}. Tuttavia, è possibile realizzare dei moduli con delle \textbf{dimensioni generiche} che possono essere poi definite nel momento dell'uso
    
    \begin{verbatim}
    module mux2
            // width è un valore parametrizzato
            #(parameter width = 8)
            
            (input logic [width-1:0] d0, d1,
            input logic s,
            output logic [width-1:0] y);
                
        assign y = s ? d1 : d0;
    endmodule
    \end{verbatim}
    
    In questo modo, abbiamo definito un modulo mux2 che opera con un \textbf{numero parametrizzato di bit}. Ciò ci permette di realizzare un solo \textbf{modulo generico} per i mux, piuttosto che un modulo specifico per ogni quantità di mux:
    
    \begin{verbatim}
        mux2 #(12) mux2_12bits (d0_12, d1_12, s, out_12);
        mux2 #( 7) mux2_7bits  (d0_7,  d1_7,  s, out_7 );
        mux2 #(64) mux2_64bits (d0_64, d1_64, s, out_64);\end{verbatim}
\end{document}

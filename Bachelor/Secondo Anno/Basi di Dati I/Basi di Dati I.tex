\documentclass[a4paper, 12pt]{report}

\usepackage[dvipsnames]{xcolor}

%%%%%%%%%%%%%%%%
% Set Variables %
%%%%%%%%%%%%%%%%

\def\useItalian{1}  % 1 = Italian, 0 = English

\def\courseName{Basi di Dati I}

\def\coursePrerequisites{Nessuno}

\def\book{\curlyquotes{Principles of Database \& Knowledge-Base Systems - Vol. 1}, J. D. Ullman}

\def\authorName{Simone Bianco}
\def\email{bianco.simone@outlook.it}
\def\github{https://github.com/Exyss/university-notes}
\def\linkedin{https://www.linkedin.com/in/simone-bianco}


%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage{../../../packages/Nyx/nyx-packages}
\usepackage{../../../packages/Nyx/nyx-styles}
\usepackage{../../../packages/Nyx/nyx-frames}
\usepackage{../../../packages/Nyx/nyx-macros}
\usepackage{../../../packages/Nyx/nyx-title}
\usepackage{../../../packages/Nyx/nyx-intro}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{../../../packages/Nyx/logo.png}

\if\useItalian1
    \institute{\curlyquotes{\hspace{0.25mm}Sapienza} Università di Roma}
    \faculty{Ingegneria dell'Informazione,\\Informatica e Statistica}
    \department{Dipartimento di Informatica}
    \ifdefined\book
        \subtitle{Appunti integrati con il libro \book}
    \fi
    \author{\textit{Autore}\\\authorName}
\else
    \institute{\curlyquotes{\hspace{0.25mm}Sapienza} University of Rome}
    \faculty{Faculty of Information Engineering,\\Informatics and Statistics}
    \department{Department of Computer Science}
    \ifdefined\book
        \subtitle{Lecture notes integrated with the book \book}
    \fi
    \author{\textit{Author}\\\authorName}
\fi


\title{\courseName}
\date{\today}

% \supervisor{Linus \textsc{Torvalds}}
% \context{Well, I was bored\ldots}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
    \maketitle

    % The following style changes are valid only inside this scope 
    {
        \hypersetup{allcolors=black}
        \fancypagestyle{plain}{%
        \fancyhead{}        % clear all header fields
        \fancyfoot{}        % clear all header fields
        \fancyfoot[C]{\thepage}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}}

        \romantableofcontents
    }

    \introduction

    %%%%%%%%%%%%%%%%%%%%%
    
    \chapter{Database e DBMS}
    
    \section{Database come sistema informativo}
    Nei dispositivi elettronici, l'informazione può essere registrata sottoforma di \textbf{dati strutturati}, ossia oggetti rappresentati da piccole stringhe di simboli e numeri, oppure sottoforma di \textbf{dati de-strutturati}, ossia testi scritti in linguaggio naturale descriventi qualcosa.
    
    Tali informazioni vengono immagazzinate in \textbf{sistemi informativi}, ad esempio un grande archivio, cartaceo o digitale che sia, utilizzato per acquisire, processare e condividere informazioni all'interno di un'organizzazione.
    
    Agli albori dell'era digitale, ogni software registrava informazioni all'interno di \textbf{file} strettamente associato al software stesso. Quest'ultimo veniva pertanto scritto tramite un linguaggio di programmazione basato sulla gestione dei file, in modo da poter ottimizzare l'accesso ai dati richiesti. Ovviamente, tale soluzione presenta degli svantaggi, tra cui:
    
    \begin{itemize}
        \item \textbf{Ridondanza}: se due applicazioni usano gli stessi dati, essi devono essere replicati su entrambi i file
        \item \textbf{Inconsistenza}: l'aggiornamento di un dato potrebbe avvenire su una sola copia del dato condiviso
        \item \textbf{Dipendenza dei dati}: ogni applicazione organizza i dati in base alle proprie necessità, senza seguire uno standard
    \end{itemize}
    
    Nel corso degli anni, venne sviluppato il concetto di \textbf{Database (DB)}, ossia un insieme di file interconnessi tra loro, dove i dati sono organizzati in differenti strutture dati che ne facilitano l'utilizzo e ne ottimizzano la gestione.
    
    Per facilitare maggiormente l'uso di tali DB, vennero sviluppati dei software chiamati \textbf{Database Management System (DBMS)} in grado di gestire di grandi quantità di dati fornendo all'utente una visione astratta dei dati, svolgendo le operazioni richieste dall'utente senza che quest'ultimo si preoccupi di interrogare direttamente il DB.
    
    La struttura dell'informazione dipende dai suoi usi ed è soggetta a cambiamenti nel corso del tempo. Ad esempio, i dati di una persona (nome, cognome, data di nascita, codice fiscale, ...) possono cambiare nel tempo.
    
    
    L'obiettivo è quindi quello di semplificare l'elaborazione dei dati strutturati sfruttandone le proprietà:
    \begin{itemize}
        \item Gli accessi individuali agli elementi della struttura vengono realizzati tramite delle \textbf{query} (o interrogazioni)
        \item Le relazioni tra dati individuali vengono rappresentate tramite un \textbf{record} strutturato
    \end{itemize}
    
    In un'organizzazione, ogni componente di essa è interessato ad accedere ad una porzione del sistema informativo, richiedendo quindi che esso venga \textbf{condiviso}, riducendo la ridondanza dei dati. La condivisione di tale accesso ai dati deve essere \textbf{regolamentata}, richiedendo che ogni componente possa accedere solo ai dati di sua competenza. Tuttavia, la condivisione dei dati stessi può generare problemi di \textbf{concorrenza}, dovuta all'accesso simultaneo al sistema da parte di più componenti.
    
    \quad
    
    \section{Modellazione dei dati}
    
    I dati vengono quindi organizzati concettualmente in \textbf{aggregati di informazioni omogenee} che costituiscono i componenti del sistema informativo. Ogni operazione di aggiornamento dei dati è mirata ad singolo insieme aggregato, mentre una query potrebbe coinvolgere più di un insieme aggregato. Nel caso particolare dei database, gli aggregati di informazioni omogenee vengono costituiti da file, i quali vengono indicizzati da \textbf{indici}, ossia ulteriori file che permettono di accedere rapidamente alle informazioni contenute nei file "principali".
    
    A seconda dell'ambito, quindi, i dati assumono \textbf{due modelli} diversi:
    \begin{itemize}
        \item \textbf{Modelli logici}: indipendenti dalla struttura fisica dei dati e gestiti dal DBMS stesso. Il modello logico che verrà approfondito dettagliatamente in questo corso è il \textbf{modello relazionale}, basato sul concetto di relazione matematica. Altri modelli logici utilizzati sono il modello gerarchico, ad oggetti o a rete.
        \item \textbf{Modelli concettuali}: indipendenti dalle modalità di realizzazione. Hanno lo scopo di rappresentare le entità del mondo reale e le relazioni tra di essi. Il modello concettuale legato al modello logico relazionale è il \textbf{modello di entità-relazione (E-R)}.
    \end{itemize}

   Possiamo riassumere i concetti descritti attraverso un'\textbf{astrazione a tre livelli}:
    \begin{itemize}
        \item \textbf{Schema esterno}: descrizione di una porzione del database in un modello logico attraverso "viste" parziali ed un'organizzazione dei dati diversa o coincidente da quella dello schema logico. Tale schema non dipende dallo schema fisico e gli accessi al database possono essere effettuati solo attraverso esso. 
        \item \textbf{Schema logico}: descrizione dell'intero database nel principale modello logico del DBMS, ad esempio la struttura delle tabelle. Non dipende dallo schema esterno e da quello fisico.
        \item \textbf{Schema fisico}: rappresentazione dello schema logico attraverso il salvataggio in strutture fisiche, ad esempio in file. 
    \end{itemize}
    
    In ogni database vengono definiti uno \textbf{schema}, descrivente la struttura dei dati salvati al suo interno e le \textbf{istanze} di tale schema, ossia i valori correnti, i quali possono cambiare anche molto velocemente.
    
    Nelle sezioni successive vedremo meglio come all'interno del \textbf{modello relazionale} lo schema e le istanze vengano definiti tramite \textbf{tabelle}, dove la loro intestazione corrisponde allo schema e il loro contenuto corrisponde alle istanze di tale schema. Ad esempio, nella tabella sottostante lo schema corrisponde a (\texttt{NAME, SURNAME, BIRTH, TOWN}), mentre le righe della tabella corrispondono alle istanze:
    
    \begin{center}
        \begin{tabular}{| l | l | l | l |}
            \hline
            NAME & SURNAME & BIRTH & TOWN \\
            \hline
            Piero & Naples & 22-10-63 & Bari\\
            Marco & Bianchi & 01-05-54 & Rome\\
            Maria & Rossi & 09-02-68 & Milan\\
            Maria & Bianchi & 07-12-70 & Bari\\
            Paolo & Sossi & 15-03-75 & Palermo\\
            \hline
        \end{tabular}
    \end{center}
    
    \quad
    
    \section{Linguaggi, Integrità e Transazioni}
    
    Per la gestione e la descrizione di un database, vengono impiegati dei linguaggi specifici:
    \begin{itemize}
        \item \textbf{Data definition language (DDL)}, per la definizione degli schemi
        \item \textbf{Data manipulation language (DML)}, per le interrogazioni e gli aggiornamenti dei dati
        \item \textbf{Structured Query Language (SQL)}, un linguaggio standardizzato che racchiude DDL e DML, basato sul modello relazionale.
    \end{itemize}
    
    Tramite tali linguaggi è possibile definire quelli che vengono chiamati \textbf{vincoli di integrità}, ossia delle imposizioni che essi devono rispettare a seconda del contesto. Alcuni esempi sono:
    \begin{itemize}
        \item \textbf{Dipendenze funzionali}: uno studente può risiedere in una sola città
        \item \textbf{Vincoli di chiave}: il numero di matricola identifica univocamente uno studente
        \item \textbf{Vincoli di dominio}: un voto può essere solo un numero intero tra 18 e 30
        \item \textbf{Vincoli di dinamicità}: il salario di un impiegato non può diminuire
    \end{itemize}
    
    Fondamentale nell'ambito dei database è il concetto di \textbf{transazione}, ossia una sequenza di singole operazioni che possono avere solo due esiti possibili: eseguita completamente (\textbf{commited}) oppure annullata (\textbf{rolled back}). Ad esempio, la transazione corrispondente a "Trasferisci 1000€ dall'account C100 all'account C200" sarà:
    \begin{enumerate}
        \item Cerca C100
        \item Sottrai 1000€ al bilancio di C100
        \item Cerca C200
        \item Aggiungi 1000€ al bilancio di C200
    \end{enumerate}
    
    Nel caso in cui l'account C200 non venga trovato, è necessario effettuare un \textbf{rollback della transazione}, annullando le due operazioni precedentemente effettuate. Affinché ciò sia possibile, è necessario un \textbf{transaction log}, contenente i valori precedenti e successivi alle modifiche effettuate.
    
    Oltre alla possibilità di annullare le operazioni svolte tramite le transazioni, è necessario che all'interno di un database venga gestita la \textbf{competizione} tra le varie transazioni.

    Ad esempio, immaginiamo vengano eseguite in contemporanea le seguenti query:
    \begin{itemize}
        \item Transazione 1: "Accredita 1000€ al conto C1"
        \item Transazione 2: "Accredita 500€ al conto C1"
    \end{itemize}
    
    \quad
    
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Transazione 1} & \textbf{Tempo} & \textbf{Transazione 2}\\
    \hline
    Ricerca C1 & T1 & \\
    & T2 & Ricerca C1\\
    Cambia bilancio in: Bilancio+1000 & T3 & \\
    & T4 & Cambia bilancio in: Bilancio+500\\
    \hline
    \end{tabular}
    
    \quad
    
    In tal caso, dato un bilancio iniziale pari a $2500$, per via della \textbf{competizione} il bilancio finale sarà $3000$ e non $4000$.
    
    \chapter{Modello relazionale}
    
    Il modello relazionale, proposto per la prima volta da E. F. Codd nel 1970, è un modello di database basato sul concetto matematico di \textbf{relazione}, le quali vengono tradotte in tabelle memorizzate all'interno del database. In particolare, i dati e le relazioni (o associazioni) tra essi e dati di insiemi esterni vengono rappresentati come valori.
    
    Prima di procedere, è necessario introdurre alcune definizioni:

    \begin{frameddefn}{Dominio}
        Definiamo come \textbf{dominio} un insieme (possibilmente finito) di valori utilizzabili. Ad esempio, l'insieme dei numeri interi e l'insieme di tutte le stringhe contenenti 20 caratteri sono due domini.
    \end{frameddefn}
    
    \begin{frameddefn}{Prodotto cartesiano}
         Siano $D_1, D_2, ..., D_k$ dei domini non necessariamente distinti tra loro. Il \textbf{prodotto cartesiano} di tali domini corrisponde all'insieme delle liste ordinate dei valori appartenenti ai vari domini:
        \[ D_1 \times D_2 \times ... \times D_k : \{ (v_1, v_2, ..., v_k) \,|\, v_1 \in D_1, v_2 \in D_2, ..., v_k \in D_k\}\]
    
    \end{frameddefn}
        
    \begin{frameddefn}{Relazione}
        Definiamo come \textbf{relazione} un qualsiasi sottoinsieme di un prodotto cartesiano.
        \[ r \subseteq D_1 \times \ldots \times D_k\]
        
        Se $P$ è il prodotto cartesiano di $k$ domini, allora $r \subseteq P$ viene detta \textbf{relazione di grado $k$}.
    \end{frameddefn}
    
    \begin{frameddefn}{Tuple di una relazione}
        Data una relazione $r$ e un elemento $t \in r$, tale elemento viene detto \textbf{tupla}. La cardinalità di una relazione $\abs{r}$, quindi, corrisponde al numero di tuple appartenenti ad essa.
        
        Se $r$ è una relazione di grado $k$, allora ogni tupla $t \in r$ possiede $k$ valori al suo interno.
    \end{frameddefn}
    
    \begin{framedobs}{}
        Poiché $r \subseteq P$, dove $P$ è un prodotto cartesiano, per definizione matematica di sottoinsieme si ha che le tuple di una relazione sono \textbf{distinte tra di loro di almeno un valore}.
    \end{framedobs}
      
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Siano $D_1 : \{\texttt{white, black}\}, D_2 :\{ 0,1,2\}$. Il loro prodotto cartesiano sarà:
        \[ D_1 \times D_2 : \{ (\texttt{white}, 0),(\texttt{white}, 1), (\texttt{white}, 2),(\texttt{black}, 0),(\texttt{black}, 1), (\texttt{black}, 2)\}\]
        
        \item La seguente relazione
        \[r_1 \subseteq D_1 \times D_2 : \{ (\texttt{white}, 1),(\texttt{black}, 0),(\texttt{black}, 1)\}\]
        è una relazione di grado 2 e cardinalità 3
        
        \item La seguente relazione
        \[r_2 \subseteq D_1 \times D_2 : \{(\texttt{black}, 0),(\texttt{black}, 2)\}\]
        è una relazione di grado 2 e cardinalità 2
        
        \item Per comodità, vengono utilizzati domini già presenti all'interno della maggior parte dei linguaggi di programmazione. Ad esempio, la seguente relazione è un sottoinsieme del prodotto cartesiano tra i domini $\texttt{String} \times \texttt{String} \times \texttt{Integer} \times \texttt{Real} $:
    
        \[ r : \{ (\texttt{Paolo, Rossi, 2, 26.5}), (\texttt{Mario, Bianchi, 10, 28.7}), \}\]
        
        Come già accennato, le relazioni possono essere tradotte in \textbf{tabelle} di un database, dove ogni riga rappresenta una tupla:
        
        \begin{center}
            \begin{tabular}{| l | l | l | l | l |}
            \hline
            Paolo & Rossi & 2 & 26.5\\
            Mario & Bianchi & 10 & 28.7\\
            \hline
            \end{tabular}
        \end{center}
    \end{itemize}
    
    Introduciamo quindi la seguente notazione:
    
    \begin{frameddefn}{Elemento di una tupla}
        Data una relazione $r \subseteq D_1 \times  ... \times D_k$ di grado $k$ e data una tupla $t \in r$, indichiamo il suo \textbf{i-esimo elemento} come $t[i]$, dove $i \in [1, k]$
    \end{frameddefn}
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Se $r : \{ (0, a), (0,c), (1,b)\}$ e $t \in r : (0,a)$, allora $t[1] = 0$, $t[2] = a$ e $t[1,2] = (0,a)$
    \end{itemize}
    
    \quad    
    
    \section{Da relazioni a tabelle}
    
    Abbiamo già visto come una relazione possa essere rappresentata sottoforma di tabella.
    
    Tuttavia, rimane un problema da risolvere: come facciamo ad interpretare i dati contenuti in una tabella? Ci basta \textbf{assegnare un nome ad ogni colonna della tabella}, trasformando tali dati in informazione.
    
    Introduciamo quindi ulteriori definizioni:
    
    \begin{frameddefn}{Attributo}
        Definiamo come \textbf{attributo} la coppia $(A, dom(A))$, dove $A$ corrisponde al nome dell'attributo e $dom(A)$ corrisponde al dominio ad esso associato.
    \end{frameddefn}
    
    \begin{frameddefn}{Schema relazionale}
        Definiamo come \textbf{schema relazionale}, indicato come $R$, l'insieme di tutti gli attributi $A \in R$ descriventi la relazione associata allo schema stesso, indicato come:
        \[R(A_1, A_2, ..., A_k)\]
        
        Lo schema descrivente la struttura di una relazione è \textbf{invariante nel tempo}.
    \end{frameddefn}
    
    \begin{frameddefn}{Istanza di una relazione}
     Sia $R$ uno schema relazionale. Definiamo come \textbf{istanza di una relazione} $R(X)$, dove $X \subseteq R$ è un sottoinsieme di attributi, un \textbf{insieme di tuple} $r$ su $X$ dove $\forall t \in r$ gli attributi di $t$ corrispondono a $X$.
     
     Un'istanza di una relazione contiene i \textbf{valori attualmente memorizzati}, i quali possono anche cambiare rapidamente.
     
    Ogni tupla $t$ definita su $R$ può essere quindi vista come una funzione $t : R \to dom(A): A \mapsto t(A)$ che associa ad ogni attributo $A \in R$ l'elemento $t(a) \in dom(A)$.
    \end{frameddefn}
    
    \textbf{Esempio:}
     
    \begin{itemize}
        
        \item Le seguenti due tabelle $r_1$ ed $r_2$ sono due istanze del seguente schema $R$:
         \[ R = \{ (\texttt{Nome}, \texttt{String}), (\texttt{Cognome}, \texttt{String}), (\texttt{Esami sostenuti}, \texttt{Integer}), (\texttt{Media}, \texttt{Real})\}\]
        
        \begin{center}
            \begin{tabular}{c}
                \\
                
                \begin{tabular}{| l | l | l | l | l |}
                \hline
                \textbf{Nome} & \textbf{Cognome} & \textbf{Esami sostenuti} & \textbf{Media}\\
                \hline
                Paolo & Rossi & 2 & 26.5\\
                Mario & Bianchi & 10 & 28.7\\
                \hline
                \end{tabular}
            \end{tabular}
        \end{center}
        
        \begin{center}
            \begin{tabular}{c}
                \begin{tabular}{| l | l | l | l | l |}
                \hline
                \textbf{Nome} & \textbf{Cognome} & \textbf{Esami sostenuti} & \textbf{Media}\\
                \hline
                Giada & Verdi & 3 & 24.3\\
                Luigi & Neri & 14 & 29.8\\
                \hline
                \end{tabular}
                \\
                \\
            \end{tabular}
        \end{center}
    \end{itemize}
    
    \begin{framedobs}{}
        Una \textbf{relazione} può essere quindi vista come una tabella in cui ogni riga corrisponde ad una tupla distinta ed ogni colonna corrisponde ad un componente con valori omogenei, ossia provenienti dallo stesso dominio.
    \end{framedobs}
        
    \begin{frameddefn}{Schema di un database e Database relazionale}
        Definiamo come \textbf{schema di un database} un insieme di relazioni distinte
        \[(R_1, R_2, ..., R_n)\]
        
        Definiamo come \textbf{database relazionale} uno schema di un database $(R_1, R_2, ..., R_n)$ su cui sono definite le istanze $(r_1, r_2, ..., r_n)$, dove $\forall i \in [1,n]$ si ha che $r_i$ è un'istanza di $R_i$.
    \end{frameddefn}
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Schema relazione: \texttt{Info\_City(City, Region, Population)}
        
        \item Istanza relazione:
        
        \begin{center}
            \begin{tabular}{| l | l | l | l | l |}
            \hline
            \textbf{City} & \textbf{Region} & \textbf{Population}\\
            \hline
            Rome & Lazio & 3000000\\
            Milan & Lombardy & 1500000\\
            Genoa & Liguria & 800000\\
            Pisa & Tuscany & 150000\\
            \hline
            \end{tabular}
        \end{center}
        
    \end{itemize}
    
    \begin{framedobs}{}
        Rispetto all'uso dell'indice relativo alla loro posizione all'interno di una tupla, nell'ambito del modello relazionale gli elementi di una tupla $t \in r$, dove $r$ è istanza di $R$, vengono indicati tramite il nome dell'attributo ad essi associato.
    \end{framedobs}
    
    \newpage

    \textbf{Esempio:}
    
    \begin{itemize}
        \item Considerando la tabella dell'esempio precedente, se $t_1 \in r$ è la prima tupla dell'istanza e $t_2 \in r$ è la seconda tupla dell'istanza, allora: 
        \[ t_1[\texttt{City}] = t_1[1] = \texttt{Rome}\]
        \[ t_2[\texttt{Region}] = t_2[2] = \texttt{Lombardy}\]
    \end{itemize}
    
    \begin{frameddefn}{Restrizione di una tupla}
        Sia $Y \subseteq X$ un sottoinsieme di attributi dello schema $X$ e sia $r$ un'istanza di $X$.
        
        Indichiamo come $t[Y]$ la \textbf{restrizione di $t \in r$}, ossia il sottoinsieme di valori di $t$ corrispondenti agli attributi in $Y$. 
    \end{frameddefn}
    
    \begin{itemize}
        \item Considerando ancora la tabella dell'esempio precedente, se $t \in r$ è la seconda tupla dell'istanza e $Y = \{\texttt{City, Population}\}$, allora: 
        \[ t[Y] = (\texttt{Milan, 1500000})\]
    \end{itemize}
    
    
    \quad
    
    \section{Riferimenti e Valori nulli}
    
    Nel modello relazionale, i riferimenti reciproci tra dati presenti all'interno di diverse relazioni viene effettuato tramite valori.
    
    Consideriamo le seguenti relazioni:
    
    \begin{center}
        \begin{tabular}{|c|c|c|c|}
            \hline
            \multicolumn{4}{|c|}{\textbf{Students}}\\
            \hline
            \textbf{Matricola} & \textbf{Surname} & \textbf{Name} & \textbf{Date of birth}\\
            \hline
            6554 & Rossi & Mario & 05/12/1978\\
            8765 & Neri & Paolo & 03/11/1976\\
            9283 & Greens & Luisa & 12/11/1979\\
            3456 & Rossi & Maria & 01/02/1978\\
            \hline
        \end{tabular}
    \end{center}
    
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            \multicolumn{3}{|c|}{\textbf{Exams}}\\
            \hline
            \textbf{Student} & \textbf{Grade} & \textbf{Course}\\
            \hline
            3456 & 30 & 04\\
            3456 & 24 & 02\\
            9283 & 28 & 01\\
            \hline
        \end{tabular}
    \end{center}
    
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            \multicolumn{3}{|c|}{\textbf{Courses}}\\
            \hline
            \textbf{Code} & \textbf{Title} & \textbf{Lecture} \\
            \hline
            01 & Chemistry & Mario\\
            02 & Math & Bruni\\
            04 & Chemistry & Verdi\\
            \hline
        \end{tabular}
    \end{center}
    
    \begin{itemize}
        \item Notiamo come le tre tabelle possiedono dei valori che fanno \textbf{riferimento ad altre tuple di altre tabelle}.
    
        \item Ad esempio, la prima tupla $t$ della tabella \texttt{Exams} contiene \textbf{due riferimenti}: $t[\texttt{Student}]$ fa riferimento al campo \texttt{Matricola} dell'ultima tupla della tabella \texttt{Students}, mentre $t[\texttt{Course}]$ fa riferimento all'ultima tupla della tabella \texttt{Courses}.
    
        \item Considerando i due riferimenti, quindi, riusciamo a \textbf{ricostruire l'informazione completa}: la studentessa Maria Rossi, nata il 01/02/1978 e avente matricola 3456, ha ottenuto un voto pari a 30 all'esame di Chimica, tenuto dal docente Verdi
    \end{itemize}
    
    Spesso può capitare di non avere ancora tutte le informazioni relative ad una determinata tupla. Immaginiamo di avere una tabella \texttt{Students}, i cui attributi comprendono anche un campo \texttt{Phone number}. Potrebbe verificarsi una delle seguenti tre situazioni:
    \begin{itemize}
        \item Lo studente non ha un numero di telefono
        \item Non sappiamo se lo studente abbia un numero di telefono
        \item Lo studente ha un numero di telefono, ma non sappiamo quale sia
    \end{itemize}
    
    Poiché la tupla deve aderire allo schema della relazione imposto, non possiamo non inserire un valore all'interno di tale campo. Dunque, inseriamo un \textbf{valore di default}, chiamato \textbf{Null}.
    
    È necessario sottolineare alcuni aspetti riguardo al \textbf{valore Null}:
    \begin{itemize}
        \item Il valore Null \textbf{non corrisponde ad uno zero}
        \item Non dovrebbe mai essere utilizzato per campi fondamentali, ad esempio una matricola
        \item È un valore \textit{polimorfo}, ossia non appartiene ad alcun dominio ma può rimpiazzare un valore di qualsiasi dominio
        \item Due valori Null, anche se sullo stesso dominio, vengono considerati diversi l'uno dall'altro
        \item Utilizzare troppi valori Null viene considerata una pessima abitudine
    \end{itemize}
    
    \quad
    
    \section{Vincoli di integrità}
    
    Consideriamo il seguente database:
    
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|}
            \hline
            \multicolumn{6}{|c|}{\textbf{Employees}}\\
            \hline
            \textbf{Code} & \textbf{Surname} & \textbf{Name} & \textbf{Role} & \textbf{Hiring} & \textbf{Department}\\
            \hline
            COD1 & Rossi &  Mario &  Analyst & 1795 &  01\\
            COD2 & Bianchi &  Luigi &  Analyst & 1990 & 05\\
            COD2 & Neri & Paolo &  Admin &  1985 &  01\\
            \hline
        \end{tabular}
    \end{center}
    
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            \multicolumn{2}{|c|}{\textbf{Departments}}\\
            \hline
            \textbf{Number} & \textbf{Name} \\
            \hline
            01 & Management\\
            02 & Administration\\
            \hline
        \end{tabular}
    \end{center}
    
    Nonostante tale database risulti essere sintatticamente corretto, risultano alcune \textbf{incoerenze} nella tabella \texttt{Employees}:
    \begin{itemize}
        \item La prima tupla contiene il valore 1795 nell'attributo \texttt{Hiring} indicante l'anno di assunzione del dipendente, il che non ha senso logico
        \item La seconda tupla fa riferimento al dipartimento numero 05, il quale non esiste nella tabella \texttt{Departments}
        \item La seconda e la terza tupla contengono lo stesso valore nell'attributo \texttt{Code}, il quale invece dovrebbe rappresentare in modo univoco un dipendente
    \end{itemize}
    
    Per evitare errori di questo tipo, imponiamo sul database dei \textbf{vincoli di integrità}
    
    \begin{frameddefn}{Vincolo di integrità}
        Definiamo come \textbf{vincolo di integrità} delle proprietà che devono essere soddisfatte da ogni istanza di un database. Un database viene detto \textbf{corretto} se soddisfa tutti i vincoli di integrità associati al suo schema.
        
        I vincoli di integrità possono essere di due tipologie:
        \begin{itemize}
            \item \textbf{Intrarelazionale}, ossia definiti su una singola relazione, in particolare sugli attributi del suo schema o tra le tuple della sua istanza.
            
            \item \textbf{Interrelazionale}, ossia definiti tra più relazioni.
        \end{itemize}
    \end{frameddefn}
    
    \begin{framedprop}{}
        In particolare, individuiamo i seguenti vincoli di integrità:
        \begin{itemize}
            \item \textbf{Vincoli di dominio}, ossia delle restrizioni imposte sul dominio di un attributo della relazione
            \item \textbf{Vincoli di tupla}, ossia delle proprietà che devono essere rispettate da ogni tupla appartenente ad un'istanza di una relazione
            \item \textbf{Vincoli di unicità}, ossia l'impossibilità di avere due tuple con lo stesso valore per un determinato attributo
            \item \textbf{Vincoli di esistenza del valore}, ossia l'impossibilità per un attributo di una tupla di poter essere impostato su Null
        \end{itemize}
    \end{framedprop}
    
    \textbf{Esempio:}
    \begin{itemize}
        \item Considerando il database dell'esempio precedente, possiamo imporre i seguenti vincoli di integrità:
        \begin{itemize}
            \item \texttt{Hiring > 1980} (vincolo di dominio)
            \item \texttt{Name, Surname Not Null} (vincolo di esistenza del valore) 
            \item \texttt{Unique Employees.Code} (vincolo di unicità)
        \end{itemize}
    \end{itemize}
    
    \quad
    
    \subsection{Chiavi primarie e secondarie}
    
    \quad 
    
    \begin{frameddefn}{Chiave relazionale}
    
        Un \textbf{insieme $X$ di attributi} appartenenti ad una relazione $R$ viene detto \textbf{chiave di $R$} se:
        \begin{enumerate}
            \item Per ogni istanza $r$ di $R$, si ha che $\forall i \neq j, \nexists t_i, t_j \in r \mid t_i[X] = t_j[X]$, ossia non esistono tuple distinte aventi gli stessi valori per tutti gli attributi di $X$ (vincolo di unicità) 
            \item Non esiste un sottoinsieme $Y \subset X$ che soddisfa la prima condizione
        \end{enumerate}
    \end{frameddefn}
    
   \begin{frameddefn}{Chiave primaria}
        Data una relazione $R$, definiamo come \textbf{chiave primaria} la chiave più utilizzata (o consistente di un minor numero di attributi).
        
        Una chiave primaria, oltre al vincolo di unicità, deve rispettare anche il vincolo di esistenza del valore (\textbf{vincolo di chiave primaria})
   \end{frameddefn}
    
    \textbf{Esempio:}
    \begin{itemize}
        \item Consideriamo la seguente relazione:
    
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c|c|}
                \hline
                \multicolumn{7}{|c|}{\textbf{Employees}}\\
                \hline
                \textbf{Tax Code} & \textbf{Code} & \textbf{Surname} & \textbf{Name} & \textbf{Role} & \textbf{Hiring} & \textbf{Department}\\
                \hline
                RSS... & COD1 & Rossi &  Mario &  Analyst & 1795 &  01\\
                BNC... & COD2 & Bianchi &  Luigi &  Analyst & 1990 & 05\\
                NRI... & COD3 & Neri & Paolo &  Admin &  1985 &  01\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Cerchiamo di individuare alcune possibili chiavi all'interno di essa:
        \begin{itemize}
            \item L'attributo \texttt{Tax Code} non è una chiave poiché, nonostante sia raro, potrebbe accadere che più dipendenti abbiano lo stesso codice fiscale
            \item L'insieme \texttt{(Surname, Name, Role, Hiring)} può essere una chiave
            \item L'insieme \texttt{(Surname, Role, Hiring, Department)} può essere una chiave
            \item L'attributo \texttt{Code} può essere una chiave, implicando che qualsiasi insieme di attributi $X$ comprendente anche \texttt{Code} non possa essere chiave, poiché non soddisferebbe la seconda condizione.
            
            \item Siccome \texttt{Code} è la chiave più piccola individuata, allora essa sarà la chiave primaria di tale relazione, indicata come
            \[ \texttt{Employees(\underline{Code}, Tax Code, Surname, Name, Role, Hiring, Department)}\]
        \end{itemize}
    
    \end{itemize}
    
    \begin{frameddefn}{Vincolo di chiave esterna (o di riferimento)}
         Siano $R_1, R_2$ due relazioni, dove $X \subseteq R_1$ è una chiave primaria di $R_1$. Definiamo come \textbf{vincolo di chiave esterna} (o di riferimento) l'obbligo per un insieme di attributi $Y \subseteq R_2$ di assumere valori presenti all'interno di $X$.
         
        In altre parole, se $r_1$ ed $r_2$ sono rispettivamente un'istanza di $R_1$ ed $R_2$ si ha che:
         \[ \forall t_2 \in r_2, \exists t_1 \in r_1 \mid t_2[Y] = t_1[X]\]
    \end{frameddefn}
    
    \textbf{Esempio:}
    \begin{itemize}
        \item Consideriamo le seguenti relazioni:
    
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|}
                \hline
                \multicolumn{5}{|c|}{\textbf{Road Violations}}\\
                \hline
                \textbf{Code} & \textbf{Date} &  \textbf{Officer} & \textbf{Prov} & \textbf{Plate}\\
                \hline
                34321 & 1/2/95 & 3987 & MI & 39548K\\
                53524 & 4/3/95 & 3295 & TO & E39548\\
                64521 & 5/4/96 & 3295 & PR & 839548\\
                73321 & 5/2/98 & 9345 & PR & 839548\\
                \hline
            \end{tabular}
            
            \begin{tabular}{ccc}
                
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{\textbf{Officers}}\\
                    \hline
                    \textbf{ID} & \textbf{Surname} &  \textbf{Name}\\
                    \hline
                    3987 & Bianchi & Luca\\
                    3295 & Gialli & Piero\\
                    9345 & Rossi & Mario\\
                    7543 & Verdi & Luigi\\
                    \hline
                \end{tabular}
                
                &\qquad&
                \begin{tabular}{|c|c|c|c|}
                    \hline
                    \multicolumn{4}{|c|}{\textbf{Cars}}\\
                    \hline
                    \textbf{Prov} & \textbf{Plate} &  \textbf{Surname} & \textbf{Name}\\
                    \hline
                    MI & 39548K & Perini & Paolo\\
                    TO & E39548 & Ascani & Marco\\
                    RM & M2931D & Rossi & Mario\\
                    \hline
                \end{tabular}
                
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Individuiamo le seguenti chiavi primarie:
        \begin{itemize}
            \item \texttt{RoadViolation(\underline{Code}, Date, Officer, Prov, Plate)}
            \item \texttt{Officers(\underline{ID}, Surname, Name)}
            \item \texttt{Cars(\underline{Prov, Plate}, Surname, Name)}
        \end{itemize}
        
        \item Applichiamo quindi i seguenti vincoli di chiave secondaria:
        \begin{itemize}
            \item \texttt{Road\_Violations.Officer References Officers.ID}
            \item \texttt{Road\_Violations.(Prov, Plate) References Cars.(Prov, Plate)}
        \end{itemize}
        
        \item Una volta applicati tali vincoli, notiamo come alcune tuple di \texttt{Road} \texttt{Violations} rendano tale istanza invalide:
        \begin{itemize}
            \item Se $r$ è l'istanza di \texttt{Road Violations}, $c$ è l'istanza di \texttt{Cars} e $t_3, t_4$ sono rispettivamente la terza e la quarta tupla di $r$, allora si ha che:
            \[ \nexists t \in c \mid t_3[\texttt{Prov, Plate}] = t[\texttt{Prov, Plate}] \]
            \[ \nexists t \in c \mid t_4[\texttt{Prov, Plate}] = t[\texttt{Prov, Plate}] \]
            
            \item In altre parole, non esiste una tupla nell'istanza di \texttt{Cars} avente \texttt{(PR, 839548)} come valori di \texttt{(Prov, Plate)} 
        \end{itemize}
    
    \end{itemize}
    
    \section{Anomalie di un database}
    \label{anomalie}
    
    \quad
    
    \begin{framedprop}{Anomalie di un database}
        Se uno schema relazionale è \textbf{mal progettato}, potrebbero verificarsi le seguenti anomalie:
        
        \begin{itemize}
            \item \textbf{Anomalie di inserimento}, dove non è possibile inserire un dato senza inserire altre informazioni non vere o non disponibili
            \item \textbf{Anomalie di cancellazione}, dove la cancellazione di un record potrebbe portare alla perdita di altre informazioni importanti
            \item \textbf{Anomalie di aggiornamento}: dove l'aggiornamento di un attributo potrebbe richiedere un costo elevato in quanto andrebbe aggiornato per ogni tupla contenente lo stesso valore in tale attributo
            \item \textbf{Ridondanza dei dati}, dove vi sono molti dati ripetuti
        \end{itemize}
    \end{framedprop}
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Consideriamo il seguente schema \texttt{Università(Matr, Nome, Città, Prov, C\#, Titolo, Docente, C\_laurea, Data, Voto)}
        
        \item Dunque, una tupla rappresenta uno studente con matricola $m$ e nome $n$, residente nella città $c$ che si trova in provincia di $p$, avente sostenuto l'esame del corso con codice $c$ e titolo $t$ tenuto dal docente $d$ del corso di laurea $l$ in data $d$, ottenendo la votazione $v$.
        
        \item Notiamo la presenza di alcune anomalie all'interno di tale relazione:
        \begin{itemize}
            \item Anomalie di inserimento, poiché non è possibile inserire i dati di uno studente senza che esso abbia sostenuto un esame
            \item Anomalie di cancellazione, poiché nel caso in cui i dati di un corso debbano essere cancellati (ad esempio durante la rimozione dell'insegnamento di un corso dal piano di studi) e ci sia uno studente avente sostenuto solo l'esame di quel corso, allora verranno perse le informazioni relative allo studente
            \item Anomalie di aggiornamento, poiché nel caso in cui si debba modificare il docente di un corso è necessario modificarlo per ogni tupla in cui tale corso compare
            \item Ridondanza dei dati, poiché le informazioni sui corsi e sugli studenti sono ripetute molteplici volte
        \end{itemize}
        
        \item Tali anomalie derivano da una mal progettazione della relazione, poiché essa esprime più concetti al suo interno
        
        \item Per risolvere tale anomalie, sarebbe più opportuno decomporre tale schema in più sottoschemi, ognuno rappresentante un concetto: uno schema \texttt{Studente(Matr, Nome, Città, Prov)}, uno schema \texttt{Corso(C\#, Titolo, Docente, C\_laurea)} ed uno schema \texttt{Esame(Matr, C\#, Data, Voto)}
    \end{itemize}
    
    \chapter{Algebra relazionale}
    
    \begin{frameddefn}{Algebra relazionale}
        Definiamo come \textbf{algebra relazionale} una notazione algebrica specifica utilizzata per realizzare query su un database relazionale, composta da un insieme di operatori unari e binari che, se applicati rispettivamente ad una o due istanze di relazioni, generano una nuova istanza.
        
        In particolare, individuiamo i seguenti quattro tipi di operatore:
        \begin{enumerate}
            \item Rimozione di specifiche parti di una relazione (\textbf{Proiezione} e \textbf{Selezione})
            \item Operazioni insiemistiche (\textbf{Unione}, \textbf{Intersezione} e \textbf{Differenza})
            \item Combinazione delle tuple di due relazioni (\textbf{Prodotto cartesiano} e \textbf{Join})
            \item Ridenominazione di attributi
        \end{enumerate}
        
        L'algebra relazionale è un linguaggio procedurale, ossia descrive l'esatto ordine con cui gli operatori devono essere applicati.
    \end{frameddefn}
    
    \section{Proiezione e Selezione}
    
    \begin{frameddefn}{Proiezione}
        Sia $R$ una relazione con istanza $r$ e sia $A_1, \ldots, A_k$ un insieme di attributi. Una \textbf{proiezione} su $R$ è un operatore unario che effettua una restrizione con $A_1, \ldots, A_k$ su tutte le tuple di $R$:
        \[ \pi_{A_1, \ldots,A_k}(R) := \{ t[A_1, \ldots, A_k] \mid t \in r\}\]
        
        In altre parole, una proiezione effettua un "taglio verticale" su una relazione, selezionando solo le colonne $A_1, \ldots, A_k$
    \end{frameddefn}
    
    \newpage
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Supponiamo di voler ottenere una lista di tutti i clienti presenti in questa relazione:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \multicolumn{3}{|c|}{\textbf{Customers}}\\
                \hline
                \textbf{Name} & \textbf{C\#} & \textbf{Town}\\
                \hline
                Rossi & C1 & Roma\\
                Rossi & C2 & Milano\\
                Rossi & C3 & Milano\\
                Bianchi & C4 & Roma\\
                Verdi & C5 & Roma\\
                \hline
            \end{tabular}
        \end{center}
            
        \quad
        
        \item Proviamo ad effettuare una proiezione $\pi_{\texttt{Name}}(\texttt{Customers})$, il cui output sarà:
        
        \begin{center}
            \begin{tabular}{|c|}
                \hline
                \multicolumn{1}{|c|}{\textbf{ $\pi_{\texttt{Name}}(\texttt{Customers})$}}\\
                \hline
                \textbf{Name}\\
                \hline
                Rossi\\
                Bianchi\\
                Verdi\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item La nuova relazione generata dalla proiezione segue comunque le regole dell'insiemistica, dunque non possono esserci tuple uguali. Difatti, notiamo come nell'output sia presente una sola tupla contente il nome "Rossi", nonostante nella relazione iniziale ve ne fossero tre.
        
        \item Per prevenire tale perdita di informazione, proviamo ad effettuare la proiezione $\pi_{\texttt{Name, Town}}(\texttt{Customers})$, il cui output sarà:
        
        \begin{center}
            \begin{tabular}{|c|c|}
                \hline
                \multicolumn{2}{|c|}{\textbf{ $\pi_{\texttt{Name, Town}}(\texttt{Customers})$}}\\
                \hline
                \textbf{Name}  & \textbf{Town}\\
                \hline
                Rossi & Roma\\
                Rossi & Milano\\
                Bianchi & Roma\\
                Verdi & Roma\\
                \hline
            \end{tabular}
        \end{center}
        
        \item La situazione è migliorata rispetto alla prima proiezione, tuttavia vi è stata comunque una perdita di informazione.
        
        \item Per prevenire totalmente la perdita di informazione, quindi, sfruttiamo l'unicità della chiave \texttt{C\#}, effettuando la proiezione  $\pi_{\texttt{Name, C\#}}(\texttt{Customers})$, il cui output sarà:
        
        \begin{center}
            \begin{tabular}{|c|c|}
                \hline
                \multicolumn{2}{|c|}{\textbf{ $\pi_{\texttt{Name, C\#}}(\texttt{Customers})$}}\\
                \hline
                \textbf{Name}  & \textbf{C\#}\\
                \hline
                Rossi & C1\\
                Rossi & C2\\
                Rossi & C3\\
                Bianchi & C4\\
                Verdi & C5\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Abbiamo quindi ottenuto una lista completa dei nostri clienti senza alcuna perdita di informazioni
    \end{itemize}
    
    \quad
    
    \begin{frameddefn}{Selezione}
        Data una relazione $R$ con istanza $r$ e schema $R(X)$, una \textbf{selezione} su $R$ è un operatore unario che data una proposizione logica $\varphi$ seleziona tutte le tuple di $R$ per cui $\varphi$ è rispettata:
        \[ \sigma_{\varphi}(R) := \{ t \in r \mid \varphi \text{ è valida}\}\]
        
        Le proposizioni logiche associate ad una selezione corrispondono ad un composto di espressioni Booleane (dunque utilizzando operatori come $\land, \lor$ e $\lnot$) i cui termini appaiono nelle forme $A \theta B$ o $A \theta a$, dove:
        \begin{itemize}
            \item $A, B \in R(X) \mid dom(A)=dom(B)$
            \item $A \in R(X), a \in dom(A)$
            \item $\theta$ è un operatore di comparazione ($<,\leq,=,\geq, >$)
        \end{itemize}
        
        In altre parole, una selezione effettua un "taglio orizzontale" su una relazione, selezionando solo alcune tuple di essa.
    \end{frameddefn}
    
     \textbf{Esempio:}
    
    \begin{itemize}
        \item Supponiamo di voler ottenere tutte le informazioni riguardo i clienti provenienti da Roma presenti in questa relazione:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \multicolumn{3}{|c|}{\textbf{Customers}}\\
                \hline
                \textbf{Name} & \textbf{C\#} & \textbf{Town}\\
                \hline
                Rossi & C1 & Roma\\
                Rossi & C2 & Milano\\
                Rossi & C3 & Milano\\
                Bianchi & C4 & Roma\\
                Verdi & C5 & Roma\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Possiamo effettuare una selezione $\sigma_{\texttt{Town='Roma'}}(\texttt{Customers})$ per ottenere le tuple richieste:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \multicolumn{3}{|c|}{\textbf{$\sigma_{\texttt{Town='Roma'}}(\texttt{Customers})$}}\\
                \hline
                \textbf{Name} & \textbf{C\#} & \textbf{Town}\\
                \hline
                Rossi & C1 & Roma\\
                Bianchi & C4 & Roma\\
                Verdi & C5 & Roma\\
                \hline
            \end{tabular}
        \end{center}
        
        \item Vogliamo ora ottenere tutte le informazioni riguardo i clienti chiamati "Rossi" provenienti da Roma. Possiamo effettuare una selezione $\sigma_{\texttt{Nome='Rossi'}\land\texttt{Town='Roma'}}(\texttt{Customers})$ per ottenere le tuple richieste:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \multicolumn{3}{|c|}{\textbf{$\sigma_{\texttt{Nome='Rossi'}\land\texttt{Town='Roma'}}(\texttt{Customers})$}}\\
                \hline
                \textbf{Name} & \textbf{C\#} & \textbf{Town}\\
                \hline
                Rossi & C1 & Roma\\
                \hline
            \end{tabular}
        \end{center}
    \end{itemize}
    
    \quad
    
    \section{Unione, Intersezione e Differenza}
    
    \quad
    
    \begin{frameddefn}{Compatibilità in unione}
        Data una relazione $R_1$ con schema $R_1(A_1, \ldots, A_k)$ ed una relazione $R_2$ con schema $R_2(A_1, \ldots, A_h)$, tali relazioni vengono dette \textbf{compatibili in unione} se e solo se:
        \begin{itemize}
            \item $k = h$, ossia hanno lo stesso numero di attributi
            \item $\forall i \in [1,k], dom(R_1.A_i) = dom(R_2.A_i)$, ossia ogni attributo corrispondente ha lo stesso dominio
        \end{itemize}
        
    \end{frameddefn}
    
    \begin{frameddefn}{Unione}
        Date due relazioni \textbf{compatibili in unione} $R_1$ e $R_2$ con rispettive istanze $r_1$ e $r_2$, l'\textbf{unione} tra $R_1$ e $R_2$ è un operatore binario che restituisce una nuova relazione contenente tutte le tuple presenti in almeno una relazione tra $R_1$ e $R_2$.
        
        \[ R_1 \cup R_2 := \{ t \mid t \in r_1 \lor t \in r_2\}\]
    \end{frameddefn}
    
    \begin{framedobs}{}
        Affinché sia possibile utilizzare l'operatore di unione, non è necessario che gli attributi corrispondenti delle due relazioni abbiano lo stesso nome, ma solo lo stesso dominio (nonostante spesso non abbia alcun senso unire due relazioni aventi attributi con nomi diversi)
    \end{framedobs}
    
    \textbf{Esempi:}
    
    \begin{enumerate}
        \item
        \begin{itemize}
            \item Consideriamo le seguenti due relazioni, descriventi gli insegnanti e i responsabili di vari dipartimenti di una scuola:
            
            \begin{center}
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{\textbf{Teachers}}\\
                    \hline
                    \textbf{Name} & \textbf{Code} & \textbf{Department}\\
                    \hline
                    Rossi & C1 & Math\\
                    Rossi & C2 & Italian\\
                    Bianchi & C3 & Math\\
                    Verdi & C4 & English\\
                    \hline
                \end{tabular}
            \end{center}
            
            \begin{center}
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{\textbf{Admins}}\\
                    \hline
                    \textbf{Name} & \textbf{AdminCode} & \textbf{Department}\\
                    \hline
                    Esposito & C1 & English\\
                    Riccio & C2 & Math\\
                    Pierro & C3 & Italian\\
                    Verdi & C4 & English\\
                    Bianchi & C5 & English\\
                    \hline
                \end{tabular}
            \end{center}
            
            \quad
            
            \item Effettuando l'unione tra \texttt{Teachers} e \texttt{Admins}, otteniamo una nuova relazione contenente tutti i membri dello staff:
            \begin{center}
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{\textbf{Teachers $\cup$ Admins}}\\
                    \hline
                    \textbf{Name} & \textbf{Code} & \textbf{Department}\\
                    \hline
                    Rossi & C1 & Math\\
                    Rossi & C2 & Italian\\
                    Bianchi & C3 & Math\\
                    Verdi & C4 & English\\
                    Esposito & C1 & English\\
                    Riccio & C2 & Math\\
                    Pierro & C3 & Italian\\
                    Bianchi & C5 & English\\
                    \hline
                \end{tabular}
            \end{center}
        \end{itemize}
        
        \quad
        
        \item \begin{itemize}
            \item Consideriamo le seguenti due relazioni:
            
            \begin{center}
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{\textbf{Teachers}}\\
                    \hline
                    \textbf{Name} & \textbf{Code} & \textbf{Department}\\
                    \hline
                    Rossi & C1 & Math\\
                    Rossi & C2 & Italian\\
                    Bianchi & C3 & Math\\
                    Verdi & C4 & English\\
                    \hline
                \end{tabular}
            \end{center}
            
            \begin{center}
                \begin{tabular}{|c|c|c|c|}
                    \hline
                    \multicolumn{4}{|c|}{\textbf{Admins}}\\
                    \hline
                    \textbf{Name} & \textbf{Code} & \textbf{Department} & \textbf{Salary}\\
                    \hline
                    Esposito & C1 & English & 1250\\
                    Riccio & C2 & Math & 2000\\
                    Pierro & C3 & Italian & 1000\\
                    \hline
                \end{tabular}
            \end{center}
            
            \quad
            
            \item È impossibile applicare l'operatore unione tra le due relazioni \texttt{Teachers} e \texttt{Admins}, poiché non possiedono lo stesso numero di attributi
            
            \item Per risolvere il problema, possiamo effettuare prima una proiezione su \texttt{Admins}, per poi effettuare l'unione con \texttt{Teachers}:
            
            \begin{center}
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{$\texttt{Teachers}\cup \pi_{\texttt{Name, AdminCode, Department}}(\texttt{Admins})$}\\
                    \hline
                    \textbf{Name} & \textbf{Code} & \textbf{Department}\\
                    \hline
                    Rossi & C1 & Math\\
                    Rossi & C2 & Italian\\
                    Bianchi & C3 & Math\\
                    Verdi & C4 & English\\
                    Esposito & C1 & English\\
                    Riccio & C2 & Math\\
                    Pierro & C3 & Italian\\
                    \hline
                \end{tabular}
            \end{center}
        \end{itemize}
        
        \quad
        
        \item \begin{itemize}
            \item Consideriamo ora le seguenti due relazioni:
            
            \begin{center}
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{\textbf{Teachers}}\\
                    \hline
                    \textbf{Name} & \textbf{Code} & \textbf{Department}\\
                    \hline
                    Rossi & C1 & Math\\
                    Rossi & C2 & Italian\\
                    Bianchi & C3 & Math\\
                    Verdi & C4 & English\\
                    \hline
                \end{tabular}
            \end{center}
            
            \begin{center}
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{\textbf{Admins}}\\
                    \hline
                    \textbf{Name} & \textbf{Code} & \textbf{ServiceYears}\\
                    \hline
                    Esposito & C1 & 3\\
                    Riccio & C2 & 13\\
                    Pierro & C3 & 7\\
                    \hline
                \end{tabular}
            \end{center}
            
            \quad
            
            \item È impossibile applicare l'operatore unione tra le due relazioni \texttt{Teachers} e \texttt{Admins}, poiché $dom(\texttt{Teachers.Department}) \neq dom(\texttt{Admins.ServiceYears})$. Tuttavia, possiamo effettuare una proiezione su entrambe le relazioni, per poi unirle:
            
            \begin{center}
                \begin{tabular}{|c|c|}
                    \hline
                    \multicolumn{2}{|c|}{\textbf{$\pi_{\texttt{Name, Code}}(\texttt{Teachers}) \cup \pi_{\texttt{Name, Code}}(\texttt{Admins})$}}\\
                    \hline
                    \textbf{Name} & \textbf{Code}\\
                    \hline
                    Rossi & C1\\
                    Rossi & C2 \\
                    Bianchi & C3 \\
                    Verdi & C4\\
                    Esposito & C1\\
                    Riccio & C2\\
                    Pierro & C3\\
                    \hline
                \end{tabular}
            \end{center}
        \end{itemize}
    \end{enumerate}
    
    \begin{frameddefn}{Intersezione}
        Date due relazioni \textbf{compatibili in unione} $R_1$ e $R_2$ con rispettive istanze $r_1$ e $r_2$, l'\textbf{intersezione} tra $R_1$ e $R_2$ è un operatore binario che restituisce una nuova relazione contenente tutte le tuple presenti sia in $R_1$ sia in $R_2$.
        
        \[ R_1 \cap R_2 := \{ t \mid t \in r_1 \land t \in r_2\}\]
    \end{frameddefn}
    
    \begin{frameddefn}{Differenza}
        Date due relazioni \textbf{compatibili in unione} $R_1$ e $R_2$ con rispettive istanze $r_1$ e $r_2$, la \textbf{differenza} tra $R_1$ e $R_2$ è un operatore binario che restituisce una nuova relazione contenente tutte le tuple presenti in $R_1$ ma non in $R_2$.
        
        \[ R_1 - R_2 := \{ t \mid t \in r_1 \land t \notin r_2\}\]
    \end{frameddefn}
    
    \begin{framedobs}{}
        Contrariamente da unione e intersezione, l'operatore di differenza \textbf{non è commutativo}
    \end{framedobs}
    
    \textbf{Esempio:}
    \begin{itemize}
        \item Consideriamo le seguenti due relazioni, descriventi gli insegnanti e i responsabili di vari dipartimenti di una scuola:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \multicolumn{3}{|c|}{\textbf{Teachers}}\\
                \hline
                \textbf{Name} & \textbf{Code} & \textbf{Department}\\
                \hline
                Rossi & C1 & Math\\
                Rossi & C2 & Italian\\
                Verdi & C3 & English\\
                Bianchi & C4 & English\\
                \hline
            \end{tabular}
        \end{center}
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \multicolumn{3}{|c|}{\textbf{Admins}}\\
                \hline
                \textbf{Name} & \textbf{AdminCode} & \textbf{Department}\\
                \hline
                Esposito & C1 & English\\
                Riccio & C2 & Math\\
                Verdi & C3 & English\\
                Bianchi & C4 & English\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Effettuando l'intersezione tra \texttt{Teachers} e \texttt{Admins}, otteniamo una nuova relazione contenente tutti gli insegnanti che sono anche responsabili:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \multicolumn{3}{|c|}{\textbf{Teachers} $\cap$ \textbf{Admins}}\\
                \hline
                \textbf{Name} & \textbf{Code} & \textbf{Department}\\
                \hline
                Verdi & C3 & English\\
                Bianchi & C4 & English\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Effettuando la differenza tra \texttt{Teachers} e \texttt{Admins}, otteniamo una nuova relazione contenente tutti gli insegnanti che non sono responsabili:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \multicolumn{3}{|c|}{\textbf{Teachers} $-$ \textbf{Admins}}\\
                \hline
                \textbf{Name} & \textbf{Code} & \textbf{Department}\\
                \hline
                Rossi & C1 & Math\\
                Rossi & C2 & Italian\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Analogamente, effettuando la differenza tra \texttt{Admins} e \texttt{Teachers}, otteniamo una nuova relazione contenente tutti i responsabili che non sono insegnanti:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \multicolumn{3}{|c|}{\textbf{Admins} $-$ \textbf{Teachers}}\\
                \hline
                \textbf{Name} & \textbf{AdminCode} & \textbf{Department}\\
                \hline
                Esposito & C1 & English\\
                Riccio & C2 & Math\\
                \hline
            \end{tabular}
        \end{center}
    \end{itemize}
    
    \quad
    
    \section{Ridenominazione e Prodotto Cartesiano}
    
    \quad
    
    \begin{frameddefn}{Ridenominazione}
        Sia $R$ una relazione con istanza $r$ e schema $R(A_1, \ldots, A_k)$. Una \textbf{ridenominazione} su $R$ è un operatore unario che restituisce una nuova relazione $R'$ con istanza $r'$ e schema $R'(B_1, \ldots, B_k)$, dove le tuple di $r'$ sono identiche alle tuple di $r$:
        \[ \rho_{B_1, \ldots, B_k \gets A_1, \ldots, A_k}(R) := \{ t' \mid t'[B_i] = t[A_i], t \in r, \forall i \in [1, k]\}\]
        
        In altre parole, una ridenominazione modifica il nome di un attributo della relazione.
    \end{frameddefn}
    
    \begin{frameddefn}{Prodotto Cartesiano}
        Siano $R_1$ ed $R_2$ due relazioni con rispettive istanze $r_1$ e $r_2$. Il \textbf{prodotto cartesiano} di $R_1$ e $R_2$ è un operatore binario che restituisce una relazione contenente tutte le possibili combinazioni tra le tuple di $r_1$ e le tuple di $r_2$:
        \[ R_1 \times R_2 := \{ (t_1, t_2) \mid t_1 \in r_1, t_2 \in r_2\}\]
    \end{frameddefn}
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Consideriamo le seguenti relazioni:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \multicolumn{3}{|c|}{\textbf{Customers}}\\
                \hline
                \textbf{Name} & \textbf{C\#} & \textbf{Town}\\
                \hline
                Rossi & C1 & Roma\\
                Rossi & C2 & Milano\\
                Bianchi & C3 & Roma\\
                Verdi & C4 & Roma\\
                \hline
            \end{tabular}
        \end{center}
        
        \begin{center}
            \begin{tabular}{|c|c|c|c|}
                \hline
                \multicolumn{4}{|c|}{\textbf{Orders}}\\
                \hline
                \textbf{O\#} & \textbf{C\#} & \textbf{A\#} & \textbf{Qnty}\\
                \hline
                O1 & C1 & A1 & 100\\
                O2 & C2 & A2 & 200\\
                O3 & C3 & A2 & 150\\
                O4 & C4 & A3 & 200\\
                O1 & C1 & A2 & 200\\
                O1 & C1 & A3 & 100\\
                \hline
            \end{tabular}
        \end{center}
        
        \item Vogliamo ottenere l'elenco di tutti i clienti e gli ordini da loro effettuati.
        
        \item Prima di poter effettuare il prodotto cartesiano tra le due relazioni, è necessario ridenominare uno dei due attributi \texttt{C\#} presenti in entrambe le relazioni.
        \[ \texttt{OrdersR} = \rho_{\texttt{CC\#} \gets \texttt{C\#}}(\texttt{Orders})\]
        
        \item Successivamente, effettuando il prodotto cartesiano \texttt{Customers} $ \times $ \texttt{OrdersR}, otteniamo:
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c|c|}
                \hline
                \multicolumn{7}{|c|}{\textbf{\texttt{Customers} $ \times $ \texttt{OrdersR}}}\\
                \hline
                \textbf{Name} & \textbf{C\#} & \textbf{Town} & \textbf{O\#} & \textbf{CC\#}&  \textbf{A\#} & \textbf{Qnty}\\
                \hline
                Rossi & C1 & Roma & O1 & C1 & A1 & 100\\
                Rossi & C1 & Roma & O2 & C2 & A2 & 200\\
                Rossi & C1 & Roma & O3 & C3 & A2 & 150\\
                Rossi & C1 & Roma & O4 & C4 & A3 & 200\\
                Rossi & C1 & Roma & O1 & C1 & A2 & 200\\
                Rossi & C2 & Milano & O1 & C1 & A1 & 100\\
                Rossi & C2 & Milano & O2 & C2 & A2 & 200\\
                \vdots &\vdots &\vdots &\vdots &\vdots &\vdots &\vdots  \\
                \vdots &\vdots &\vdots &\vdots &\vdots &\vdots &\vdots \\
                Verdi & C4 & Roma & O4 & C4 & A3 & 200\\
                Verdi & C4 & Roma & O1 & C1 & A2 & 200\\
                \hline
            \end{tabular}
        \end{center}
        
        \item A questo punto, però, notiamo la presenza di alcune incorrettezze. Ad esempio, il cliente "Rossi", avente codice \texttt{C1}, non ha mai effettuato l'ordine "\texttt{(O2, C2, 200)}", il quale invece è stato effettuato dal cliente avente codice \texttt{C2}.
        
        \item Possiamo risolvere tale problema effettuando una selezione dopo aver effettuato il prodotto cartesiano:
        
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c|c|}
                \hline
                \multicolumn{7}{|c|}{\textbf{$\sigma_{C\#=CC\#}(\texttt{Customers} \times \texttt{OrdersR})$}}\\
                \hline
                \textbf{Name} & \textbf{C\#} & \textbf{Town} & \textbf{O\#} & \textbf{CC\#}&  \textbf{A\#} & \textbf{Qnty}\\
                \hline
                Rossi & C1 & Roma & O1 & C1 & A1 & 100\\
                Rossi & C1 & Roma & O1 & C1 & A2 & 200\\
                Rossi & C1 & Roma & O1 & C1 & A3 & 100\\
                Rossi & C2 & Milano & O2 & C2 & A2 & 200\\
                Bianchi & C3 & Roma & O3 & C3 & A2 & 150\\
                Verdi & C4 & Roma & O4 & C4 & A3 & 200\\
                \hline
            \end{tabular}
        \end{center}
        
        \item Infine, per via del select svolto, le colonne \texttt{C\#} e \texttt{CC\#} risultano essere uguali, dunque potremmo rimuovere una delle due effettuando una proiezione.
        
        La query finale, quindi risulta essere:
        
        \[ \texttt{OrdersR} = \rho_{\texttt{CC\#} \gets \texttt{C\#}}(\texttt{Orders})\]
        \[ \texttt{CustomerOrders} = \pi_{\texttt{Name, C\#, Town, O\#, A\#, Qnty}} (\sigma_{C\#=CC\#}(\texttt{Customers} \times \texttt{OrdersR}))\]
        
        \quad
        
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c|}
                \hline
                \multicolumn{6}{|c|}{\textbf{CustomerOrders}}\\
                \hline
                \textbf{Name} & \textbf{C\#} & \textbf{Town} & \textbf{O\#} &  \textbf{A\#} & \textbf{Qnty}\\
                \hline
                Rossi & C1 & Roma & O1 & A1 & 100\\
                Rossi & C1 & Roma & O1 & A2 & 200\\
                Rossi & C1 & Roma & O1 & A3 & 100\\
                Rossi & C2 & Milano & O2 & A2 & 200\\
                Bianchi & C3 & Roma & O3 & A2 & 150\\
                Verdi & C4 & Roma & O4 & A3 & 200\\
                \hline
            \end{tabular}
        \end{center}
    \end{itemize}
    
    \quad
    
    \section{Join Naturale e Theta Join}
    
    \quad
    
    \begin{frameddefn}{Join Naturale}
        Siano $R_1$ e $R_2$ due relazioni con rispettive istanze $r_1$ e $r_2$ e rispettivi schemi $R_1(X)$ e $R_2(Y)$. Il \textbf{join naturale} tra $R_1$ e $R_2$ è un operatore binario equivalente a:
        
        \[ R_1 \bowtie R_2 = \pi_{X,(Y-X)}(\sigma_{\varphi}(R_1 \times R_2))\]
        
        dove dato un insieme di attributi $A_1, \ldots, A_k  \mid \forall i \in [1,k], A_i \in X \cap Y$ si ha che:
        \[\varphi := R_1.A_1 = R_2.A_1 \land \ldots \land R_1.A_k = R_2.A_k\]
        
        In altre parole, il join naturale tra $R_1$ ed $R_2$ restituisce l'insieme di tutte le combinazioni tra tuple di $r_1$ ed $r_2$ che sono uguali per i loro attributi in comune.
    \end{frameddefn}
    
    \textbf{Esempi:}
    
    \begin{enumerate}
    
        \item \begin{itemize}
            \item  Riprendiamo l'esempio visto per il prodotto cartesiano: date le seguenti due relazioni, vogliamo ottenere un elenco di tutti i clienti e gli ordini da loro effettuati
        
            \begin{center}
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{\textbf{Customers}}\\
                    \hline
                    \textbf{Name} & \textbf{C\#} & \textbf{Town}\\
                    \hline
                    Rossi & C1 & Roma\\
                    Rossi & C2 & Milano\\
                    Bianchi & C3 & Roma\\
                    Verdi & C4 & Roma\\
                    \hline
                \end{tabular}
            \end{center}
            
            \begin{center}
                \begin{tabular}{|c|c|c|c|}
                    \hline
                    \multicolumn{4}{|c|}{\textbf{Orders}}\\
                    \hline
                    \textbf{O\#} & \textbf{C\#} & \textbf{A\#} & \textbf{Qnty}\\
                    \hline
                    O1 & C1 & A1 & 100\\
                    O2 & C2 & A2 & 200\\
                    O3 & C3 & A2 & 150\\
                    O4 & C4 & A3 & 200\\
                    O1 & C1 & A2 & 200\\
                    O1 & C1 & A3 & 100\\
                    \hline
                \end{tabular}
            \end{center}
            
            \quad
            
            \item Notiamo come la soluzione già vista sia equivalente ad un join naturale tra le due relazioni:
            
            \begin{center}
                \begin{tabular}{|c|c|c|c|c|c|}
                    \hline
                    \multicolumn{6}{|c|}{\textbf{\texttt{Customers $\bowtie$ Orders}}}\\
                    \hline
                    \textbf{Name} & \textbf{C\#} & \textbf{Town} & \textbf{O\#} &  \textbf{A\#} & \textbf{Qnty}\\
                    \hline
                    Rossi & C1 & Roma & O1 & A1 & 100\\
                    Rossi & C1 & Roma & O1 & A2 & 200\\
                    Rossi & C1 & Roma & O1 & A3 & 100\\
                    Rossi & C2 & Milano & O2 & A2 & 200\\
                    Bianchi & C3 & Roma & O3 & A2 & 150\\
                    Verdi & C4 & Roma & O4 & A3 & 200\\
                    \hline
                \end{tabular}
            \end{center}
        \end{itemize}
        
        \quad
        
        \item \begin{itemize}
            \item Oltre alle due precedenti relazioni, consideriamo anche la seguente relazione:
            
            \begin{center}
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{\textbf{Articles}}\\
                    \hline
                    \textbf{A\#} & \textbf{Label} & \textbf{Price}\\
                    \hline
                    A1 & Plate & 3\\
                    A2 & Glass & 2\\
                    A3 & Mug & 4\\
                    \hline
                \end{tabular}
            \end{center}
            
            \quad
            
            \item Vogliamo ottenere una lista dei nomi e delle città dei clienti che hanno ordinato più di 100 pezzi di articoli che costano più di due euro.
            
            \item Prima di tutto, effettuiamo un join naturale tra le tre relazioni:
            
            \[\texttt{CustOrdArt $=$ (Customers $\bowtie$ Orders) $\bowtie$ Articles}\]
            
            \begin{center}
                \begin{tabular}{|c|c|c|c|c|c|c|c|}
                    \hline
                    \multicolumn{8}{|c|}{\textbf{\texttt{CustOrdArt}}}\\
                    \hline
                    \textbf{Name} & \textbf{C\#} & \textbf{Town} & \textbf{O\#} &  \textbf{A\#} & \textbf{Qnty} & \textbf{Label} & \textbf{Price}\\
                    \hline
                    Rossi & C1 & Roma & O1 & A1 & 100 & Plate & 3\\
                    Rossi & C1 & Roma & O1 & A2 & 200 & Glass & 2\\
                    Rossi & C1 & Roma & O1 & A3 & 100 & Mug & 4\\
                    Rossi & C2 & Milano & O2 & A2 & 200 & Glass & 2\\
                    Bianchi & C3 & Roma & O3 & A2 & 150 & Glass & 2\\
                    Verdi & C4 & Roma & O4 & A3 & 200 & Mug & 4\\
                    \hline
                \end{tabular}
            \end{center}
            
            \item Successivamente, selezioniamo le tuple che rispettano le condizioni che ci interessano:
            
             \begin{center}
                \begin{tabular}{|c|c|c|c|c|c|c|c|}
                    \hline
                    \multicolumn{8}{|c|}{\textbf{$\sigma_{\texttt{Qnty}>100 \land \texttt{Price} > 2}(\texttt{CustOrdArt})$}}\\
                    \hline
                    \textbf{Name} & \textbf{C\#} & \textbf{Town} & \textbf{O\#} &  \textbf{A\#} & \textbf{Qnty} & \textbf{Label} & \textbf{Price}\\
                    \hline
                    Verdi & C4 & Roma & O4 & A3 & 200 & Mug & 4\\
                    \hline
                \end{tabular}
            \end{center}
            
            \quad
            
            \item Infine, effettuiamo una proiezione sul nome e la città delle tuple ottenute:
            
            \begin{center}
                \begin{tabular}{|c|c|}
                    \hline
                    \multicolumn{2}{|c|}{\textbf{$\pi_{\texttt{Name, Town}}(\sigma_{\texttt{Qnty}>100 \land \texttt{Price} > 2}(\texttt{CustOrdArt}))$}}\\
                    \hline
                    \textbf{Name} & \textbf{Town}\\
                    \hline
                    Verdi & Roma\\
                    \hline
                \end{tabular}
            \end{center}
        \end{itemize}
        
        \quad
        
        \item \begin{itemize}
            \item Oltre alla soluzione appena vista, possiamo ottenere lo stesso risultato selezionando prima le tuple che rispettano le condizioni e i dati che ci interessano, per poi effettuare il join tra loro, rendendo così la query più efficiente, poiché la mole di dati su cui vengono applicati gli operatori è minore:
            \[ \pi_{\texttt{Name,Town}} ((\texttt{Customer} \bowtie \sigma_{\texttt{Qnty>100}}(\texttt{Order})) \bowtie \sigma_{\texttt{Price>2}} (\pi_{\texttt{A\#,Price}}(\texttt{Article})))\]
            
        \end{itemize}
    \end{enumerate}
    
    \begin{framedprop}{Casi speciali del join naturale}
        Siano $R_1$ e $R_2$ due relazioni con rispettivi schemi $R_1(X)$ e $R_2(Y)$.
        \begin{enumerate}
            \item Se $R_1$ ed $R_2$ hanno un insieme di attributi in comune ma nessun valore in comune per tali attributi, allora il risultato sarà un insieme vuoto:
            \[Z \subseteq X \cap Y, \nexists t_1 \in R_1 \land  t_2 \in R_2 \mid t_1[Z] = t_2[Z] \implies  R_1 \bowtie R_2 =  \emptyset\]
            
            \item Se $R_1$ ed $R_2$ non hanno degli attributi in comune, allora il join naturale degenererà in un prodotto cartesiano:
            \[ X \cap Y = \emptyset \implies R_1 \bowtie R_2 = R_1 \times R_2\]
        \end{enumerate}
    \end{framedprop}
    
    \begin{frameddefn}{Theta Join}
        Siano $R_1$ e $R_2$ due relazioni con rispettive istanze $r_1$ e $r_2$ e rispettivi schemi $R_1(X)$ e $R_2(Y)$. Il \textbf{theta join} tra $R_1$ e $R_2$ è un operatore binario equivalente a:
        
        \[ R_1 \bowtie_{A \theta B} R_2 =\sigma_{A \theta B}(R_1 \times R_2)\]
        
        dove:
        \begin{itemize}
            \item $A \in R_1(X), B \in R_2(Y)$
            \item $dom(A)=dom(B)$
            \item $\theta$ è un operatore di confronto ($<, \leq, =, \geq, >$)
        \end{itemize}
        
        In altre parole, un theta join tra $R_1$ ed $R_2$ restituisce tutte le combinazioni tra le tuple di $r_1$ e $r_2$ che rispettano una condizione su un attributo in comune
    \end{frameddefn}
    
    \begin{framedobs}{}
        In alcuni casi può essere necessario effettuare il\textbf{ join tra una relazione e se stessa} (\textbf{self join}), in modo da ottenere combinazioni di tuple della stessa relazione.
    \end{framedobs}
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Data la seguente relazione, vogliamo ottenere una lista dei codici e dei nomi dei dipendenti aventi un salario maggiore dei loro supervisori
        
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|}
                \hline
                \multicolumn{5}{|c|}{\textbf{Employees}}\\
                \hline
                \textbf{Name} & \textbf{C\#} & \textbf{Section} & \textbf{Salary} & \textbf{Supervisor\#}\\
                \hline
                Rossi & C1 & B & 100 & C3\\
                Pirlo & C2 & A & 200 & C3\\
                Bianchi & C3 & A & 500 & NULL\\
                Verdi & C4 & B & 200 & C2\\
                Neri & C5 & B & 150 & C1\\
                Tosi & C6 & B & 100 & C1\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item In tal caso, la soluzione migliore risulta essere una selezione effettuata su self join di \texttt{Employees}, in modo da poter accoppiare ogni dipendente al suo supervisore. Possiamo ottenere un self join eseguendo una delle seguenti query:
        
        \begin{itemize}
            \item Creiamo una copia della relazione per poi effettuare un theta join tra il codice dei dipendenti e il codice dei loro supervisori, specificando la relazione di appartenenza di ognuno dei due attributi confrontati:
            
            \[ \texttt{EmployeesC} = \texttt{Employees}\]
            \[ \texttt{EmpSup}_1 = \texttt{EmployeesC} \bowtie_{\texttt{EmployeesC.Supervisor\# = Employees.C\#}} \texttt{Employees}\]
            
            \item Effettuiamo un theta join tra la relazione ed una sua copia rinominata, senza dover specificare la relazione di appartenenza degli attributi confrontati:
            
            \[ X = \{ \texttt{Name, C\#, Section, Salary, Supervisor\#} \}\]
            \[ Y = \{ \texttt{CName, CC\#, CSec, CSal, CSup\#} \}\]
            
            \[ \texttt{EmpSup}_2 = \texttt{Employees} \bowtie_{\texttt{Supervisor\# = C\#}} \rho_{X \gets Y}(\texttt{Employees})\]
            
        \end{itemize}
        
        \item \textit{Attenzione:} utilizzare il join naturale al posto del theta join in una delle tre soluzioni genererebbe una relazione identica a \texttt{Employees}, poiché ogni tupla verrebbe joinata con se stessa scartando automaticamente gli attributi doppioni
        
        \item Successivamente, eseguiamo la selezione richiesta, mantenendo solo le tuple dove il salario del dipendente è maggiore del salario del suo supervisore:
        \[ \sigma_{\texttt{Employees.Salary > EmployeesC.Salary}}(\texttt{EmpSup}_\texttt{1})\]
        
        oppure
        \[ \sigma_{\texttt{Salary > CSalary}}(\texttt{EmpSup}_\texttt{2})\]
        
        \end{itemize}
        
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
                \hline
                \multicolumn{10}{|c|}{\textbf{\texttt{$\sigma_{\texttt{Salary > CSal}}(\texttt{EmpSup}_\texttt{2})$}}}\\
                \hline
                \textbf{Name} & \textbf{C\#} & \textbf{Section} & \textbf{Salary} & \textbf{Supervisor\#} &  \textbf{CName} & \textbf{CC\#} & \textbf{CSec} & \textbf{CSal} & \textbf{CSup\#}\\
                \hline
                Verdi & C4 & B & 200 & C2 & Pirlo & C2 & A & 200 & C3\\
                Neri & C5 & B & 150 & C1 & Rossi & C1 & B & 100 & C3\\
                Tosi & C6 & B & 100 & C1 & Rossi & C1 & B & 100 & C3\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
    \begin{itemize}
        \item Infine, effettuiamo una proiezione sul nome e il codice del dipendente:
        \[ \pi_{\texttt{Employees.Name, Employees.C\#}}(\sigma_{\texttt{Employees.Salary > EmployeesC.Salary}}(\texttt{EmpSup}_\texttt{1}))\]
        
        oppure
        \[ \pi_{\texttt{Name, C\#}}(\sigma_{\texttt{Salary > CSal}}(\texttt{EmpSup}_\texttt{2}))\]
        
        \quad
        
        \begin{center}
            \begin{tabular}{|c|c|}
                \hline
                \multicolumn{2}{|c|}{\textbf{\texttt{$\pi_{\texttt{Name, C\#}}(\sigma_{\texttt{Salary > CSal}}(\texttt{EmpSup}_\texttt{2}))$}}}\\
                \hline
                \textbf{Name} & \textbf{C\#}\\
                \hline
                Verdi & C4\\
                Neri & C5\\
                Tosi & C6\\
                \hline
            \end{tabular}
        \end{center}
    \end{itemize}
    
    \newpage
    
    \section{Quantificazione universale}
    
    Fino ad ora, abbiamo visto solo query inerenti la \textbf{quantificazione esistenziale} (indicata col simbolo $\exists$), ossia la selezione di oggetti che soddisfino \textbf{almeno una volta} una determinata condizione.
    
    Tuttavia, utilizzando solo gli operatori visti precedentemente, non abbiamo un modo per poter effettuare query inerenti alla \textbf{quantificazione universale} (indicata col simbolo $\forall$), ossia la selezione di oggetti che soddisfino \textbf{sempre} una determinata condizione.
    
    \begin{framedobs}{}
        Nella logica del primo ordine, la negazione di \textit{"Per ogni oggetto $x$ la condizione $\varphi$ è vera"} non corrisponde a \textit{"Per ogni oggetto $x$ la condizione $\varphi$ è falsa"}, bensì corrisponde a \textit{"Esiste almeno un oggetto $x$ per cui la condizione $\varphi$ è falsa"}.
        
        In simboli, diremmo che:
        \[ \lnot(\forall x, \varphi(x)) \neq \forall x, \lnot \varphi(x)\]
        
        ma bensì:
        
        \[ \lnot(\forall x, \varphi(x)) = \exists x, \lnot \varphi(x)\]
        
        Per selezionare tutte le tuple di una relazione per cui una determinata condizione $\varphi$ è sempre valida, quindi, ci basta scartare tutte le tuple per cui almeno una volta la condizione non è valida.
    \end{framedobs}
    
    \textbf{Esempi:}
    
    \begin{enumerate}
        \item \begin{itemize}
            \item Data la seguente relazione, vogliamo ottenere un elenco di tutti i nomi e la città di provenienza dei clienti che hanno sempre effettuato un ordine di più di 100 pezzi.
            
            \begin{center}
                \begin{tabular}{ccc}
                    \begin{tabular}{|c|c|c|}
                        \hline
                        \multicolumn{3}{|c|}{\textbf{Customers}}\\
                        \hline
                        \textbf{Name} & \textbf{C\#} & \textbf{Town}\\
                        \hline
                        Rossi & C1 & Roma\\
                        Rossi & C2 & Milano\\
                        Bianchi & C3 & Roma\\
                        Verdi & C4 & Roma\\
                        \hline
                    \end{tabular}

                    &\qquad&

                    \begin{tabular}{|c|c|c|c|}
                        \hline
                        \multicolumn{4}{|c|}{\textbf{Orders}}\\
                        \hline
                        \textbf{O\#} & \textbf{C\#} & \textbf{A\#} & \textbf{Qnty}\\
                        \hline
                        O1 & C1 & A1 & 100\\
                        O2 & C2 & A2 & 200\\
                        O3 & C3 & A2 & 150\\
                        O4 & C4 & A3 & 200\\
                        O1 & C1 & A2 & 200\\
                        O1 & C1 & A3 & 100\\
                        \hline
                    \end{tabular}
                \end{tabular}
            \end{center}
                
            \quad

            \item Per ottenere l'elenco richiesto, ci basta scartare l'elenco dei nomi e delle città che almeno una volta non hanno acquistato più di 100 pezzi dall'elenco totale dei nomi e delle città:
            
            \[ \texttt{ElencoNonValidi} = \pi_{\texttt{Name, Town}}(\sigma_{\lnot(\texttt{Qnty} > 100)}(\texttt{Customers} \bowtie \texttt{Orders}))\]
            \[ R = \pi_{\texttt{Name, Town}}(\texttt{Customers}) - \texttt{ElencoNonValidi}\]
            
            oppure, direttamente:
            \[ R = \pi_{\texttt{Name, Town}}(\texttt{Customers}) - \pi_{\texttt{Name, Town}}(\sigma_{\lnot(\texttt{Qnty} > 100)}(\texttt{Customers} \bowtie \texttt{Orders}))\]
            
            
            \begin{center}
                \begin{tabular}{|c|c|}
                    \hline
                    \multicolumn{2}{|c|}{\textbf{R}}\\
                    \hline
                    \textbf{Name} & \textbf{Town}\\
                    \hline
                    Bianchi & Roma\\
                    Verdi & Roma\\
                    \hline
                \end{tabular}
            \end{center}
        \end{itemize}
        
        \quad
        
        \item
        \begin{itemize}
            \item Data la seguente relazione, vogliamo ottenere una lista dei codici e dei nomi dei supervisori aventi un salario maggiore di tutti i loro dipendenti
            
            \begin{center}
                \begin{tabular}{|c|c|c|c|c|}
                    \hline
                    \multicolumn{5}{|c|}{\textbf{Employees}}\\
                    \hline
                    \textbf{Name} & \textbf{C\#} & \textbf{Section} & \textbf{Salary} & \textbf{Supervisor\#}\\
                    \hline
                    Rossi & C1 & B & 100 & C3\\
                    Pirlo & C2 & A & 200 & C3\\
                    Bianchi & C3 & A & 500 & NULL\\
                    Verdi & C4 & B & 200 & C2\\
                    Neri & C5 & B & 150 & C1\\
                    Tosi & C6 & B & 100 & C1\\
                    \hline
                \end{tabular}
            \end{center}
            
            \quad
            
            \item Anche in questo caso, per ottenere l'elenco richiesto ci basta scartare i supervisori aventi il salario minore di almeno un dipendente:
            
            \[ \texttt{EmployeesC} = \texttt{Employees}\]
            \[ \texttt{EmpSup} = \texttt{EmployeesC} \bowtie_{\texttt{EmployeesC.Supervisor\# = Employees.C\#}} \texttt{Employees}\]
            \[  \texttt{Invalid} = \pi_{\texttt{Name, C\#}}(\sigma_{\lnot(\texttt{Employees.Salary < EmployeesC.Salary} )}(\texttt{EmpSup}))\]

            \[ R = \pi_{\texttt{Name, C\#}}(\texttt{EmpSup}) - \texttt{Invalid}\]
            
            \quad

            \begin{center}
                \begin{tabular}{|c|c|}
                    \hline
                    \multicolumn{2}{|c|}{\textbf{R}}\\
                    \hline
                    \textbf{Name} & \textbf{C\#}\\
                    \hline
                    Bianchi & C3\\
                    \hline
                \end{tabular}
            \end{center}
        \end{itemize}
    \end{enumerate}
    
    \chapter{Teoria della normalizzazione}
    
    \section{Dipendenze funzionali}
    
    \begin{frameddefn}{Dipendenza funzionale}
        Sia $R$ uno schema con istanza $r$ e siano $X,Y \subseteq R$.
        
        Definiamo come \textbf{dipendenza funzionale} tra $X$ e $Y$, indicata come $X \to Y$ e letta "$X$ determina $Y$", un vincolo di integrità che impone ad ogni coppia di tuple in $r$ aventi valori uguali su $X$ di avere valori uguali anche su $Y$:
        \[ \forall t_1, t_2 \in r, t_1[X] = t_2[X] \implies t_1[Y] = t_2[Y]\]
        
        \textit{Attenzione:} notiamo come nella condizione non vi sia un \textit{"se e solo se"}, bensì solo un \textit{"se"}. Dunque, $X \to Y$ non implica che ogni coppia di tuple in $r$ aventi valori uguali su $Y$ debba avere valori uguali anche su $X$.
    \end{frameddefn}
    
    \textbf{Esempi:}
    
    \begin{enumerate}
        \item 
        \begin{itemize}
            \item Supponiamo di avere il seguente schema $\texttt{Flights(Code, Day, Pilot, Time)}$. Viene naturale considerare i seguenti vincoli:
            \begin{itemize}
                \item Un volo con un certo codice partirà sempre allo stesso orario
                \item C'è un solo volo con un certo pilota ad un certo orario in un certo giorno
                \item C'è un solo pilota di un certo volo in un certo giorno
            \end{itemize}
            
            \item Dunque, imponiamo le seguenti dipendenze funzionali sullo schema:
            \begin{itemize}
                \item \texttt{Code} $\to$ \texttt{Time}
                \item \texttt{(Day, Pilot, Time)} $\to$ \texttt{Code}
                \item \texttt{(Code, Day)} $\to$ \texttt{Pilot}
            \end{itemize}
        \end{itemize}
    \end{enumerate}
    
    \begin{frameddefn}{Istanza legale}
        Dato uno schema $R$ e un insieme $F$ di dipendenze funzionali definite su $R$, diciamo che un'istanza di $R$ è \textbf{legale su $\textbf{F}$} se soddisfa tutte le dipendenze funzionali in $F$
    \end{frameddefn}
    
    
    \textbf{Esempi:}
    
    \begin{enumerate}
        \item 
        \begin{itemize}
            \item Consideriamo la seguente relazione su cui sono definite le seguenti dipendenze funzionali:
            \[ F = \{ A \to B\}\]
            
            \begin{center}
                \begin{tabular}{|c|c|c|c|}
                    \hline
                    \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D}\\
                    \hline
                    $a_1$ & $b_1$ & $c_1$ & $d_1$\\
                    $a_1$ & $b_1$ & $c_2$ & $d_2$\\
                    $a_2$ & $b_2$ & $c_1$ & $d_3$\\
                    \hline
                \end{tabular}
            \end{center}
            
            \quad
            
            \item Tale istanza è legale su $F$, poiché soddisfa le dipendenze funzionali in $F$: tutte le tuple aventi $t[A] = a_1$ hanno anche $t[B] = b_1$, così come tutte le tuple (nonostante sia solo una in questo caso) aventi $t[A] = a_2$ hanno anche $t[B] = b_2$
            
        \end{itemize}
        
        \begin{itemize}
            \item Consideriamo la seguente situazione:
            \[ F = \{ A \to B\}\]
            
            \begin{center}
                \begin{tabular}{|c|c|c|c|}
                    \hline
                    \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D}\\
                    \hline
                    $a_1$ & $b_1$ & $c_1$ & $d_1$\\
                    $a_2$ & $b_1$ & $c_2$ & $d_2$\\
                    $a_2$ & $b_2$ & $c_1$ & $d_3$\\
                    \hline
                \end{tabular}
            \end{center}
            
            \quad
            
            \item Tale istanza è illegale su $F$, poiché non soddisfa le dipendenze funzionali in $F$: la seconda e la terza tupla hanno lo stesso valore in $A$ ma non in $B$
        \end{itemize}
    \end{enumerate}
    
    \quad
    
    \subsection{Chiusura di F}
    
    \begin{frameddefn}{Chiusura di F}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Definiamo come \textbf{chiusura di $\textbf{F}$}, indicata con $F^+$, l'insieme di \textbf{tutte} le dipendenze funzionali, incluse quelle non in $F$, soddisfatte da \textbf{ogni istanza} di $R$ legale su $F$.
        
        \[ F^+ = \bigcap_{r \in L} \{ f \text{ dipendenza funzionale} \mid r \text{ soddisfa } f\} \]
        
        dove $L =\{ r \text{ istanza di } R \mid r \text{ legale su } F\}$. In generale, quindi, si ha che $F \subseteq F^+$.
    \end{frameddefn}
    
    \textbf{Esempio:}
    \begin{itemize}
        \item Consideriamo la seguente relazione su cui sono definite le seguenti dipendenze funzionali:
        \[ F = \{ A \to B, B \to C\}\]
        
        \begin{center}
            \begin{tabular}{|c|c|c|c|}
                \hline
                \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D}\\
                \hline
                $a_1$ & $b_1$ & $c_1$ & $d_1$\\
                $a_1$ & $b_1$ & $c_1$ & $d_2$\\
                $a_2$ & $b_2$ & $c_1$ & $d_3$\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Tale istanza è legale su $F$, poiché soddisfa tutte le dipendenze funzionali in $F$. Inoltre, è soddisfatta anche la dipendenza funzionale $A \to C$, che tuttavia non è in $F$. Dunque, si ha che $A \to B, B \to C, A \to C \in F^+$
    \end{itemize}
    
    \begin{framedobs}{}
        Dato uno schema $R$ e un insieme $F$ di dipendenze funzionali definite su $R$, si ha che:
        \[ Y \subseteq X \subseteq R \implies X \to Y \in F^+\]
        
        Tali dipendenze funzionali vengono dette \textbf{banali}, poiché soddisfatte da ogni istanza di $R$.
    \end{framedobs}
    
    \begin{framedprop}{}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Dati $X,Y \subseteq R$, si ha che:
        \[ X \to Y \in F^+ \iff \forall A \in Y, X \to A \in F^+\]
    \end{framedprop}
    
    \textit{Dimostrazione:}
    
    \begin{itemize}
        \item Siano $X, Y\subseteq R$, dove $Y = \{A_1, \ldots, A_k\}$ .
        \item Data $r$ una qualsiasi istanza di $R$, si ha che:
            \[ \forall A_i \in Y, X \to A \in F^+ \iff \left \{ \begin{array}{l}
                \forall t_1, t_2 \in r, t_1[X]=t_2[X] \implies t_1[A_1]=t_2[A_1]\\
                \vdots\\
                \forall t_1, t_2 \in r, t_1[X]=t_2[X] \implies t_1[A_k]=t_2[A_k]\\
            \end{array}\right . \iff \]
            \[\iff \forall t_1, t_2 \in r, t_1[X]=t_2[X] \implies t_1[\{A_1, \ldots, A_k\}]=t_2[\{A_1, \ldots, A_k\}]\]
            \[ \iff \forall t_1, t_2 \in r, t_1[X]=t_2[X] \implies t_1[Y]=t_2[Y] \iff X \to Y \in F^+\]

            $\hfill\qed$
    \end{itemize}
    
    \newpage

    \textbf{Esempio:}
    \begin{itemize}
        \item Consideriamo la seguente istanza di uno schema $R = \{A,B,C\}$:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                \textbf{A} & \textbf{B} & \textbf{C}\\
                \hline
                $a_1$ & $b_1$ & $c_1$ \\
                $a_1$ & $b_1$ & $c_1$ \\
                $a_2$ & $b_2$ & $c_1$ \\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Dato $F$ un insieme di dipendenze funzionali definite su $R$, notiamo facilmente, che tutte le tuple di tale istanza soddisfano la dipendenza $ABC \to ABC \in F^+$.
        
        \item Notiamo inoltre che tutte le tuple di tale istanza in cui $A$ e $B$ sono uguali anche $A$ è uguale, dunque $AB \to A \in F^+$.
    
        \item Procedendo analogamente, in definitiva si ha che:
        \[ \left . \begin{array}{l}
            ABC \to ABC, ABC \to AB, ABC \to AC, ABC \to BC, \\
            ABC \to A, ABC \to B, ABC \to C, AB \to AB, AB \to A,  \\
            AC \to A, AC \to C, BC \to A, BC \to C, A \to A, B \to B, C \to C
        \end{array}\right \} \in F^+\]
    \end{itemize}
    
    \quad
    
    \section{Assiomi di Armstrong}
    
    \quad
    
    \begin{frameddefn}{Assiomi di Armstrong}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Definiamo come $F^A$ l'insieme di tutte le dipendenze funzionali ottenibili partendo da $F$ applicando i seguenti \textbf{assiomi di Armstrong}:
        \begin{itemize}
            \item \textbf{Inclusione iniziale} ($F \subseteq F^A$):
            \[ X \to Y \in F \implies X \to Y \in F^A\]
            \item \textbf{Assioma di riflessività}:
            \[ Y \subseteq X \subseteq R \implies X \to Y \in F^A\]
            \item \textbf{Assioma di aumento:}
            \[ Z \subseteq R, X \to Y \in F^A \implies XZ \to YZ \in F^A\]
            \item \textbf{Assioma di transitività:}
            \[  X \to Y \in F^A \land Y \to Z \in F^A \implies X \to Z \in F^A\]
        \end{itemize}
    \end{frameddefn}
    
    \begin{framedprop}{Regole secondarie di Armstrong}
         Dato uno schema $R$ e un insieme $F$ di dipendenze funzionali definite su $R$, tramite gli assiomi di Armstrong è possibile ricavare le seguenti regole aggiuntive:
         \begin{itemize}
             \item \textbf{Regola dell'unione}:
             \[ X \to Y \in F^A \land X \to Z \in F^A \implies X \to YZ \in F^A\]
             \item \textbf{Regola della decomposizione}:
             \[Z \subseteq Y, X \to Y \in F^A \implies X \to Z \in F^A\]
             \item \textbf{Regola della pseudo-transitività}:
             \[ X \to Y \in F^A \land WY \to Z \in F^A \implies WX \to Z \in F^A\]
         \end{itemize}
    \end{framedprop}
    
    \textit{Dimostrazione:}
    \begin{itemize}
        \item \textbf{Regola dell'unione}:
        
        \begin{itemize}
            \item Siano $X \to Y, X \to Z \in F^A$.
            
            \item Per assioma di aumento, si ha che:
            \[ X \subseteq R, X \to Y \in F^A \implies XX \to XY = X \to XY \in F^A \]
            
            \item Analogamente, si ha che:
            \[ Y \subseteq R, X \to Z \in F^A \implies XY \to ZY = XY \to YZ\in F^A \]
            
            \item Infine, per assioma di transitività si ha che:
            \[ X \to XY \in F^A \land XY \to YZ \in F^A \implies X \to YZ \in F^A\]
        \end{itemize}
        
        \item \textbf{Regola della decomposizione:}
        
        \begin{itemize}
            \item Sia $Z \subseteq Y \subseteq R$ e sia $X \to Y \in F^A$.
            \item Per assioma di riflessività, si ha che:
            \[ Z \subseteq Y \subseteq R \implies Y \to Z \in F^A\]
            
            \item Infine, per assioma di transitività si ha che:
            \[ X \to Y \in F^A \land Y \to Z \in F^A \implies X \to Z \in F^A\]
        \end{itemize}
        
        \newpage
        
        \item \textbf{Regola della pseudo-transitività:}
        
        \begin{itemize}
            \item Sia $X \to Y, YW \to Z \in F^A$.
            \item Per assioma di aumento, si ha che:
            \[ W \subseteq R, X \to Y \in F^A \implies XW \to YW \in F^A\]
            \item Infine, per assioma di transitività si ha che:
            \[ XW \to YW \in F^A \land YW \to Z \in F^A \implies XW \to Z \in F^A\]
        \end{itemize}

        $\hfill\qed$

    \end{itemize}
    
    \begin{framedprop}{}
        Dato uno schema $R$ e un insieme $F$ di dipendenze funzionali definite su $R$, si ha che:
        \[X \to Y \in F^A \iff \forall A \in Y, X \to A \in F^A\]
    \end{framedprop}
    
    \textit{Dimostrazione:}
    \begin{itemize}
        \item Siano $X,Y \subseteq R$, dove $Y = \{A_1, \ldots, A_k\}$.
        \item Per la regola dell'unione, si ha che:
        \[ \forall A_i \in Y, X \to A \in F^A \implies X \to \{A_1, \ldots, A_k\} = Y \in F^A\]
        
        \item Per la regola della decomposizione, invece si ha che:
        \[ X \to Y \in F^A \implies \forall A \in Y, X \to A \in F^A\]

        $\hfill\qed$
    \end{itemize}
    
    \quad
    
    \subsection{Chiusura di X}
    
    \quad
    
    \begin{frameddefn}{Chiusura di un insieme di attributi}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Dato $X \subseteq R$, definiamo come \textbf{chiusura di X rispetto a F}, indicata con $X_F^+$ (o solo $X^+$ se $F$ è l'unico insieme di dipendenze su $R$), il seguente insieme:
        \[ X_F^+ = \{ A \in R \mid X \to A \in F^A\}\]
        dove $A \in R$ implica che $A$ sia un singolo attributo di $R$
    \end{frameddefn}
    
    \begin{framedlem}{}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Dato $X,Y \subseteq R$, si ha che:
        \[ X \to Y \in F^A \iff Y \subseteq X^+\]
        
    \end{framedlem}
    
    \textit{Dimostrazione:}
    
    \begin{itemize}
        \item Dato $Y = \{A_1, \ldots, A_k\}$, si ha che:
        \[ X \to Y \in F^A \iff X \to A \in F^A, \forall A \in Y \iff A \in X^+, \forall A \in Y \iff Y  \subseteq X^+\]

        $\hfill\qed$

    \end{itemize}
    
    \begin{framedcor}{}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Dato $X\subseteq R$, si ha che $X \to X \in F^A$. Dunque, ne segue che:
        \[ X \to X \in F^A \iff X \subseteq X^+\]
        
        In altre parole, ogni insieme di attributi è un elemento della sua chiusura.
    \end{framedcor}
    
    \quad
    
    \subsection{$F^+ = F^A$}
    
    \quad
    
    \begin{framedthm}{$\textbf{F}^{\textbf{+}}\textbf{= F}^{\textbf{A}}$}
        Dato uno schema $R$ e un insieme $F$ di dipendenze funzionali definite su $R$, si ha che:
        \[ F^+ = F^A\]
    \end{framedthm}
    
    \textit{Dimostrazione:}
    \begin{itemize}
        \item Dimostriamo che $F^A \subseteq F^+$:
        
            \begin{itemize}
            
            \item \textbf{Caso base $(n = 0)$}: se $X \to Y \in F^A$ senza aver applicato alcun assioma di Armstrong, allora l'unica possibilità è che:  
            \[ X \to Y \in F^A \iff X \to Y \in F\]
            Siccome $X \to Y \in F$, allora
            \[ X \to Y \in F \implies X \to Y \in F^+\]
            
            \item \textbf{Ipotesi induttiva forte}: ogni dipendenza funzionale in $F^A$ ottenuta da $F$ applicando $k \leq n$ assiomi di Armstrong è anche in $F^+$
            \[ X \to Y \in F^A \text{ tramite } k \leq n \text{ assiomi} \implies X \to Y \in F^+ \]
            
            \item \textbf{Passo induttivo $(n>0)$}: è necessario dimostrare che se $X \to Y \in F^A$ dopo aver applicato $n+1$ assiomi di Armstrong, allora $X \to Y \in F^+$.
            
            È possibile ritrovarsi in uno dei seguenti tre casi:
            \begin{enumerate}
                \item Se l'$(n+1)$-esimo assioma applicato è l'assioma di riflessività, allora l'unica possibilità è che $X \to Y \in F^A \iff Y \subseteq X \subseteq R$.
                
                Dunque, poiché, $Y \subseteq X \subseteq R$, per ogni istanza legale di $R$ si ha che:
                \[ \forall t_1, t_2 \in r, t_1[X] = t_2[X] \implies t_1[Y] = t_2[Y] \]
                
                da cui ne segue automaticamente che $X \to Y \in F^+$:
                
                \item Se l'$(n+1)$-esimo assioma applicato è l'assioma di aumento, allora è obbligatoriamente necessario che:
                
                \begin{itemize}
                    \item $\exists V, W \subseteq R \mid \exists V \to W \in F^A$, ottenuta applicando $j \leq n$ assiomi di Armstrong
                    \item $\exists Z \subseteq R \mid X := VZ, Y := WZ$
                \end{itemize}
                
                affinché si abbia che:
                \[ Z \subseteq R, V \to W \implies VZ \to WZ = X \to Y \in F^A\]
                
                Siccome per ipotesi induttiva si ha $V \to W \in F^A \implies V \to W \in F^+$ e siccome $Z \subseteq Z \implies Z \to Z \in F^+$, si vede facilmente che:
                \[ \left \{ \begin{array}{l}
                    V \to W \in F^+\\
                    Z \to Z \in F^+
                \end{array}\right . \implies
                \left \{ \begin{array}{l}
                    \forall t_1,t_2 \in r, t_1[V]=t_2[V] \implies t_1[W]=t_2[W]\\
                    \forall t_1,t_2 \in r, t_1[Z]=t_2[Z] \implies t_1[Z]=t_2[Z]
                \end{array}\right . \implies\]
                \[\implies \forall t_1,t_2 \in r, t_1[VZ]=t_2[VZ] \implies t_1[WZ]=t_2[WZ] \implies\]
                \[\implies \forall t_1,t_2 \in r, t_1[X]=t_2[X] \implies t_1[Y]=t_2[Y] \implies X \to Y \in F^+\]
                
                \item Se l'$(n+1)$-esimo assioma applicato è l'assioma di transitività, allora è obbligatoriamente necessario che $\exists X \to Z, Z \to Y \in F^A$, ottenute con  $k \leq n$ assiomi di Armstrong, affinché si abbia che:
                \[ X \to Z \in F^A \land  Z \to Y \in F^A \implies X \to Y \in F^A\]
                
                Siccome per ipotesi induttiva $X \to Z \in F^A \implies X \to Z \in F^+$ e $Z \to Y \in F^A \implies Z \to Y \in F^+$, si vede facilmente che:
                \[ \left \{ \begin{array}{l}
                    X \to Z \in F^+\\
                    Z \to Y \in F^+
                \end{array}\right . \implies \forall t_1, t_2 \in r, t_1[X]=t_2[X]\]
                \[ \implies t_1[Z]=t_2[Z] \implies t_1[Y]=t_2[Y] \implies  X \to Y \in F^+\]
            \end{enumerate}
            
        \end{itemize}
        
        \item Dimostriamo che $F^+ \subseteq F^A$:
            
            \begin{itemize}
                \item Sia $X \subseteq R$ e sia $r$ istanza di $R(X^+, R-X^+)$ tale che
                
                \begin{center}
                    \begin{tabular}{|c|c|c|c|c|c|}
                        \hline
                        \multicolumn{3}{|c|}{\textbf{$X^+$}}
                        & \multicolumn{3}{|c|}{\textbf{$R-X^+$}}\\
                        \hline
                        \textbf{$A_1$} & \textbf{$\cdots$} & \textbf{$A_i$} & \textbf{$A_j$} & \textbf{$\cdots$} & \textbf{$A_n$} \\
                        \hline
                        1 & \ldots & 1 & 1 & \ldots & 1\\
                        1 & \ldots & 1 & 0 & \ldots & 0\\
                        \hline
                    \end{tabular}
                \end{center}
                
                dunque tale che $\forall t_1, t_2 \in r$ si ha:
                \begin{itemize}
                    \item $t_1[X^+]= (1, \ldots, 1) = t_2[X^+]$
                    \item $t_1[R-X^+]= (1, \ldots, 1)  \neq (0, \ldots, 0) = t_2[R-X^+]$
                \end{itemize} 
                
                \item Notiamo che $\forall V,W \subseteq R \mid V \to W \in F$ si ha che:
                \begin{itemize}
                    \item Se $V \cap R-X^+ \neq \emptyset$  (dunque anche se $V \subseteq R-X^+$) allora $t_1[V] \neq t_2[V]$, dunque $r$ soddisfa $V \to W \in F$
                    \item Se invece $V \subseteq X^+$, per il lemma precedentemente visto si ha che
                    \[ V \subseteq X^+ \iff X \to V \in F^A\]
                    Siccome $V \to W \in F \implies V \to W \in  F^A$, per transitività si ha che
                    \[ X \to V \in F^A \land V \to W \in F^A \implies X \to W \in F^A \iff W \subseteq X^+ \]
                    
                    Dunque, siccome $V,W \subseteq X^+$, in definitiva si ha che
                    \[t_1, t_2 \in r, t_1[V]=(1,\ldots,1) = t_2[V] \land t_1[W]=(1,\ldots,1) = t_2[W]\]
                    
                    e quindi $r$ soddisfa ogni $V \to W \in F$
                \end{itemize}

                
                \item Siccome in entrambi i casi $r$ soddisfa ogni $V \to W \in F$, allora $r$ è legale.
                \item A questo punto, una qualsiasi dipendenza $X \to Y \in F^+$ deve essere soddisfatta da qualsiasi istanza legale di $R$, inclusa $r$ stessa
                \item Poiché $X \subseteq X^+$, ne segue che la dipendenza non può essere soddisfatta a vuoto poiché $t_1[X] = t_2[X]$. Dunque, l'unica possibilità affinché $X \to A \in F^+$ sia soddisfatta da $r$ è che $Y \subseteq X^+$ in modo che si abbia $t_1[Y] = t_2[Y]$
                \item A questo punto, per il lemma si ha che $Y \subseteq X^+ \iff X \to Y \in F^A$
                \item Dunque, siccome $X \to Y \in F^+ \implies X \to Y \in F^A$, concludiamo che $F^+ \subseteq F^A$
            \end{itemize}

            $\hfill\qed$
    \end{itemize}
    
    \quad
    
    \begin{framedobs}{}
        Poiché $F^+ = F^A$, per \textbf{calcolare} $F^+$ ci basta applicare gli assiomi di Armstrong sulle dipendenze in $F$ in modo da trovare $F^A$.
        
        Tuttavia, calcolare $F^+ = F^A$ richiede \textbf{tempo esponenziale}, quindi $\Omega(2^{\abs{R}})$: considerando anche solo l'assioma di riflessività, siccome ogni possibile sottoinsieme di $R$ genera una dipendenza e siccome i sottoinsiemi possibili di $R$ sono $2^{\abs{R}}$, allora ne segue che $\abs{F^+} >> 2^{\abs{R}}$
    \end{framedobs}
    
    \quad
    
    \section{Terza Forma Normale (3NF)}
    
    \quad
    
    A questo punto, possiamo sfruttare la definizione di dipendenza funzionale per dare una definizione più rigorosa di chiave:
    \begin{frameddefn}{Chiave e Primo}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Definiamo il sottoinsieme di attributi $K \subseteq R$ come \textbf{chiave} di $R$ se:
        \begin{itemize}
            \item $K \to R \in F^+$
            \item $\nexists K' \subset K \mid K' \to R \in F^+$
        \end{itemize}
        
        Se $K$ è una chiave di $R$, ogni attributo $A \in K$ viene detto \textbf{primo}.
    \end{frameddefn}

    \textbf{Esempio:}
    \begin{itemize}
        \item Consideriamo lo schema \texttt{Student(Matr, LastName, FirstName, BirthD)}
        
        \item In questo caso, è ovvio imporre la seguente dipendenza funzionale in $F$:
        \[ \texttt{Matr} \to \{\texttt{LastName, FirstName, BirthD}\}\in F \subseteq F^+\]
        poiché ogni tupla avente matricola uguale deve anche avere informazioni uguali.
        
        \item Siccome $\texttt{Matr} \subseteq \texttt{Matr}^+ \iff \texttt{Matr} \to \texttt{Matr} \in F^+ = F^A$, per unione si ha che:
        \[ \texttt{Matr} \to \{\texttt{Matr, LastName, FirstName, BirthD}\} \in F^+ = F^A\]
        
        dunque \texttt{Matr} è superchiave di \texttt{Student} poiché determina tutto il suo schema
        \item Siccome non esiste alcun sottoinsieme di \texttt{Matr}, allora possiamo concludere che \texttt{Matr} sia chiave di \texttt{Student}
    \end{itemize}
    
    \quad
    
    \begin{frameddefn}{Superchiave}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Definiamo il sottoinsieme di attributi $K \subseteq R$ come \textbf{superchiave} di $R$ se:
        \begin{itemize}
            \item $K \to R \in F^+$
            \item $\exists K' \subseteq K \mid K' \to R \in F^+ \land \nexists K'' \subset K' \mid K'' \to R \in F^+$  (ossia contiene una chiave)
        \end{itemize}
    \end{frameddefn}
    
    \begin{framedobs}{}
        
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Se $X \subseteq R$ è chiave di $R$, allora essa è anche superchiave, poiché $\exists X \subseteq X$ tale che  $X \text{ chiave di } R$
        \[ X \text{ chiave di } R \implies X \text{ superchiave di } R\]
    \end{framedobs}
    
    \begin{frameddefn}{Terza Forma Normale (3NF)}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Lo schema $R$ viene detto in \textbf{terza forma normale (3NF)} se:
        \[ \forall X \to A \in F^+, A \in R - X,  \exists K \subseteq R \text{ chiave } \mid K \subseteq X \lor A \in K\]
        
        In altre parole, uno schema viene detto in terza forma normale se per ogni dipendenza funzionale \textbf{non banale} $X \to A \in F^+$, il determinante $X$ è superchiave o il determinato $A$ è primo.
        
        Se uno schema è in 3NF, la quantità di \textbf{anomalie} e di \textbf{ridondanze} dei dati (sezione \ref{anomalie}) è \textbf{estremamente ridotta}.
    \end{frameddefn}
    
    \textbf{Esempio:}
    
    \begin{enumerate}
        \item \begin{itemize}
            \item Sia $R=ABCD$ uno schema e sia $F = \{ A \to B, B \to CD\}$ un insieme di dipendenze funzionali su $R$
            \item Applicando gli assiomi di Armstrong, si ha che:
            \begin{itemize}
                \item Per riflessività:
                \[ A \subseteq A \implies A \to A \in F^A\]
                \item Per transitività:
                \[ A \to B, B \to CD \in F^A \implies A \to CD \in F^A\]
                \item Per unione:
                \[ A \to A, A \to B, A \to CD \in F^A \implies A \to ABCD = R \in F^A\]
            \end{itemize}
            
            \item Dunque, siccome $A \to R \in F^A = F^+$ e siccome $A$ non ha sottoinsiemi, allora $A$ è chiave di $R$ (in particolare, $A$ è l'unica chiave di $R$)
            
            \item Verifichiamo quindi se $R$ sia in 3NF: 
            \begin{itemize}
                \item $A \to B \in F^+$ rispetta la definizione di 3NF, poiché il determinante $A$ è chiave (e quindi anche una superchiave di se stessa)
                \item $B \to CD \in F^+$ non è una dipendenza da controllare, poiché $CD$ sono un sottoinsieme di attributi e non un singolo attributo
                \item Tuttavia, per decomposizione abbiamo che $B \to CD \in F^A=F^+ \implies B \to C, B \to D \in F^A=F^+$
                \item Per entrambe si ha che $B$ non è superchiave, poiché $A \not\subseteq B$, mentre $C$ e $D$ non sono primi, poiché $C,D \notin A$, dunque concludiamo che $R$ non sia in 3NF
            \end{itemize}
        \end{itemize}
        
        \item \begin{itemize}
            \item Sia $R=ABCD$ e sia $F = \{ AC \to B, B \to AD\}$ un insieme di dipendenze funzionali su $R$.
            \item Applicando gli assiomi di Armstrong, si ha che:
            \begin{itemize}
                \item Per riflessività:
                \[A,C, AC \subseteq AC \implies AC \to A, AC \to C, AC \to AC \in F^A\]
                \[B,C, BC \subseteq BC \implies BC \to B, BC \to C, BC \to BC \in F^A\]
                \item Per transitività:
                \[ AC \to B, B \to AD \in F^A \implies AC \to AD \in F^A\]
                \[BC \to B, B \to AD \in F^A \implies BC \to AD \in F^A\]
                \item Per unione:
                \[ AC \to C, AC \to B, AC \to AD \in F^A \implies AC \to ABCD = R \in F^A\]
                \[ BC \to B, BC \to C, BC \to AD \in F^A \implies BC \to ABCD \in F^A\]
                \item Per aumento:
                \[ AC \to ABCD = R \in F^A \implies ABC \to ABBCD = ABCD = R \in F^A\]
            \end{itemize}
            
            \item Deduciamo quindi che $AC$ e $BC$ siano chiave di $R$, mentre $ABC$ è una superchiave di $R$
            \item Verifichiamo quindi se $R$ sia in 3NF:
            \begin{itemize}
                \item $AC \to B \in F^A = F^+$ rispetta la definizione di 3NF, poiché $AC$ è chiave
                \item $B \to AD \in F^A = F^+$ non va controllato, ma per decomposizione si ha che $B \to A, B \to D \in F^A=F^+$
                \item $B \to A \in F^+$ rispetta la definizione di 3NF, poiché $A \in AC$ e dunque primo, mentre $B \to D \in F^+$ non rispetta la definizione di 3NF, poiché né B è superchiave né D è primo, dunque concludiamo che $R$ non sia in 3NF
            \end{itemize}
        \end{itemize}
        
        \item \begin{itemize}
        \item Sia $R=ABCD$ uno schema e sia $F = \{ AB\to CD, BC \to A, D \to AC\}$ un insieme di dipendenze funzionali su $R$
        \item In tal caso si ha che $AB, BC$ e $BD$ sono chiavi di $R$
        
        \item Verifichiamo quindi se $R$ sia in 3NF: 
        \begin{itemize}
            \item $AB \to CD \in F^+$ rispetta la definizione di 3NF, poiché $AB$ è chiave
            \item $BC \to A \in F^+$ rispetta la definizione di 3NF, poiché $BC$ è chiave e $A$ è primo
            \item $D \to AC \in F^+ \implies D \to A, D \to C \in F^+$, i quali rispettano entrambi la definizione di 3NF, poiché $A$ e $C$ sono entrambi primi
            \item Dunque, concludiamo che $R$ sia in 3NF
        \end{itemize}
        
    \end{itemize}
    \end{enumerate}
    
    \quad
    
    \begin{frameddefn}{Dipendenza parziale}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Definiamo $X \to A \in F^+$, dove $A \notin X$, come \textbf{dipendenza parziale} su $R$ se:
        \begin{itemize}
            \item $A$ non è primo
            \item $\exists K \subseteq R$ chiave di $R$ tale che $X \subset K$ (quindi in particolare $X \neq K$)
        \end{itemize}
    \end{frameddefn}
    
    \begin{frameddefn}{Dipendenza transitiva}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Definiamo $X \to A \in F^+$, dove $A \notin X$, come \textbf{dipendenza transitiva} su $R$ se:
        \begin{itemize}
            \item $A$ non è primo
            \item $\forall K \subseteq R$ chiave di $R$ si ha che $X \not\subset K$ e $K - X \neq \emptyset$
        \end{itemize}
    \end{frameddefn}
    
    \begin{framedcor}{Definizione alternativa di 3NF}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Lo schema $R$ viene detto in \textbf{terza forma normale (3NF)} se non esistono dipendenze parziali o transitive in $F$.
        
        \[ \nexists X \to Y \in F \mid X \to Y \text{ dip. parziale o transitiva}\]
    \end{framedcor}
    
    \begin{frameddefn}{Forma Normale di Boyce-Codd}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Lo schema $R$ viene detto in \textbf{forma normale di Boyce-Codd (BCNF)} se
        \[\forall X \to Y \in F \implies X \text{ superchiave}\]
        
    \end{frameddefn}
    
    \begin{framedobs}{}
        Uno schema in BCNF è anche uno schema in 3NF, poiché la BCNF è una versione \textbf{più restrittiva} della 3NF.
        
        Non è sempre possibile decomporre uno schema in BCNF in più sottoschemi in BCNF preservando tutte le dipendenze. Tuttavia, ciò non vale per uno schema in 3NF, il quale, invece, è sempre decomponibile in più sottoschemi in 3NF preservando tutte le dipendenze.

        Dunque, si preferisce l'uso della 3NF rispetto alla BCNF.
    \end{framedobs}
    
    \quad
    
    \section{Calcolare $X^+$}
    
    \quad
    
    \begin{framedalgo}{Algoritmo per la chiusura di un insieme di attributi}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Dato un qualsiasi insieme di attributi $X \subseteq R$, è possibile calcolare tutti gli elementi appartenenti a $X_F^+$ tramite il seguente algoritmo:
        
        \quad
        
        \texttt{def closureX(R: schema, F: set of dependencies, X: subset of R):}
        
        \texttt{\qquad Z := X}
        
        \texttt{\qquad S := \{ A $\mid$ $\exists$ Y $\to$ V $\in$ F, A $\in$ V $\subseteq$ R, Y $\subseteq$ Z \}}
        
        \texttt{\qquad while S $\not\subseteq$ Z do:}
        
        \texttt{\qquad\qquad Z := X $\cup$ S}
        
        \texttt{\qquad\qquad S := \{ A $\mid$ $\exists$ Y $\to$ V $\in$ F, A $\in$ V $\subseteq$ R, Y $\subseteq$ Z \}}
        
        \texttt{\qquad X$^+$ := Z}
        
        \texttt{\qquad return X$^+$}
        
        Tale algoritmo viene eseguito in tempo polinomiale, ossia $O(n^k)$
    \end{framedalgo}
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Dato lo schema $R = ABCDEHL$ e l'insieme di dipendenze funzionali $F = \{ AB \to C, B \to D, AD \to E, CE \to H\}$ definite su $R$, vogliamo calcolare $AB^+$.
        
        \item Utilizzando l'algoritmo, ad ogni iterazione si ha che:
        \begin{enumerate}
            \item Inizialmente si ha che $Z := AB$ e $S := CD$, poiché:
                \begin{itemize}
                    \item $AB \subseteq AB \land AB \to C \implies C \in S$
                    \item $B \subseteq AB \land B \to D \implies D \in S$
                \end{itemize}
                
                Notiamo come tramite l'algoritmo stiamo implicitamente utilizzando gli assiomi di Armstrong per aggiungere $C$ e $D$ a $Z = AB$:
                
                \begin{itemize}
                    \item $A,B \in AB, AB \to A, AB \to B \in F^A$
                    \item $AB \to C, B \to D \in F \implies AB \to C, B \to D \in  F^A$
                    \item $B \subseteq AB \implies AB \to B \in F^A$
                    \item $AB \to B, B \to D \in F^A \implies AB \to D \in F^A$
                    \item $AB \to A, AB \to B, AB \to C, AB \to D \in F^A \iff A,B,C,D \in AB^+ $
                \end{itemize}
                
            \quad

            \item Siccome $C,D \in S \land C,D \notin Z \implies S \not\subseteq Z$, procediamo ponendo $Z := Z \cup S = ABCD$ e $S := CDE$, poiché:
                \begin{itemize}
                    \item $AB \subseteq ABCD \land AB \to C \implies C \in S$
                    \item $B \subseteq ABCD \land B \to D \implies D \in S$
                    \item $AD \subseteq ABCD \land AD \to E \implies E \in S$
                \end{itemize}
                
                Anche in questo caso, stiamo implicitamente utilizzando gli assiomi di Armstrong per aggiungere $E$ a $Z = ABCD$:
                
                \begin{itemize}
                    \item $B \to D \in F^A \implies AB \to AD \in F^A$
                    \item $AD \to E \in F \implies AD \to E \in F^A$
                    \item $AB \to AD, AD \to E \in F^A \implies AB \to E \in F^A \iff E \in AB^+$
                \end{itemize}
                
            \quad
            
             \item Siccome $E \in S \land E \notin Z \implies S \not\subseteq Z$, procediamo ponendo $Z := Z \cup S = ABCDE$ e $S := CDEH$, poiché:
                \begin{itemize}
                    \item $AB \subseteq ABCDE \land AB \to C \implies C \in S$
                    \item $B \subseteq ABCDE \land B \to D \implies D \in S$
                    \item $AD \subseteq ABCDE \land AD \to E \implies E \in S$
                    \item $CE \subseteq ABCDE \land CE \to H \implies H \in S$
                \end{itemize}
                
            Anche in questo caso, stiamo implicitamente utilizzando gli assiomi di Armstrong per aggiungere $H$ a $Z = ADCDE$:
            
            \begin{itemize}
                \item $AB \to C, AB \to E \in F^A \implies AB \to CE \in F^A$
                \item $CE \to H \in F \implies CE \to H \in F^A$
                \item $AB \to CE, CE \to H \in F^A \implies AB \to H \in F^A \iff H \in AB^+$
            \end{itemize}
                
            \quad
            
            \item Siccome $H \in S \land H \notin Z \implies S \not\subseteq Z$, procediamo ponendo $Z := Z \cup S = ABCDEH$ e $S := CDEH$, poiché:
                \begin{itemize}
                    \item $AB \subseteq ABCDEH \land AB \to C \implies C \in S$
                    \item $B \subseteq ABCDEH \land B \to D \implies D \in S$
                    \item $AD \subseteq ABCDEH \land AD \to E \implies E \in S$
                    \item $CE \subseteq ABCDEH \land CE \to H \implies H \in S$
                \end{itemize}
                
                In questo caso, quindi, $S$ rimane inalterato
                
            \item Infine, siccome $S \subseteq Z$, l'output dell'algoritmo sarà $AB^+ = ABCDEH$
        \end{enumerate}
    \end{itemize}
    
    \quad
    
    \begin{framedthm}{Correttezza dell'algoritmo \texttt{closureX}}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Dato un qualsiasi insieme di attributi $X \subseteq R$, l'algoritmo \texttt{closureX(R,F,X)} restituisce $X_F^+$
    \end{framedthm}
    
    \textit{Dimostrazione}:
    \begin{itemize}
        \item Siano $Z_0, Z_1, \ldots, Z_i, \ldots$ e $S_0, S_1, \ldots, S_i, \ldots$ gli insiemi calcolati ad ogni iterazione del ciclo while dell'algoritmo
        \item Osserviamo che $Z_i \subseteq Z_{i+1} \forall i \in \mathbb{N}$, dunque $Z_0, Z_1, \ldots, Z_i, \ldots$ è una sequenza monotona limitata da $R$, implicando che $\exists f \in \mathbb{N} \mid Z_f = Z_{f+1}$
        \item Siccome ciò può accadere solo se $S_f \subseteq Z_f$, ossia quando l'algoritmo termina, si ha che $Z_f$ è l'output dell'algoritmo
        \item Dimostriamo quindi per induzione che $Z_f \subseteq X^+$:
        \begin{itemize}
            \item \textbf{Caso base (i = 0)}: Alla 0-esima iterazione del while (ossia prima di esso) si ha $Z_0 = X \subseteq X^+$
            \item \textbf{Ipotesi induttiva}: Per ogni $i \in \mathbb{N}$ si ha che $Z_i \subseteq X^+$
            \item \textbf{Passo induttivo (i > 0)}: Dato $A \in Z_{i+1} := Z_i \cup S_i$, si ha che $A \in Z_i \lor A \in S_i$. Dunque, si possono verificare due casi:
            \begin{itemize}
                \item Se $A \in Z_i$, allora per ipotesi si ha che $A \in Z_i \subseteq X^+$
                \item Se $A \in S_i$, allora $\exists Y \to V \in F \mid A \in V \subseteq R, Y \subseteq Z_i$.
                
                Siccome per ipotesi si ha $Z_i \subseteq X^+$ e siccome $Y \subseteq Z_i$, allora $Y \subseteq Z_i \subseteq X^+ \iff X \to Y \in F^A$ e siccome $Y \to V \in F \implies Y \to V \in F^A$, allora per transitività si ha che
                \[ X \to Y, Y \to V \in F^A \implies X \to V \in F^A \iff V \subseteq X^+\]
                
                Dunque, si ha che $A \in V \subseteq X^+$
                \item Siccome in entrambi i casi $A \in Z_{i+1} \implies A \in X^+$, allora concludiamo che $Z_{i+1} \subseteq X^+$
            \end{itemize}
        \end{itemize}
        
        \item Dimostriamo ora che $X^+ \subseteq Z_f$:
            \begin{itemize}
                \item Sia $X \subseteq R$ e sia $r$ istanza di $R(Z_f, R-Z_f)$ tale che
                
                \begin{center}
                    \begin{tabular}{|c|c|c|c|c|c|}
                        \hline
                        \multicolumn{3}{|c|}{\textbf{$Z_f$}}
                        & \multicolumn{3}{|c|}{\textbf{$R-Z_f$}}\\
                        \hline
                        \textbf{$A_1$} & \textbf{$\cdots$} & \textbf{$A_i$} & \textbf{$A_j$} & \textbf{$\cdots$} & \textbf{$A_n$} \\
                        \hline
                        1 & \ldots & 1 & 1 & \ldots & 1\\
                        1 & \ldots & 1 & 0 & \ldots & 0\\
                        \hline
                    \end{tabular}
                \end{center}
                
                dunque tale che per $t_1, t_2 \in r$ si ha:
                \begin{itemize}
                    \item $t_1[Z_f]= (1, \ldots, 1) = t_2[Z_f]$
                    \item $t_1[R-Z_f]= (1, \ldots, 1)  \neq (0, \ldots, 0) = t_2[R-Z_f]$
                \end{itemize} 
                
                \item Notiamo che $\forall V,W \subseteq R \mid V \to W \in F$ si ha che:
                \begin{itemize}
                    \item Se $V \cap R-Z_f \neq \emptyset$  (dunque anche se $V \subseteq R-Z_f$) allora $t_1[V] \neq t_2[V]$, dunque $r$ soddisfa $V \to W \in F$
                    \item Se invece $V \subseteq Z_f$, allora $W \subseteq S_f$, poiché, per come viene calcolato $S_f$, si ha che:
                    \[V \to W \in F, V \subseteq Z_f, B \in W \subseteq R\implies B \in S_f  \implies W \subseteq S_f\]
                    
                    e dunque, siccome $S_f \subseteq Z_f$ è la condizione che termina l'algoritmo, allora $W \subseteq S_f \subseteq Z_f$
                    \item Siccome $V,W \subseteq Z_f$, in definitiva si ha che
                    \[t_1, t_2 \in r, t_1[V]=(1,\ldots,1) = t_2[V] \land t_1[W]=(1,\ldots,1) = t_2[W]\]
                    
                    e quindi $r$ soddisfa $V \to W \in F$
                    
                \end{itemize}
                
                \item Siccome in entrambi i casi $r$ soddisfa ogni $V \to W \in F$, allora $r$ è legale.
                \item A questo punto, dato $A \in X^+$ si ha che $X \to A \in F^A = F^+$ deve essere soddisfatta da qualsiasi istanza legale di $R$, inclusa $r$ stessa
                \item Poiché $X = Z_0 \subseteq Z_f$, ne segue che la dipendenza non può essere soddisfatta a vuoto poiché $t_1[X] = t_2[X]$. Dunque, l'unica possibilità affinché $X \to A \in F^+$ sia soddisfatta da $r$ è $A \in Z_f$ in modo che si abbia $t_1[A] = t_2[A]$
                \item Dunque, siccome $A \in X^+ \implies A \in Z_f$, concludiamo che $X^+ \subseteq Z_f$
            \end{itemize}

            $\hfill\qed$
    \end{itemize}
    
    \quad
    
    \subsection{Trovare le chiavi di uno schema}
    
    \quad
    
    \begin{framedprop}{}
        Dato uno schema $R$ e dato un insieme $F$ di dipendenze funzionali definite su $R$, si ha che:
        \[  X \subseteq R  \text{ superchiave di }R \iff X^+ = R\]
    \end{framedprop}
    
    \textit{Dimostrazione}:
    
    \begin{itemize}
        \item Sia $R = \{ A_1, \ldots, A_k\}$ e sia $X \subseteq R$. In tal caso, si ha che:
        \[ X \to R \in F^+ \iff \forall i \in [1,k], X \to A_i \in F^+ = F^A \iff\]
        \[\iff \forall i \in [1,k], A_i \in X^+ \iff X^+ = \{ A_i, \ldots, A_k\} = R\]
        
        \item Se $X \to R \in F^+$, le uniche possibilità sono:
        \begin{itemize}
            \item $\exists Y \subseteq X \mid Y \text{ chiave di } R \implies X \text{ superchiave di } R$
            \item $\nexists Y \subset X \mid Y \to R \in F^+ \implies X \text{ chiave di } R \implies X \text{ superchiave di } R$
        \end{itemize}
        
        \item Dunque, possiamo concludere che $X \subseteq R  \text{ superchiave di } R \iff X^+ = R$

        $\hfill\qed$
    \end{itemize}
    
    \begin{framedcor}{}
        Dato uno schema $R$ e dato un insieme $F$ di dipendenze funzionali definite su $R$, si ha che:
        \[ X \subseteq R \text{ chiave di } R \iff X^+ = R \land \nexists Y \subset X \mid Y^+ = R \]
    \end{framedcor}
    
    \begin{framedprop}{}
        Dato uno schema $R$ e dato un insieme $F$ di dipendenze funzionali definite su $R$, si ha che:
        \[ \nexists X \to Y \in F \mid A \in Y \implies A \in K \subseteq R \mid K \text{ chiave di } R\]
        
        In altre parole, se $A$ non è determinato da nessuna dipendenza funzionale in $F$, allora $A$ apparterrà ad ogni chiave di $R$
    \end{framedprop}
    
    \textit{Dimostrazione:}
    
    \begin{itemize}
        \item Sia $R = A_1, \ldots,A_j, \ldots  A_k$ e sia $F$ in insieme di dipendenze funzionali su $R$ dove $\nexists X \to Y \in F \mid A \in Y$.
        
        \item Se $K = R$ fosse chiave di $R$, allora necessariamente si avrebbe che $A \in K = R$
        
        \item Supponiamo quindi per assurdo che $\exists K \subset R \mid K \text{ chiave di } R, A \notin K$
        
        \item Siccome $K$ è chiave di $R$, allora $K^+ = R =  A_1, \ldots,A_j, \ldots  A_k$, implicando necessariamente $K \to A_j \in F^A$.
        
        \item Tuttavia, si verifica che:
        \begin{itemize}
            \item $K \to A_j \in F^A$ non può essere ottenuta tramite l'inclusione di $F$, poiché $K \to A_j \notin F$, siccome $A_j$ non è determinato da alcuna dipendenza in $F$
            
            \item $K \to A_j \in F^A$ non può essere ottenuta tramite riflessività, poiché implicherebbe necessariamente che $A_j \in K$
            
            \item $K \to A_j \in F^A$ non può essere ottenuta tramite aumento, poiché implicherebbe necessariamente che $A_j \in K$
            
            \item L'unica possibilità, quindi, è che $K \to A_j \in F^A$ sia ottenuta tramite transitività, implicando l'esistenza di $Y \subseteq R$ tale che
            \[ K \to Y, Y \to A_j \in F^A \implies K \to A_j \in F^A\]
            
        \end{itemize}
        
        \item Affinché $Y \to A_j \in F^A$, si ha necessariamente che $\exists V \to W \in F \mid A_j \in V \lor A_j \in W$, poiché altrimenti non sarebbe possibile ricavare $Y \to A_j \in F^A$ applicando gli assiomi di Armstrong, contraddicendo l'ipotesi per cui $A$ non appartiene a nessun determinante e nessun determinato di ogni dipendenza funzionale in $F$
        
        $\hfill\qed$
        
    \end{itemize} 
    
    \textbf{Esempi}:
    
    \begin{enumerate}
        \item \begin{itemize}
            \item Dato lo schema $R = ABCDEH$ e l'insieme di dipendenze funzionali $F = \{ AB \to CD, C \to E, AB \to E, ABC \to D\}$, vogliamo trovare le chiavi del seguente schema
            
            \item Siccome non esistono dipendenze funzionali in $F$ per cui $A,B$ ed $H$ appaiono come determinato, necessariamente per ogni $K$ chiave di $R$ si ha che $A,B,H \in K$
            
            \item Proviamo quindi a calcolare $ABH^+$ utilizzando l'algoritmo visto precedentemente:
            \begin{itemize}
                \item Inizializziamo $Z = ABH$ e $S = CDE$
                \item Alla prima iterazione abbiamo $Z = ABCDEH$ e $S = CDE$
                \item Poiché alla seconda iterazione si avrebbe $S \subseteq Z$, allora $ABC^+ = ABCDEH$
            \end{itemize}
            
            \item Difatti, otteniamo che $ABH^+ = ABCDEH = R$, implicando che $ABH$ sia superchiave di $R$. Tuttavia, siccome per ogni $K$ chiave di $R$ si ha che $A,B,H \in K$, non possono esistere sottoinsiemi di $ABH$ che siano chiave, implicando quindi che $ABH$ sia chiave di $R$
            
            \item Inoltre, siccome $A,B,H$ sono in ogni chiave di $R$, ogni altro possibile insieme di attributi $X \subseteq R \mid X^+ = R$ corrisponderebbe ad una superchiave contenente $ABH$, dunque $ABH$ è l'unica chiave di $R$
        \end{itemize}
        
        \quad
        
        \item \begin{itemize}
            \item Dato lo schema $R = ABCDEGH$ e il seguente insieme di dipendenze funzionali $F = \{ AB \to D, G \to A, G \to B, H \to E, H \to G, D \to H\}$
            
            \item Siccome $C$ non è determinato da alcuna dipendenza, allora esso sarà in ogni chiave di $R$. Tuttavia, si ha che $C^+ = \emptyset \neq R$, dunque $C$ non è chiave di $R$
            
            \item Applichiamo quindi l'algoritmo per calcolare le chiusure di ogni insieme di attributi costituiti da $C$ e da un determinato di una dipendenza funzionale in $F$:
            \begin{itemize}
                \item $ABC^+ = R$
                \item $GC^+ = R$
                \item $DC^+ = R$
                \item $HC^+ = R$
            \end{itemize}
            
            \item Siccome gli unici sottoinsiemi di $GC, DC, HC$ contenenti anche $C$ sono loro stessi, allora tutti e tre sono chiavi di $R$
            \item Quanto ad $ABC$, è necessario applicare l'algoritmo sui sottoinsiemi $AC$ e $BC$, ottenendo che $AC^+ = AC$ e che $BC^+ = BC$, implicando quindi che $ABC$ sia chiave di $R$
        \end{itemize}
    \end{enumerate}
    
    \begin{framedthm}{Test dell'unicità}
        Sia $R$ uno schema e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Posto:
        \[ X := \bigcap_{V \to W \in F} R-(W-V)\]
        
        Si ha che:
        \begin{itemize}
            \item $X^+ = R \implies X$ è l'unica chiave di $R$
            \item $X^+ \neq R \implies$ esistono più chiavi in $R$ e $X$ non è superchiave di $R$
        \end{itemize}
        
        \textit{(dimostrazione omessa)}
    \end{framedthm}
    
    \newpage

    \textbf{Esempi:}
    
    \begin{enumerate}
        \item \begin{itemize}
            \item Dato lo schema $R = ABCDEH$ e l'insieme di dipendenze funzionali $F = \{ AB \to CD, C \to E, AB \to E, ABC \to D\}$, vogliamo determinare se $R$ sia in 3NF
            
            \item Utilizziamo il test dell'unicità per determinare la quantità di chiavi in $R$:
            \begin{itemize}
                \item Siccome $AB \to CD \in F$, allora consideriamo l'insieme di attributi $R-(CD - AB) = R-CD+AB =  ABEH$
                \item Siccome $C \to E \in F$, allora consideriamo l'insieme di attributi $R-(E - C) = R-E+C =  ABCDH$
                \item Siccome $AB \to E \in F$, allora consideriamo l'insieme di attributi $R-(E - AB) = R-E+AB =  ABCDH$
                \item Siccome $ABC \to D \in F$, allora consideriamo l'insieme di attributi $R-(D - ABC) = R-D+ABC =  ABCEH$
                \item A questo punto, consideriamo l'intersezione degli insiemi di attributi determinati:
                \[ \bigcap_{V \to W \in F} R-(W-V) = ABEH \cap ABCDH \cap ABCDH \cap ABCEH = ABH\]
                
                \item Siccome $ABH^+ = R$, allora $ABH$ è l'unica chiave di $R$
            \end{itemize}
            
            \item Per verificare che $R$ sia in 3NF, ci basta vedere che:
            \[ AB \to CD \in F \implies AB \to CD \in F^A \implies AB \to C, AB \to D \in F^A = F^+\]
            
            \item Siccome $AB \to C, AB \to D \in F^+$ sono dipendenze parziali, allora $R$ non è in 3NF 
        \end{itemize}
        
        \quad

        \item \begin{itemize}
            \item Dato lo schema $R = ABCDEGH$ e l'insieme di dipendenze funzionali $F = \{ AB \to CD, EH \to D, D \to H\}$, vogliamo determinare se $R$ sia in 3NF
            
            \item Utilizziamo il test dell'unicità per determinare la quantità di chiavi in $R$:
            \[ \bigcap_{V \to W \in F} R-(W-V) =  ABEGH \cap ABCEGH \cap ABCDEG = ABEG\]
            
            \item Siccome $ABEG^+ = R$, allora $ABEG$ è l'unica chiave di $R$, implicando che $R$ non sia in 3NF (basta considerare la dipendenza $AB \to CD \in F$)
        \end{itemize}
        
        \newpage
        
        \item \begin{itemize}
            \item Dato lo schema $R = ABCDE$ e l'insieme di dipendenze funzionali $F = \{ AB \to C, AC \to B, B \to E\}$, vogliamo determinare se $R$ sia in 3NF
            
            \item Utilizziamo il test dell'unicità per determinare la quantità di chiavi in $R$:
            \[ \bigcap_{V \to W \in F} R-(W-V) =  ABDE \cap ACDE \cap ABCD = AD\]
            
            \item Siccome $AD^+ = AD \neq R$, allora esistono più chiavi in $R$ e $AD$ non è superchiave di $R$.
            
            \item Siccome $A$ e $D$ non sono determinati da alcuna dipendenza in $F$, allora sappiamo che essi devono appartenere ad ogni chiave di $R$.
            
            \item Osservando i determinanti delle dipendenze in $F$, notiamo che aggiungendo $B$ all'insieme di attributi $AD$ potremmo raggiungere anche $C$ ed $E$ tramite l'algoritmo conosciuto. Difatti, si ha che $ABD^+ = R$, implicando che $ABD$ sia chiave di $R$, poiché l'unico sottoinsieme di $ABD$ contenente anche $AD$ è $AD$ stesso, il quale sappiamo non essere superchiave.
            
            \item Analogamente, osserviamo che aggiungendo $C$ all'insieme di attributi $AD$ potremmo raggiungere $B$ ed $E$. Difatti, si ha che $ACD^+ = R$, implicando che anche $ACD$ sia chiave di $R$
            
            \item Siccome $B \to E \in F$ è una dipendenza parziale, allora $R$ non è in 3NF
        \end{itemize}
    \end{enumerate}
    
    \quad
    
    \section{Decomposizione di uno schema}
    
    \quad
    
    \begin{frameddefn}{Decomposizione di uno schema}
        Sia $R$ uno schema. Definiamo come \textbf{decomposizione di $R$} l'insieme di sottoschemi $\rho = R_1, \ldots, R_k$ che \textbf{ricoprono $R$}, ossia tali che:
        \[ R = \bigcup_{i=0}^k R_i\]
        
        In altre parole, $R_1, \ldots, R_k$ sono un insieme di schemi tramite cui è possibile ricostruire $R$ effettuando un join naturale tra essi
    \end{frameddefn}
    
    \begin{framedobs}{}
        Decomporre uno schema $R$ in più sottoschemi $R_1, \ldots, R_k$ risulta utile nel caso in cui:
        \begin{itemize}
            \item $R$ non sia in 3NF, poiché è più probabile che i suoi sottoschemi siano in 3NF
            \item Si vuole ottenere un'efficienza maggiore, poiché in alcuni casi potrebbe essere necessaria solo una parte dell'informazione totale, rendendo quindi necessario effettuare una query solo tra alcuni sottoschemi invece che su tutto $R$. Inoltre, essendo le tuple dei sottoschemi più piccole rispetto a quelle di $R$, possiamo caricarne di più in memoria.
        \end{itemize}
    \end{framedobs}
    
     \begin{frameddefn}{Buona decomposizione di uno schema}
        Sia $R$ uno schema con decomposizione $\rho = R_1, \ldots, R_k$ e sia $F$ un insieme di dipendenze funzionali su $R$.
        
        Definiamo $\rho$ come una \textbf{buona decomposizione di $R$} se:
        \begin{itemize}
            \item Ogni sottoschema $R_1, \ldots, R_k \in \rho$ è in \textbf{Terza Forma Normale}
            \item $\rho$ permette di mantenere soddisfatta ogni dipendenza in $F$ per ogni istanza legale $r$ di $R$ ricostruita attraverso un join naturale tra tutte le istanze $r_1, \ldots, r_k$ rispettivamente di $R_1, \ldots, R_k$ (\textbf{preservazione di $F$})
            \item $\rho$ permette di ricostruire senza perdita di informazioni le tuple di ogni istanza legale $r$ di $R$ ricostruita attraverso un join naturale tra tutte le istanze $r_1, \ldots, r_k$ rispettivamente di $R_1, \ldots, R_k$ (\textbf{join senza perdita})
        \end{itemize}
    \end{frameddefn}
    
    \textbf{Esempio:}
    
    \begin{enumerate}
        \item 
        \begin{itemize}
            \item Consideriamo lo schema $R = ABC$ e l'insieme di dipendenze funzionali $F = \{ A \to B, B \to C\}$.
            \item Notiamo facilmente che $A$ è l'unica chiave di $R$, implicando che $R$ non sia in 3NF poiché $B \to C$ non rispetta la definizione di 3NF.
            \item Proviamo quindi a decomporre $R$ in $\rho = \{AB, AC\}$, dove $F_1 = \{A \to B\}$ è l'insieme di dipendenze di $R_1 := AB$ mentre $F_2 = \{ A \to C\}$ è l'insieme di dipendenze di $R_2 := AC$
            
            \item Entrambi i sottoschemi risultano essere in 3NF, tuttavia la decomposizione risulta essere incorretta:
            
            \begin{itemize}
                \item Consideriamo due istanze legali dei due sottoschemi ottenuti:
                
                \begin{center}
                    \begin{tabular}{ccc}
                        \begin{tabular}{|c|c|}
                            \hline
                            \multicolumn{2}{|c|}{$R_1$}\\
                            \hline
                            \textbf{A} & \textbf{B}\\
                            \hline
                            $a_1$ & $b_1$\\
                            $a_2$ & $b_1$\\
                            \hline
                        \end{tabular}
                        
                        &\qquad\qquad&
                        
                        \begin{tabular}{|c|c|}
                            \hline
                            \multicolumn{2}{|c|}{$R_2$}\\
                            \hline
                            \textbf{A} & \textbf{C}\\
                            \hline
                            $a_1$ & $c_1$\\
                            $a_2$ & $c_2$\\
                            \hline
                        \end{tabular}
                    \end{tabular}
                \end{center}
                
                \item Effettuando il join naturale tra $R_1$ ed $R_2$, otteniamo che:
                
                 \begin{center}
                    \begin{tabular}{|c|c|c|}
                        \hline
                        \multicolumn{3}{|c|}{$R = R_1 \bowtie R_2$}\\
                        \hline
                        \textbf{A} & \textbf{B} & \textbf{C}\\
                        \hline
                        $a_1$ & $b_1$ & $c_1$\\
                        $a_2$ & $b_1$ & $c_2$\\
                        \hline
                    \end{tabular}
                \end{center}
                
                \quad
                
                \item Considerando l'insieme iniziale di dipendenze funzionali $F = \{ A \to B, B \to C\}$, notiamo come $B \to C$ non \textbf{preservata dalla decomposizione}, ossia non sia più soddisfatta da tale istanza di $R$, rendendola quindi illegale. 
                
                \item Dunque, tale decomposizione non risulta essere una buona decomposizione
            \end{itemize}
        \end{itemize}
        
        \item \begin{itemize}
        
        \item Consideriamo lo schema $R = ABC$ e l'insieme di dipendenze funzionali $F = \{ A \to B, C \to B\}$
            
        \item In questo caso, notiamo facilmente che $AC$ è l'unica chiave di $R$, implicando che $R$ non sia in 3NF poiché né $A \to B$ né $C \to B$ rispettano la definizione di 3NF.
        
        \item Consideriamo quindi la seguente istanza $r$ di $R$:
            \begin{center}  
                \begin{tabular}{|c|c|c|}
                    \hline
                    \multicolumn{3}{|c|}{$r$}\\
                    \hline
                    \textbf{A} & \textbf{B} & \textbf{C}\\
                    \hline
                    $a_1$ & $b_1$ & $c_1$\\
                    $a_2$ & $b_1$ & $c_2$\\
                    \hline
                \end{tabular}
            \end{center}
        
        \quad
        
        \item Proviamo quindi a decomporre $R$ in $\rho = \{AB, BC\}$, dove $F_1 = \{A \to B\}$ è l'insieme di dipendenze di $R_1 := AB$ mentre $F_2 = \{ C \to B\}$ è l'insieme di dipendenze di $R_2 := BC$
        
            \begin{itemize}
                \item Le due sottoistanze ottenute corrispondono a:
                
                \begin{center}
                    \begin{tabular}{ccc}
                        \begin{tabular}{|c|c|}
                            \hline
                            \multicolumn{2}{|c|}{$R_1$}\\
                            \hline
                            \textbf{A} & \textbf{B}\\
                            \hline
                            $a_1$ & $b_1$\\
                            $a_2$ & $b_1$\\
                            \hline
                        \end{tabular}
                        
                        &\qquad\qquad&
                        
                        \begin{tabular}{|c|c|}
                            \hline
                            \multicolumn{2}{|c|}{$R_2$}\\
                            \hline
                            \textbf{B} & \textbf{C}\\
                            \hline
                            $b_1$ & $c_1$\\
                            $b_1$ & $c_2$\\
                            \hline
                        \end{tabular}
                    \end{tabular}
                \end{center}
                
                \item Effettuando il join naturale tra $R_1$ ed $R_2$, otteniamo che:
                
                 \begin{center}
                    \begin{tabular}{|c|c|c|}
                        \hline
                        \multicolumn{3}{|c|}{$R = R_1 \bowtie R_2$}\\
                        \hline
                        \textbf{A} & \textbf{B} & C\\
                        \hline
                        $a_1$ & $b_1$ & $c_1$\\
                        $a_1$ & $b_1$ & $c_2$\\
                        $a_2$ & $b_1$ & $c_1$\\
                        $a_2$ & $b_1$ & $c_2$\\
                        \hline
                    \end{tabular}
                \end{center}
                
                \quad
                
                \item Notiamo come nell'istanza ottenuta si siano andate a creare nuove tuple precedentemente non esistenti, implicando una \textbf{perdita di informazione} (controintuitivamente, la creazione di tuple prima non esistenti implica che sia stata persa l'informazione "tali tuple non esistevano")
                \item Dunque, tale decomposizione non risulta essere una buona decomposizione
            \end{itemize}
        \end{itemize}
    \end{enumerate}
    
    
    \begin{framedprop}{}
        Dato uno schema $R$ con decomposizione $\rho = R_1, \ldots, R_k$ ed istanza $r$, ogni istanza $r_1, \ldots, r_k$ rispettivamente di $R_1, \ldots, R_k$ corrisponde ad una \textbf{proiezione di $r$} sugli attributi di $R_i$:
        \[ r_i = \pi_{R_i}(r)\]
        
        dove $i \in [1, k]$.
        
        Di conseguenza, le singole proiezioni hanno l'effetto di eliminare i duplicati che potrebbero essere generati da due tuple distinte aventi una porzione comune che ricade nello stesso sottoschema, riducendo la memoria necessaria a conservare le informazioni.
    \end{framedprop}
    
    \quad
    
    \subsection{Preservazione di $F$}
    
    \quad
    
    \begin{frameddefn}{Equivalenza tra insiemi di dipendenze}
        Sia $R$ uno schema e siano $F$ e $G$ due insiemi di dipendenze funzionali su $R$.
        
        Tali insiemi vengono detti \textbf{equivalenti}, indicato come $F \equiv G$, se $F^+ = G^+$
    \end{frameddefn}
    
    \begin{framedlem}{Inclusione delle chiusure}
        Dato uno schema $R$ e due insiemi $F$ e $G$ di dipendenze funzionali su $R$, si ha che:
        \[ F \subseteq G^+ \iff F^+ \subseteq G^+\]
        
    \end{framedlem}
    
    
    \textit{Dimostrazione:}
    \begin{itemize}
        \item Denotiamo come $G \xrightarrow{A} F$ la possibilità di ottenere $F$ partendo da $G$ applicando una determinata quantità di assiomi di Armstrong
        \item Ricordando che $G^A$ è l'insieme di tutte le dipendenze funzionali ottenibile applicando assiomi di Armstrong su $G$, allora:
        \[G \xrightarrow{A} F \iff \forall X \to Y \in F \text{ si ha } X \to Y \in G^A = G^+ \iff F \subseteq G^+\]
        
        \item Siccome $F \subseteq G^+ \iff G \xrightarrow{A} F$, per definizione di $F^A = F^+$ si ha che
        \[F \subseteq G^+ \implies G \xrightarrow{A} F \xrightarrow{A} F^A = F^+ \implies F^+ \subseteq G^+\]
        
        \item Viceversa, si ha che $F^+ \subseteq G^+ \implies F \subseteq F^+ \subseteq G^+$, quindi concludiamo che $F \subseteq G^+ \iff F^+ \subseteq G^+$
        
        $\hfill\qed$
    \end{itemize}
    
    \begin{framedthm}{Preservazione di $F$}
        Sia $R$ uno schema con decomposizione $\rho = R_1, \ldots, R_k$ e sia $F$ un insieme di dipendenze funzionali su $R$.
        
        Si ha che \textbf{$\rho$ preserva $F$} se:
        \[ F \equiv G := \bigcup_{i = 0}^k \pi_{R_i}(F)\]
        
        dove $\pi_{R_i}(F) = \{ X \to Y \in F^+ \mid XY \subseteq R_i\}$ viene detta \textbf{proiezione di $F$ su $R_i$}, ossia l'insieme di tutte le dipendenze in $F^+$ tali che il determinante e il determinato sono entrambi sottoinsiemi di $R_i$
    \end{framedthm}
    
    \begin{framedcor}{}
         Dato uno schema $R$ con decomposizione $\rho = R_1, \ldots, R_k$, dato un insieme $F$ di dipendenze funzionali su $R$ e posto:
        \[ G := \bigcup_{i = 0}^k \pi_{R_i}(F)\]
        si ha che $\rho$ preserva $F$ se $F \subseteq G^+$, poiché:
        \[F \subseteq G^+ \implies F \equiv G\]
    \end{framedcor}
    
    \textit{Dimostrazione:}
    
    \begin{itemize}
        \item Poiché $\forall R_i \in \rho$ si ha che $\pi_{R_i}(F) \subseteq F^+$, per definizione stessa di $G$ si ha sempre che $G \subseteq F^+$.
        \item Siccome $G \subseteq F^+ \iff G^+ \subseteq F^+$ e siccome $F \equiv G \iff F^+ = G^+$, allora è sufficiente verificare se $F \subseteq G^+$ affinché $F^+ = G^+$, poiché $F \subseteq G^+ \iff F^+ \subseteq G^+$
        
        $\hfill\qed$
    \end{itemize}
    
    \begin{framedalgo}{Verifica di $F_1 \subseteq F_2^+$}
        Dato uno schema $R$ e dati due insiemi $F_1$ e $F_2$ di dipendenze funzionali su $R$, il seguente algoritmo determina se $F_1 \subseteq F_2^+$:
        
        \texttt{def F$_1$\_in\_F$_2^+$(R: schema, F$_1$: set of dep., F$_2$: set of dep.):}
        
        \texttt{\qquad for X $\to$ Y $\in$ F$_1$:}
        
        \texttt{\qquad\qquad if Y $\not\subseteq$ X$_{F_2}^+$:}
        
        \texttt{\qquad\qquad\qquad return False}
        
        \texttt{\qquad return True}
        
    \end{framedalgo}
    
    
    \begin{framedobs}{}
        Per applicare tale algoritmo durante la verifica della preservazione di $F$, è necessario prima calcolare $F^+$, in modo da poter calcolare $G$ e successivamente ogni $X_G^+$ richiesto per verificare che $F \subseteq G^+$. Tuttavia, siccome il calcolo di $F^+$ richiede tempo esponenziale, allora è necessario calcolare i vari $X_G^+$ tramite un metodo alternativo.
    \end{framedobs}
    
    \begin{framedalgo}{Calcolo di $X_G^+$ tramite $F$}
        Dato uno schema $R$ con decomposizione $\rho = R_1, \ldots, R_k$, dato un insieme $F$ di dipendenze funzionali su $R$ e posto:
        \[ G := \bigcup_{i = 0}^k \pi_{R_i}(F)\]
        
        preso $X \subseteq R$, il seguente algoritmo calcola $X_G^+$ tramite $F$:
        
        \texttt{def X$_G^+$\_with\_F(R: schema, F: set of dependencies, X: set of attributes):}
        
        \texttt{\qquad Z := X}
        
        \texttt{\qquad S := $\emptyset$}
        
        \texttt{\qquad for i in range(1, k):}
        
        \texttt{\qquad\qquad S := S $\cup$ ((Z $\cap$ R$_i$)$_F^+ \cap R_i$)}
        
        \texttt{\qquad while S $\not\subseteq $ Z:}
        
        \texttt{\qquad\qquad Z := Z $\cup$ S}
        
        \texttt{\qquad\qquad for i in range(1, k):}
        
        \texttt{\qquad\qquad\qquad S := S $\cup$ ((Z $\cap$ R$_i$)$_F^+ \cap R_i$)}
        
        \texttt{\qquad X$_G^+$ := Z}
        
        \texttt{\qquad return X$_G^+$}
        
    \end{framedalgo}
    
    \textbf{Esempi:}
    
    \begin{enumerate}
        \item \begin{itemize}
            \item Dato lo schema $R = ABC$ e l'insieme di dipendenze funzionali $F = \{A \to B, B \to C\}$, vogliamo vedere se la decomposizione $\rho = \{ AB, AC\}$ preserva $F$.
            
            \item Per il corollario precedentemente visto, sappiamo che è sufficiente utilizzare l'algoritmo in grado di verificare se $F \subseteq G^+$, richiamante a sua volta l'algoritmo del calcolo di $X^+_G$ tramite $F$
            
            \item Siccome $A \to B\in \pi_{AB}(F) \subseteq G \subseteq G^+$, non è necessario verificare tramite l'algoritmo se tale dipendenza venga preservata.
            
            \item Dunque, l'unica dipendenza da verificare è $B \to C$. Calcoliamo quindi $B_G^+$:
            
            \begin{itemize}
                \item Inizializzando l'algoritmo, dunque ponendo $Z := B$ otteniamo che:
                \begin{itemize}

                    \item $S_1 = S_0 \cup ((B \cap AB)_F^+ \cap AB) = \emptyset \cup (B_F^+ \cap AB) = \emptyset \cup (BC \cap AB) = B$
                    \item $S_2 = S_1 \cup ((B \cap AC)_F^+ \cap AC) = B \cup ((\emptyset)_F^+ \cap AC) = B$
                \end{itemize}
            
                \item Siccome $S_2 = B \subseteq B = Z$, allora l'algoritmo termina con $B_G^+ = Z = B$, implicando a sua volta che $C \notin B_G^+ \iff B \to C \notin G^A=G^+$
            \end{itemize}
            
            \item Dunque, siccome tutte non tutte le dipendenze di $F$ sono in $G^+$, l'algoritmo terminerà concludendo che $F \not\subseteq G^+$, implicando che $F \not\equiv G$ e quindi che $F$ non venga preservato
        \end{itemize}
        
        \quad
            
        \item \begin{itemize}
            \item Dato lo schema $R = ABCD$ e l'insieme di dipendenze funzionali $F = \{AB \to C, D \to C, D \to B, D \to A, C \to B\}$, vogliamo vedere se la decomposizione $\rho = \{ ABC, ABD\}$ preserva $F$.
            
            \item Siccome $AB \to C, C \to B \in \pi_{ABC}(F) \subseteq G \subseteq G^+$, non è necessario verificare tramite l'algoritmo se tali dipendenze vengano preservate.
            
            Analogamente, siccome $D \to B, D \to A, \in \pi_{ABD}(F) \subseteq G \subseteq G^+$, non è necessario verificare se tali dipendenze vengano preservate.

            \item Dunque, l'unica dipendenza da verificare è $D \to C$. Calcoliamo quindi $D_G^+$:
            
            \begin{itemize}
                \item Inizializzando l'algoritmo, dunque ponendo $Z := D$ otteniamo che:
                \begin{itemize}

                    \item $S_1 = S_0 \cup ((D \cap ABC)_F^+ \cap ABC) = \emptyset \cup ((\emptyset)_F^+ \cap ABC) = \emptyset$
                    \item $S_2 = S_1 \cup ((D \cap ABD)_F^+ \cap ABD) = \emptyset \cup (D_F^+ \cap ABC) = \emptyset \cup (ABCD \cap ABD) = ABD$
                \end{itemize}
                
                \item Siccome $S_2= ABD \not\subseteq D$, allora entriamo nel ciclo while ponendo $Z := Z \cup S_2 = ABD$ e ripetendo il procedimento:
                
                \begin{itemize}
                    \item $S_3 = S_2 \cup ((ABD \cap ABC)_F^+ \cap ABC) = ABD \cup (AB_F^+ \cap ABC) = ABD \cup (ABC \cap ABC) = ABCD$
                    \item $S_4 = S_3 \cup ((ABD \cap ABD)_F^+ \cap ABD) = ABCD \cup (ABD_F^+ \cap ABD) = ABCD \cup (ABCD \cap ABD) = ABCD$
                \end{itemize}
                
                \item Siccome $S_4= ABCD \not\subseteq ABD$, allora poniamo $Z := Z \cup S_4 = ABCD$ e ripetiamo il procedimento:
                
                \begin{itemize}
                    \item $S_5 = S_4 \cup ((ABCD \cap ABC)_F^+ \cap ABC) = ABCD \cup (ABC_F^+ \cap ABC) = ABD \cup (ABC \cap ABC) = ABCD$
                    \item $S_6 = S_5 \cup ((ABCD \cap ABD)_F^+ \cap ABD) = ABCD \cup (ABD_F^+ \cap ABD) = ABCD \cup (ABCD \cap ABD) = ABCD$
                \end{itemize}
                
                \item Siccome $S_6 = ABCD \subseteq ABCD = Z$, allora l'algoritmo termina con $D_G^+ = Z = ABCD$, da cui si ha che $D_G^+ = ABCD \implies D \to C \in G^+$, dunque si ha che $F \subseteq G^+ \implies F \equiv G$ e quindi che $\rho$ preservi $F$ 
            \end{itemize}
        \end{itemize}
    \end{enumerate}
    
    \begin{framedthm}{Correttezza dell'algoritmo \texttt{X$_G^+$\_with\_F}}
        Sia $R$ uno schema con decomposizione $\rho = R_1, \ldots, R_k$ e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Posto:
        \[ G := \bigcup_{i = 0}^k \pi_{R_i}(F)\]
        
        e dato un qualsiasi insieme di attributi $X \subseteq R$, l'algoritmo \texttt{X$_G^+$\_with\_F(R,F,X)} restituisce $X_G^+$
    \end{framedthm}
    
    \textit{Dimostrazione (solo un'implicazione):}
    
    \begin{itemize}
        \item Siano $Z_0, Z_1, \ldots, Z_i, \ldots$ e $S_0, S_1, \ldots, S_i, \ldots$ gli insiemi calcolati ad ogni iterazione del ciclo while dell'algoritmo
        \item Osserviamo che $Z_i \subseteq Z_{i+1} \forall i \in \mathbb{N}$, dunque $Z_0, Z_1, \ldots, Z_i, \ldots$ è una sequenza monotona limitata da $R$, implicando che $\exists f \in \mathbb{N} \mid Z_f = Z_{f+1}$
        \item Siccome ciò può accadere solo se $S_f \subseteq Z_f$, ossia quando l'algoritmo termina, si ha che $Z_f$ è l'output dell'algoritmo
        
        \item Dimostriamo quindi per induzione che $Z_f \subseteq X_G^+$:
        \begin{itemize}
            \item \textbf{Caso base (i = 0)}: Alla 0-esima iterazione del while (ossia prima di esso) si ha $Z_0 = X \subseteq X_G^+$
            \item \textbf{Ipotesi induttiva}: Per ogni $i \in \mathbb{N}$ si ha che $Z_i \subseteq X_G^+$
            \item \textbf{Passo induttivo (i > 0)}: Dato $A \in Z_{i+1} := Z_i \cup S_i$, si ha che $A \in Z_i \lor A \in S_i$. Dunque, si possono verificare due casi:
            \begin{itemize}
                \item Se $A \in Z_i$, allora per ipotesi si ha che $A \in Z_i \subseteq X_G^+$
                \item Se $A \in S^i$, allora per definizione stessa di $S_i$ si ha che $\exists j \leq k \mid A \in ((Z_i \cap R_j)_F^+ \cap R_j)$
                
                A questo punto, si ha che $A \in ((Z_i \cap R_j)_F^+ \cap R_j) \iff A \in (Z_i \cap R_j)_F^+ \land A \in R_j$
                
                da cui otteniamo che $A \in (Z_i \cap R_j)_F^+ \iff (Z_i \cap R_j) \to A \in F^A = F^+$
                
                Dunque, siccome $(Z_i \cap R_j) \subseteq R_j$ e siccome $A \in R_j$, allora si ha che
                \[ (Z_i \cap R_j) \to A \in \pi_{R_j}(F) = \{ X \to Y \in F^+ \mid XY \in R_j\}\]
                
                da cui traiamo che $(Z_i \cap R_j) \to A \in \pi_{R_j}(F) \subseteq G \subseteq G^+ = G^A$ 
                
                Inoltre, siccome $(Z_i \cap R_j) \subseteq Z_i$ e siccome per ipotesi induttiva $Z_i \subseteq X_G^+$, allora $(Z_i \cap R_J) \subseteq Z_i \subseteq X_G^+$, implicando quindi che $X \to (Z_i \cap R_j) \in G^A$
                
                Infine, per transitività otteniamo che:
                \[ X \to (Z_i \cap R_j), (Z_i \cap R_j) \to A \in G^A \implies X \to A \in G^A \iff A \in X_G^+\]
            \end{itemize}
            
            \item Dunque, siccome in entrambi i casi si ha che $A \in Z_f \implies A \in X_G^+$, allora $Z_f \subseteq X^+_G$
        \end{itemize}

        $\hfill\square$
    \end{itemize}
    
    \quad
    
    \subsection{Join senza perdita}
        
    \quad
    
    \begin{framedthm}{Join senza perdita}
        Sia $R$ uno schema con decomposizione $\rho = R_1, \ldots, R_k$ e sia $F$ un insieme di dipendenze funzionali su $R$. La decomposizione \textbf{$\rho$ presenta un join senza perdita} se per ogni istanza legale $r$ di $R$ si ha che:
        \[ r = m_{\rho}(r) := \pi_{R_1}(r) \bowtie \ldots \bowtie \pi_{R_k}(r)\]
    \end{framedthm}
    
    \begin{framedprop}{}
        Sia $R$ uno schema con decomposizione $\rho = R_1, \ldots, R_k$ e sia $F$ un insieme di dipendenze funzionali su $R$.
        
        Posto $m_{\rho}(r) := \pi_{R_1}(r) \bowtie \ldots \bowtie \pi_{R_k}(r)$, per ogni istanza legale $r$ di $R$ si ha che:
        \begin{enumerate}
            \item $r \subseteq m_{\rho}(r)$
            \item $\pi_{R_i}(m_{\rho}(r)) = \pi_{R_i}(r), \forall R_i \in \rho$
            \item $m_{\rho}(m_{\rho}(r)) = m_{\rho}(r)$
        \end{enumerate}
    \end{framedprop}

    \newpage

    \textit{Dimostrazioni:}
    \begin{enumerate}
        \item Data una qualsiasi tupla $t \in r$, si ha che:
        \[ t \in r \implies t \in \{t[R_1]\} \bowtie \ldots \{t[R_k]\} \subseteq \pi_{R_1}(r) \bowtie \ldots \bowtie \pi_{R_k}(r) = m_{\rho}(r)\]
        dunque $r \subseteq m_{\rho}(r)$
        
        \item Poiché $r \subseteq m_{\rho}(r)$, allora effettuando una proiezione con $R_i \in \rho$ su entrambe, ne segue che $\pi_{R_i}(r) \subseteq \pi_{R_i}(m_{\rho}(r))$
        
        Inoltre, per definizione di proiezione, si ha che:
        \[t_{R_i} \in \pi_{R_i}(m_{\rho}(r)) \implies \exists t' \in m_{\rho}(r) \mid t_{R_i} = t'[R_i]\]
        
       Infine, per definizione stessa di $m_{\rho}(r)$, si ha che:
       \[ t' \in m_{\rho}(r) \implies \exists t_1, \ldots, t_k \in r \mid \forall R_j \in \rho, t_j[R_j]= t'[R_j]\]
       
       In particolare, quindi, otteniamo che:
       \[ t_{R_i} \in \pi_{R_1}(m_{\rho}(r)) \implies t_{R_i} = t'[R_i] = t_i[R_i] \in \pi_{R_i}(r) \implies \pi_{R_1}(m_{\rho}(r)) \subseteq \pi_{R_i}(r)\]
       
       \item Siccome $\pi_{R_i}(r) = \pi_{R_1}(m_{\rho}(r))$, allora si ha che:
       \[ m_{\rho}(m_{\rho}(r)) = \pi_{R_1}(m_{\rho}(r)) \bowtie \ldots \bowtie \pi_{R_k}(m_{\rho}(r)) = \pi_{R_1}(r) \bowtie \ldots \bowtie \pi_{R_k}(r) = m_{\rho}(r)\]

       $\hfill\qed$
    \end{enumerate}
    
    \begin{framedalgo}{Controllo presenza del join senza perdita}
        Dato uno schema $R = A_1, \ldots, A_n$ con decomposizione $\rho = R_1, \ldots, R_k$ e un insieme $F$ di dipendenze funzionali su $R$, presa l'istanza legale di $r$ di $R$ dove $\forall i \in [1,k], \forall j \in [1,n]$ si ha:
        \[r_{i,j} = \left \{ \begin{array}{ll}
            "a" & \text{ se } A_j \in R_i\\
            "b_{i}" & \text{ se } A_j \notin R_i
        \end{array}\right .\]
        
        il seguente algoritmo determina se $\rho$ presenta un join senza perdita.
        
        \texttt{def has\_lossless\_join(R: schema, F: set of dep., $\rho$: decomposition):}
        
        \texttt{\qquad unchanged := False}

        \texttt{\qquad while not unchanged:}

        \texttt{\qquad\qquad unchanged := True}
        
        \texttt{\qquad\qquad for X $\to$ Y $\in$ F:}
        
        \texttt{\qquad\qquad\qquad for t$_1$ in r:}
        
        \texttt{\qquad\qquad\qquad\qquad for t$_2$ in r:}
        
        \texttt{\qquad\qquad\qquad\qquad\qquad if t$_1$[X] == t$_2$[X] \&\& t$_1$[Y] != t$_2$[Y]:}
        
        \texttt{\qquad\qquad\qquad\qquad\qquad\qquad unchanged = False}
        
        \texttt{\qquad\qquad\qquad\qquad\qquad\qquad for A$_j \in$ Y:}
        
        \texttt{\qquad\qquad\qquad\qquad\qquad\qquad\qquad if t$_1$[A$_j$] == "a":}
        
        \texttt{\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad t$_2$[A$_j$] := t$_1$[A$_j$]}
        
        \texttt{\qquad\qquad\qquad\qquad\qquad\qquad\qquad else:}
        
        \texttt{\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad t$_1$[A$_j$] := t$_2$[A$_j$]}
        
        \texttt{\qquad if $\exists$ t $\in$ r $\mid$ t = ("a", $\ldots$, "a"):}

        \texttt{\qquad\qquad return True}
        
        \texttt{\qquad else: return False}
    \end{framedalgo}
    
    \textbf{Commenti sull'algoritmo:}
    
    \begin{itemize}
        \item L'algoritmo modifica l'istanza di partenza $r$ in modo che tutte le dipendenze di $F$ vengano soddisfatte
        \item Ogni volta che l'algoritmo trova due tuple aventi stesso valore nel determinante ma valori differenti , quest'ultimo viene modificato, in modo che essi siano uguali
        \item Nel fare ciò, il simbolo "$a$" viene considerato prioritario (difatti, "$a$" non può mai diventare "$b$", mentre "$b$" può diventare "$a$")
        \item Se due tuple hanno stesso valore nel determinante ma valori differenti nel determinato e se solo una delle due tuple ha un valore "$a$" nel determinato, viene cambiato il valore "$b$" dell'altra tupla in una "$a$"
        \item Se due tuple hanno stesso valore nel determinante ma valori differenti nel determinato ma nessuna delle due tuple ha un valore "$a$" nel determinato, viene cambiato il valore "$b$" di una delle due tuple in modo che esse abbiano lo stesso valore "$b$"
        \item Due valori vengono considerati uguali se sono entrambi una "$a$" (indipendentemente dal pedice che hanno) o se entrambi hanno una "$b$" con lo stesso identico pedice
        \item L'algoritmo termina quando tutte le coppie di tuple soddisfano le dipendenze di $F$
        \item Infine, quindi, $r$ diventa un'istanza legale di $R$
        \item Una volta terminato l'algoritmo, se esiste almeno una tupla avente tutti valori "$a$" al suo interno, allora $\rho$ presenta un join senza perdita, altrimenti no
    \end{itemize}
    
    \quad
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Dato lo schema $R = ABCDE$ con decomposizione $\rho = \{ AC, ADE, CDE, AD, B\}$ e con insieme di dipendenze  $F = \{ C \to D, AB \to E, D \to B\}$, vogliamo verificare se $\rho$ presenti un join senza perdita
        
        \item Partiamo costruendo l'istanza di $r$ secondo le regole date:
        
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c|}
                \hline
                    & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E}\\
                \hline
                \color{red}\textbf{AC} & \color{red}$a$ & $b_{1}$ & \color{red}$a$ & $b_{1}$ & $b_{1}$\\
                \color{blue}\textbf{ADE} & \color{blue}$a$ & $b_{2}$ & $b_{2}$ & \color{blue}$a$ & \color{blue}$a$\\
                \color{green}\textbf{CDE} & $b_{3}$ & $b_{3}$ & \color{green}$a$ & \color{green}$a$ & \color{green}$a$\\
                \color{orange}\textbf{AD} & \color{orange}$a$ & $b_{4}$ & $b_{4}$ & \color{orange}$a$ & $b_{4,5}$\\
                \color{purple}\textbf{B} & $b_{5}$ & \color{purple}$a$ & $b_{5}$ & $b_{5}$ & $b_{5}$\\
                \hline
            \end{tabular}
        \end{center}
            
        \quad
        
        \item Effettuiamo quindi la prima iterazione del ciclo:
        
        \begin{itemize}
            \item Considerando $C \to D \in F$, notiamo che la prima e la terza tupla sono uguali nel determinante $C$, dunque modifichiamo $b_{1} \to a$ affinché esse siano uguali anche nel determinato $D$
            \item Considerando $AB \to E \in F$, notiamo che tale dipendenza è già soddisfatta
            \item Considerando $D \to B \in F$, notiamo che la prima (poiché abbiamo già modificato $b_{1} \to a$), la seconda, la terza e la quarta tupla sono uguali nel determinante $D$, dunque modifichiamo $b_{2} \to b_{1}, b_{3} \to b_{1}$ e $b_{4} \to b_{1}$ affinché esse siano uguali anche nel determinato $B$
        \end{itemize}
            
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c|}
                \hline
                    & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E}\\
                \hline
                \textbf{AC} & $a$ & $b_{1}$ & $a$ & $b_{1} \to a$ & $b_{1}$\\
                \textbf{ADE} & $a$ & $b_{2} \to b_{1}$ & $b_{2}$ & $a$ & $a$\\
                \textbf{CDE} & $b_{3}$ & $b_{3} \to b_{1}$ & $a$ & $a$ & $a$\\
                \textbf{AD} & $a$ & $b_{4} \to b_{1}$ & $b_{4}$ & $a$ & $b_{4}$\\
                \textbf{B} & $b_{5}$ & $a$ & $b_{5}$ & $b_{5}$ & $b_{5}$\\
                \hline
            \end{tabular}
        \end{center}
        
        \item Siccome la tabella è stata modificata, allora effettuiamo un'altra iterazione del ciclo:
        \begin{itemize}
            \item Considerando $C \to D \in F$, notiamo che tale dipendenza è già soddisfatta
            \item Considerando $AB \to E \in F$, notiamo la prima, la seconda e la terza tupla sono uguali nel determinante $AB$, dunque modifichiamo $b_{1} \to a$ e $b_{4} \to a$ in modo che siano uguali nel determinato $E$
            \item Considerando $D \to B \in F$, notiamo che tale dipendenza è già soddisfatta
        \end{itemize}
        
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c|}
                \hline
                    & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E}\\
                \hline
                \textbf{AC} & $a$ & $b_{1}$ & $a$ & $a$ & $b_{1} \to a$\\
                \textbf{ADE} & $a$ & $b_{1}$ & $b_{2}$ & $a$ & $a$\\
                \textbf{CDE} & $b_{3}$ & $b_{1}$ & $a$ & $a$ & $a$\\
                \textbf{AD} & $a$ & $ b_{1}$ & $b_{4}$ & $a$ & $b_{4} \to a$\\
                \textbf{B} & $b_{5}$ & $a$ & $b_{5}$ & $b_{5}$ & $b_{5}$\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Siccome la tabella è stata modificata, allora effettuiamo un'altra iterazione del ciclo:
        \begin{itemize}
            \item Considerando $C \to D \in F$, notiamo che tale dipendenza è già soddisfatta
            \item Considerando $AB \to E \in F$, notiamo che tale dipendenza è già soddisfatta
            \item Considerando $D \to B \in F$, notiamo che tale dipendenza è già soddisfatta
        \end{itemize}
        
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c|}
                \hline
                    & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E}\\
                \hline
                \textbf{AC} & $a$ & $b_{1}$ & $a$ & $a$ & $a$\\
                \textbf{ADE} & $a$ & $b_{1}$ & $b_{2}$ & $a$ & $a$\\
                \textbf{CDE} & $b_{3}$ & $b_{1}$ & $a$ & $a$ & $a$\\
                \textbf{AD} & $a$ & $ b_{1}$ & $b_{4}$ & $a$ & $a$\\
                \textbf{B} & $b_{5}$ & $a$ & $b_{5}$ & $b_{5}$ & $b_{5}$\\
                \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item Siccome la tabella non è stata modificata, allora l'algoritmo termina stabilendo che $\rho$ non presenta un join senza perdita, poiché non esiste alcuna riga contenente tutti valori "$a$"
    \end{itemize}
    
    \quad
    
    
    \begin{framedthm}{Correttezza algoritmo \texttt{has\_lossless\_join}}
        Sia $R$ uno schema con decomposizione $\rho = R_1, \ldots, R_k$ e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        L'algoritmo \texttt{has\_lossless\_join(R,F,$\rho$)} determina che $\rho$ presenta un join senza perdita se e solo se esiste una tupla in $r$ contente tutte "$a$" una volta terminato
    \end{framedthm}
    
    \newpage

    \textit{Dimostrazione (solo un'implicazione):}
    
    \begin{itemize}
        \item Supponiamo che $\rho$ presenti un join senza perdita
        \item Siano $r^0$ e $r^f$ rispettivamente lo stato iniziale e lo stato finale dell'istanza $r$
        \item Per costruzione stessa di $r^0$, per ogni tupla $t_{R_i}^0 \in r^0$ si ha che $t_{R_i}^0[R_i] = ("a", \ldots, "a")$
        \item Siccome l'algoritmo non modifica mai una "$a$" in una "$b$", allora si ha che $t_{R_i}^0[R_i] = t_{R_i}^f[R_i] = ("a", \ldots, "a")$
        \item Sia quindi $t^a$ la tupla contenente tutte le "$a$". Per costruzione di $r$, si ha quindi che:
        \[ t^a \in t_{R_1}^f[R_1] \bowtie \ldots \bowtie t_{R_k}^f[R_k] \subseteq \pi_{R_1}(r^f) \bowtie \ldots \bowtie \pi_{R_k}(r^f) = m_{\rho}(r^f)\]
        \item Siccome l'istanza $r^f$ generata al termine dell'algoritmo è sempre legale, allora nel caso in cui $\rho$ presenti un join senza perdita si ha $t^a \in m_{\rho}(r^f)=r^f$
        
        $\hfill\qed$
    \end{itemize}
    
    \quad
    
    \subsection{Copertura minimale}
    
    \quad
    
    \begin{frameddefn}{Copertura minimale}
        Sia $R$ uno schema con decomposizione $\rho = R_1, \ldots, R_k$ e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Definiamo come \textbf{copertura minimale di $F$} un insieme di dipendenze $G$ tale che:
        \begin{itemize}
            \item $G \equiv F$
            \item $\forall X \to A \in G$ si ha che $A \in G$, ossia il determinato di ogni dipendenza è un attributo
            \item $\forall X \to A \in G, \nexists X' \subset X \mid G \equiv (G - \{X \to A\}) \cup \{X' \to A\})$, ossia non è possibile determinare funzionalmente $A$ tramite un sottoinsieme proprio di $X$ (rimozione determinanti ridondanti)
            \item $\nexists X \to A \in G \mid G \equiv G - \{X \to A\}$, ossia non è possibile determinare funzionalmente $A$ tramite altre dipendenze (rimozione dipendenze ridondanti)
        \end{itemize}
    \end{frameddefn}
    
    \newpage
    
    \begin{framedalgo}{Calcolare una copertura minimale}
        Sia $R$ uno schema con decomposizione $\rho = R_1, \ldots, R_k$ e sia $F$ un insieme di dipendenze funzionali definite su $R$.
        
        Per calcolare la copertura minimale di $F$ sono sufficienti i seguenti tre step:
        \begin{enumerate}
            \item Usando la regola della decomposizione, tutte le dipendenze vengono ridotte ad avere un singolo attributo come determinante 
            \item Ogni dipendenza funzionale $X \to A \in F$ dove $\exists X' \subset X \mid X \to A \in F$ tale che
            \[ G \equiv (G-\{X \to A\}) \cup \{X' \to A\}\]
            viene rimpiazzata direttamente con $X' \to A$ (o scartata se $X' \to A$ è già in F), ripetendo tale processo finché possibile.
            
            \item Ogni dipendenza $X \to A$ tale $G \equiv G - \{X \to A\}$ viene scartata
        \end{enumerate}
    \end{framedalgo}
    
    \begin{framedobs}{}
        Durante lo step 2), chiamiamo $F$ l'insieme di dipendenze originale, dunque contenente $X\to A$, mentre chiamiamo $F_r$ l'insieme ridotto, dunque contenente $X' \to A$.
        
        Siccome gli insiemi differiscono di una sola dipendenza, è sufficiente verificare che $X \to A \in F_r^+$ e che $X' \to A \in F^+$ affinché $F \equiv F_r$
        
        Tuttavia, non è necessario verificare se $X \to A \in F_r^+$, poiché:
        \[X' \subset X \implies X \to X' \in F_r^A=F_r^+\]
        
        e conseguentemente che:
        \[ X \to X', X' \to A \in F_r^A = F_r^+ \implies X \to A \in F_r^A = F_r^+\]
        
        Dunque, affinché $F \equiv F_r$ è \textbf{sufficiente verificare} che $X' \to A \in F^+$
    \end{framedobs}
    
    \begin{framedobs}{}
        Durante lo step 2), denotiamo come $F$ l'insieme di dipendenze originale e come $F_k$ l'insieme di dipendenze ridotto dopo aver effettuato $k$ riduzioni.
        
        Siccome affinché $F_1, \ldots, F_k$ siano riduzioni valide è necessario che $F_1 \equiv F, \ldots, F_k \equiv F$, allora è sufficiente verificare che $F_k \equiv F_{k-1}$ affinché $F_k$ sia una riduzione valida.
        
        Inoltre, è necessario sottolineare che $X_{F_{k-1}}^+ = X_{F_{k}}^+$, dunque \textbf{non è necessario ricalcolare le chiusure ad ogni riduzione}
    \end{framedobs}
    
    \begin{framedobs}{}
        Durante lo step 3), denotiamo come $F$ l'insieme contenente tutte le dipendenze $X \to A$ da scartare e $F_r$ l'insieme in cui esse sono scartate.
        
        Siccome $F_r \subseteq F \subseteq F^+ \iff F_r^+ \subseteq F^+$, è sufficiente verificare che ogni dipendenza $X \to A \in F$ scartata sia ancora in $F_r^+$, dunque che $X \to A \in F_r^+ \iff A \in X_{F_r}^+$, per affermare che $F \subseteq F_r^+ \iff F^+ \subseteq F_r^+$ e quindi conseguentemente che $F \equiv F_r$.
        
        Inoltre, ogni dipendenza $X \to A \in F$ tale che $\nexists Y \neq X \subseteq R \mid Y \neq A \in F$ ovviamente risulta non essere ridondante, poiché altrimenti $A$ non sarebbe determinato più da alcuna dipendenza, dunque \textbf{non è necessario} effettuare lo step 3) su tali dipendenze.
    \end{framedobs}
    
    \begin{framedobs}{}
        Durante lo step 3), denotiamo come $F$ l'insieme di dipendenze originale e come $F_k$ l'insieme di dipendenze ridotto dopo aver effettuato $k$ riduzioni.
        
        Siccome affinché $F_1, \ldots, F_k$ siano riduzioni valide è necessario che $F_1 \equiv F, \ldots, F_k \equiv F$, allora è sufficiente verificare che $F_k \equiv F_{k-1}$ affinché $F_k$ sia una riduzione valida.
        
        Tuttavia, è necessario sottolineare che in tal caso $X_{F_{k-1}}^+ \neq X_{F_k}^+$, poiché scartando le dipendenze cambia il comportamento dell'algoritmo per il calcolo di $X^+$, dunque ad ogni riduzione \textbf{è necessario ricalcolare le chiusure ad ogni riduzione}
    \end{framedobs}
    
    \textbf{Esempi:}
    
    \begin{enumerate}
        \item \begin{itemize}
            \item Vogliamo trovare la copertura minimale del seguente insieme di dipendenze funzionali $F = \{ AB \to CD, C \to E, AB \to E, ABC \to D\}$
            
            \item Prima di tutto, scomponiamo le dipendenze con la regola della decomposizione, ottenendo che:
            \[ F = \{AB \to C, AB \to D, C \to E, AB \to E, ABC \to D\}\]
            
            \item Consideriamo quindi la dipendenza $AB \to C \in F$ e verifichiamo se $A \to C, B \to C \in F^+$, dunque se $C \in A_F^+$ e se $C \in B_F^+$:
            
            \begin{itemize}
                \item $A_F^+ = A \implies C \notin A_F^+$
                \item $B_F^+ = B \implies C \notin B_F^+$
            \end{itemize}
            
            dunque, non possiamo rimpiazzare la dipendenza $AB \to C$
            
            \item Procedendo analogamente, verifichiamo che $A \to E, B \to E, A \to D, B \to D \notin F^+$, dunque ne traiamo che $AB \to E, AB \to D \in F$ non possano essere rimpiazzate
            
            \item Infine, considerando $ABC \to D \in F$, sappiamo gia che $AB \to D \in F \subseteq F^+$, dunque tale dipendenza può essere rimpiazzata data $AB \to D$ (e di conseguenza rimossa, poiché già presente in $F$)
            
            \item Al termine dello step 2), quindi, abbiamo che
            \[ F = \{AB \to C, AB \to D, C \to E, AB \to E\}\]
            
            \item Applichiamo quindi lo step 3)
            \begin{itemize}
                \item $C$ e $D$ sono determinati rispettivamente solo da $AB \to C$ e $AB \to D$, dunque tali dipendenze non possono essere rimosse
                \item Considerando $C \to E \in F$, verifichiamo se $E \in C_{F-\{C \to E\}}^+$ affinché $C \to E \in F-\{C \to E\}^+$. Siccome $E \notin C_{F-\{C \to E\}}^+ = C$, ne segue che $C \to E$ non possa essere scartata
                \item Considerando $AB \to E \in F$, verifichiamo se $E \in AB_{F-\{AB \to E\}}^+$ affinché $AB \to E \in F-\{AB \to E\}^+$. Siccome $E \in AB_{F-\{AB \to E\}}^+ = ABCDE$, ne segue che $AB \to E$ possa essere scartata
            \end{itemize}
            
            \item Infine, otteniamo che $F =  \{AB \to C, AB \to D, C \to E\}$ è la copertura minimale di $F$
        \end{itemize}
    
        \item \begin{itemize}
            \item Vogliamo trovare la copertura minimale del seguente insieme di dipendenze funzionali $F = \{ BC \to DE, C \to D, B \to D, E \to L, D \to A, BC \to AL\}$
            
            \item Prima di tutto, decomponiamo le dipendenze:
            \[F = \{ BC \to D, BC \to E, C \to D, B \to D, E \to L, D \to A, BC \to A, BC \to L\}\]
            
            \item Siccome $BC$ è l'unico determinante su cui potremmo applicare lo step due, calcoliamo $B_F^+ = ABD$ e $C_F^+ = ACD$, da cui otteniamo che:
            \begin{itemize}
                \item $BC \to D$ può essere scartata direttamente, poiché sia $B \to D$ sia $C \to D$ sono entrambe già in F
                \item $E \notin B_F^+ \implies B \to E \notin F^+$ (e anche $E \notin C_F^+ \implies C \to E \in F^+$), dunque $BC \to E$ non può essere rimpiazzata
                \item $A \in B_F^+ \implies B \to A \in F^+$ e $A \in C_F^+ \implies C \to A \in F^+$, dunque $BC \to A$ può essere rimpiazzata sia da $B \to A$ sia da $C \to A$ (dunque, in base alla scelta, otterremo due coperture minimali diverse). Nel nostro caso, sceglieremo $B \to A$
                \item Siccome $L \notin B_F^+ \implies B \to L \notin F^+$ e siccome $L \notin C_F^+ \implies C \to L \notin F^+$, la dipendenza $BC \to L$ non può essere rimpiazzata
            \end{itemize}
            
            \item Al termine dello step 2), quindi, abbiamo che
            \[F = \{ BC \to E, C \to D, B \to D, E \to L, D \to A, B \to A, BC \to L\}\]
            
            \item Procediamo quindi con lo step 3):
            \begin{itemize}
                \item Siccome $E$ è determinato solo da $BC \to E$, allora non possiamo scartare tale dipendenza
                \item Considerando $C \to D$, si ha che $D \notin C_{F-\{C \to D\}}^+ = C \iff C \to D \notin F-\{C \to D\}^+$, dunque $C \to D$ non può essere scartata
                \item Considerando $B \to D$, si ha che $D \notin B_{F-\{B \to D\}}^+ = BA \iff B \to D \notin F-\{B \to D\}^+$, dunque $B \to D$ non può essere scartata
                \item Considerando $E \to L$, si ha che $L \notin E_{F-\{E \to L\}}^+ = E \iff E \to L \notin F-\{E \to L\}^+$, dunque $E \to L$ non può essere scartata
                \item Considerando $D \to A$, si ha che $A \notin D_{F-\{D \to A\}}^+ = D \iff D \to A \notin F-\{D \to A\}^+$, dunque $D \to A$ non può essere scartata
                \item Considerando $B \to A$, si ha che $A \in B_{F-\{B \to A\}}^+ = BDA \iff B \to A \in F-\{B \to A\}^+$, dunque $B \to A$ può essere scartata
                \item Considerando $BC \to L$, si ha che $L \in BC_{F-\{B \to A, BC \to L\}}^+ = BCEDLA \iff BC \to L \in F-\{B \to A, BC \to D\}^+$, dunque $BC \to L$ può essere scartata
            \end{itemize}
            
            \item Infine, otteniamo che $F = \{ BC \to E, C \to D, B \to D, E \to L, D \to A\}$ è la copertura minimale
        \end{itemize}
    \end{enumerate}
    
    \subsection{Algoritmo di decomposizione}
    
    \quad
    
    \begin{framedalgo}{Algoritmo di decomposizione}
        Dato uno schema $R$ e un insieme $F$ una \textbf{copertura minimale} di dipendenze funzionali su $R$, il seguente algoritmo calcola in tempo polinomiale, dunque in $O(n^k)$, una decomposizione $\rho$ di $R$ tale che ogni sottoschema è in 3NF e $\rho$ preserva $F$:
        
        \texttt{def decompose\_R(R: set of attributes, F: minimal cover of dependencies):}
        
        \texttt{\qquad S, $\rho$ := $\emptyset$}
        
        \texttt{\qquad for A $\in$ R $\mid$ $\nexists$ X $\to$ B $\in$ F, A $\in$ X $\lor$ A = B:}
        
        \texttt{\qquad\qquad S := S $\cup$ A}
        
        \texttt{\qquad if S $\neq \emptyset$:}
        
        \texttt{\qquad\qquad R := R - S}
        
        \texttt{\qquad\qquad $\rho$ := $\rho$ $\cup $ \{S\}}
        
        \texttt{\qquad if $\exists$ X $\to$ A $\in$ F $\mid$ X $\cup$ A = R:}
        
        \texttt{\qquad\qquad $\rho$ := $\rho$ $\cup$ \{R\} }
        
        \texttt{\qquad else:}
        
        \texttt{\qquad\qquad for X $\to$ A $\in$ F:}
        
        \texttt{\qquad\qquad\qquad $\rho$ := $\rho$ $\cup$ \{XA\}}
        
        \texttt{\qquad return $\rho$}
    \end{framedalgo}
    
    \begin{framedthm}{Correttezza algoritmo \texttt{decompose\_R}}
        Sia $R$ uno schema e sia $F$ una copertura minimale di dipendenze funzionali definite su $R$.
        
        L'algoritmo \texttt{decompose\_R(R,F)} restituisce una decomposizione $\rho$ tale che ogni sottoschema di $\rho$ è in 3NF e $\rho$ preserva $F$
        
        \textit{(dimostrazione omessa)}
    \end{framedthm}
    
    \begin{framedprop}{Ottenere una buona decomposizione}
        Sia $R$ uno schema e sia $F$ una copertura minimale di dipendenze funzionali definite su $R$.
        
        Data la decomposizione $\rho$ ottenuta applicando l'algoritmo $\texttt{decompose\_R(R,F)}$, se $\exists K$ chiave di $R$ tale che $K \subseteq R_i$ dove $R_i \in \rho$, allora \textbf{$\rho$ è una buona decomposizione} (ossia preserva $F$, ha un join senza perdita ed è composta da sottoschemi in 3NF)
        
        Di conseguenza, \textbf{è sempre possibile ottenere una buona decomposizione} di uno schema applicando l'algoritmo $\texttt{decompose\_R(R,F)}$ e aggiungendo una chiave di $R$ alla decomposizione (a meno che non esista già un sottoschema contenente una chiave).
    \end{framedprop}
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Consideriamo lo schema $R=ABCDEH$ e l'insieme di dipendenze $F = \{ AB \to CD, C \to E, AB \to E, ABC \to D\}$
        
        \item Prima di tutto, verifichiamo l'unicità della chiave dello schema:
        
        \begin{enumerate}
            \item Troviamo prima l'intersezione
            \[ ABEH \cap ABCDH \cap ABCDH \cap ABCEH = ABH \]
            \item Vediamo se la chiusura dell'intersezione coincide con $R$
            \[ ABH^+ = ABCDEH = R \implies ABH \text{ è l'unica chiave di } R\]
        \end{enumerate}
        
        \item Poiché $ABH$ è l'unica chiave di $R$, notiamo subito che tale schema non è in 3NF, poiché la dipendenza $C \to E$ viola la condizione richiesta in quanto $C$ non è una superchiave ed $E$ non è un primo
        
        \item Cerchiamo quindi una copertura minimale di $F$, in modo da poter utilizzare l'algoritmo di decomposizione:
        
        \begin{enumerate}
            \item Decomponiamo tutte le dipendenze di $F$:
            \[F = \{ AB \to C, AB \to D, C \to E, AB \to E, ABC \to D\}\]
            
            \item Cerchiamo i determinanti ridondanti:
            \begin{itemize}
                \item $A \to C, B \to C \notin F^+$ poiché $C \notin A_F^+ = A$ e $C \notin B_F^+$, dunque $AB \to C$ non può essere ridotta
                \item $A \to D, B \to D \notin F^+$ poiché $D \notin A_F^+ = A$ e $D \notin B_F^+$, dunque $AB \to D$ non può essere ridotta
                \item $A \to E, B \to E \notin F^+$ poiché $E \notin A_F^+ = A$ e $E \notin B_F^+$, dunque $AB \to E$ non può essere ridotta
                \item $AB \to D, C \to D \in F \implies AB \to D, C \to D \in F^+$, dunque $ABC \to D$ può essere ridotta sia in $AB \to D$ sia in $C \to D$ e dunque scartata poiché entrambe sono già in $F$
                \item L'insieme di dipendenze senza determinanti ridondanti quindi sarà:
                \[ F = \{ AB \to C, AB \to D, C \to E, AB \to E\}\]
            \end{itemize}
            
            \item Cerchiamo quindi le dipendenze ridondanti:
            
            \begin{itemize}
                \item $C$ e $D$ sono determinati solo da $AB \to C$ e $AB \to D$, dunque non possono essere rimosse
                \item Considerando $C \to E$, si ha che $E \notin D_{F-\{C \to E\}}^+ = C \iff C \to E \notin F-\{C \to E\}^+$, dunque $C \to E$ non può essere scartata
                \item Considerando $AB \to E$, si ha che $E \in AB_{F-\{AB \to E\}}^+ = ABCDE \iff AB \to E \in F-\{AB \to E\}^+$, dunque $AB \to E$ può essere scartata
             \end{itemize}
             
            \item La copertura minimale di $F$ quindi sarà:
            \[ F = \{ AB \to C, AB \to D, C \to E\}\]
        \end{enumerate}
        
        \item A questo punto, possiamo applicare l'algoritmo di decomposizione:
        
        \begin{enumerate}
            \item L'attributo $H$ non compare in alcuna dipendenza, dunque $S := \{H\}$
            \item Siccome $S = \{H\} \neq \emptyset$, allora $R := R-S = ABCDEH - H = ABCDE$ e $\rho := \rho \cup S = \{H\}$
            \item Siccome $\nexists X \to A \in F \mid X \cup A = R = ABCDE$, allora entriamo nel ciclo for, dunque $\rho := \rho \cup \{ABC, ABD, CE\} = \{H, ABC, ABD, CE\}$
            \item La decomposizione $\rho$ ottenuta preserva $F$ e tutti i suoi sottoschemi sono in 3NF
        \end{enumerate}
        
        \item  Infine, affinché $\rho$ sia una buona decomposizione, dunque presenti anche un join senza perdita, è sufficiente aggiungere un sottoschema composto dalla chiave $ABH$ alla decomposizione $\rho$.
        
        Dunque, una buona decomposizione di $R$ con copertura minimale $F = \{ AB \to C, AB \to D, C \to E\}$ risulta essere:
        \[ \rho = \{H, ABC, ABD, CE, ABH\}\]
    \end{itemize}
    
    \addtocontents{toc}{\protect\newpage}
    \chapter{Organizzazione fisica}
    
    Abbiamo già accennato la differenza tra livello fisico e livello logico di un database. In questo capitolo verrà discusso il funzionamento interno del livello fisico con particolare attenzione sull'\textbf{organizzazione fisica dei dati}.
    
    Prima di tutto, è necessario descrivere le sotto-aree che compongono il livello fisico:
    
    \begin{itemize}
        \item \textbf{Hardware di archiviazione e progettazione fisica}:
        \begin{itemize}
            \item Gerarchia di archiviazione
            \item Interni di un Hard Disk
            \item Passaggio dai concetti logici ai concetti fisici
        \end{itemize}
        
        \item \textbf{Organizzazione dei record}:
        
        \begin{itemize}
            \item Puntatori
            \item Liste
        \end{itemize}
        
        \item \textbf{Organizzazione dei file}:
        \begin{itemize}
            \item Organizzazione con file heap
            \item Organizzazione sequenziale dei file
            \item Organizzazione casuale dei file (Hashing)
            \item Organizzazione indicizzata sequenziale dei file
            \item Organizzazione dei dati in lista
            \item Indici secondari e File invertiti
            \item B-trees e B$^+$-trees
        \end{itemize}
    \end{itemize}
    
    \newpage
    
    \section{Hardware di archiviazione e progettazione fisica}
    
    \quad
    
    \begin{frameddefn}{Gerarchia dell'archiviazione}
        
        L'\textbf{Archiviazione primaria} di un DBMS contiene i buffer del database e i codici in esecuzione delle applicazioni e del DBMS. Essa è composta da CPU, Cache, Memoria principale (composta a sua volta da vari banchi di RAM). 
        
        L'\textbf{Archiviazione secondaria} si occupa dell'archiviazione permanente dei dati attraverso vari Hard Disk (HDD) e Solid-state drive (SSD), memorizzando i file fisici contenenti i dati del database
    \end{frameddefn}
    
    \begin{center}
        \includegraphics[scale=0.55]{resources/images/hierarchy.png}
    \end{center}
    
    In particolare, ci concentreremo sul funzionamento interno di un Hard Disk, il quale è costituito da:
    \begin{itemize}
        \item Un \textbf{controller} interno che gestisce gli altri componenti e che gestisce le richieste di lettura/scrittura, mettendole in coda
        \item Piatti circolari magnetici assicurati su uno \textbf{spindle} (ossia un mandrino), il quale ruota a velocità costante
        \item Delle\textbf{ testine di lettura e scrittura} posizionate sui bracci di un attuatore. Quest'ultimo, muovendosi, posizionerà le testine sui piatti, andando a leggere o a scrivere dei dati.
    \end{itemize}
    
    \begin{center}
        \includegraphics[scale=0.525]{resources/images/hdd_internal.png}
    \end{center}
    
    \newpage
    
    \begin{framedobs}{}
         Leggere o scrivere un blocco di dati dai piatti, quindi, implica:
    
        \begin{itemize}
            \item Il posizionamento corretto dell'attuatore, il cui tempo impiegato viene detto \textbf{Seek time} (Seek)
            \item L'attesa della rotazione del disco affinché il settore richiesto si trovi sotto la testina di lettura e scrittura, il cui tempo impiegato viene detto \textbf{Rotation time} (ROT)
            \item Il trasferimento dei dati, il cui tempo viene detto \textbf{Transfer time}, dipendente dalla grandezza del blocco da leggere, ossia il \textbf{block size} (BS), e il rateo di trasferimento dei dati, ossia il \textbf{trasfer rate} (TR), influenzato dalla densità delle particelle magnetiche presenti sul disco e la velocità di rotazione del disco stesso
        \end{itemize}
    \end{framedobs}
    
    \begin{frameddefn}{Random Block Access e Sequential Block Access}
        Il tempo totale impiegato per completare una lettura o una scrittura viene detto \textbf{Service time}
        \[ \text{Service time } = \text{ Seek } + \text{ ROT } + \text{ Transfer time } = \text{ Seek } + \text{ ROT } + \frac{\text{BS}}{\text{TR}}\]
        
        Il tempo totale impiegato dall'hard disk a restituire una risposta è detto \textbf{Response time} ed è quindi composto dal Service time e il tempo necessario a mettere in coda la richiesta (\textbf{Queueing time}):
        \[ \text{Response time } = \text{ Service time } + \text{ Queueing time}\]
        
        Poiché il tempo di lettura e di scrittura dipende anche dalla posizione delle testine, distinguiamo in:
        \begin{itemize}
            \item Il tempo impiegato ad effettuare un \textbf{Random Block Access}, ossia il tempo impiegato ad accedere ad un blocco indipendentemente dal precedente accesso, dunque indipendentemente dalla posizione attuale della testina
            \[ T_{RBA} = \text{ Seek } + \frac{\text{ROT}}{2} + \frac{\text{BS}}{\text{TR}}\]
            
            \item Il tempo impiegato ad effettuare un \textbf{Sequential Block Access}, ossia il tempo impiegato ad accedere sequenzialmente ad un blocco con la testina già posizionata nel settore corretto
            \[ T_{SBA} = \frac{\text{ROT}}{2} + \frac{\text{BS}}{\text{TR}}\]
        \end{itemize}
    \end{frameddefn}
    
    \newpage
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Vogliamo sapere il tempo impiegato dalla lettura di un blocco 4096 Byte da HDD possedente le seguenti specifiche:
        \begin{itemize}
            \item Seek time medio: 8.9 ms
            \item Velocità dello spindle: 7200 rpm (rotazioni per minuto)
            \item Transfer rate: 150 MBps (MB al secondo)
        \end{itemize}
        
        \item Prima di tutto, calcoliamo il Rotation time, prima in minuti e poi in millisecondi:
        \[ ROT = \frac{1}{7200 \text{ rpm}} \text{ minutes} = \frac{60 \cdot 1000}{7200 \text{ rpm}} \text{ ms} \approx 8.33 \text{ ms} \]
        
        \item Successivamente, calcoliamo il tempo impiegato per un RBA ed un SBA:
        \[ T_{RBA} \approx 8.9 \text{ ms} + \frac{8.33}{2} \text{ ms} + \frac{4096 \text{ B}}{150 \cdot 2^{20}  \text{ Bps}} \text{ s} = 8.9 \text{ ms} + \frac{8.33}{2} \text{ ms} + 2.6 \cdot 10^{-5} \text{ s} \approx \]
        \[ \approx 8.9 \text{ ms} + 4.165 \text{ ms} + 2.6 \cdot 10^{-2} \text{ ms} \approx 13.09 \text{ ms} \]
        
        \[ T_{SBA} \approx \frac{8.33}{2} \text{ ms} + \frac{4096 \text{ B}}{150 \cdot 2^{20}  \text{ Bps}} \text{ s} \approx 4.165 \text{ ms} + 2.6 \cdot 10^{-2} \text{ ms} \approx 4.19 \text{ ms} \]
    \end{itemize}
    
    \quad
    
    \subsection{Passaggio dai concetti logici ai concetti fisici}
    
    \quad
    
    La seguente tabella racchiude i concetti inerenti alla "traduzione" dal modello concettuale di un database alla sua implementazione prima a livello relazionale e successivamente alla sua rappresentazione fisica
    
    \quad
    
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Modello concettuale} & \textbf{Modello relazionale}  & \textbf{Modello interno}\\
            \hline
            & & Dati oggetti o campi \\
            Tipo attributo e valore & Nome colonna e cella & (bit o caratteri \\
            & & rappresentanti uno\\
            & & specifico valore)\\
            \hline
            & & Record archiviato\\
            (Entità) Record & Riga o tupla & (collezione di\\
            & & dati oggetto)\\
            \hline
            (Entità) Tipo record & Tabella o relazione & File fisico o\\
            & & insieme di dati\\
            \hline
            Insieme di tipi di record & Insieme di tabelle & Database fisico\\
            & & (collezione di file)\\
            \hline
            Strutture dati logiche & Chiavi esterne & Strutture di archiviazione\\
            \hline
        \end{tabular}
    \end{center}
    
    \newpage
    
    \textbf{Modello concettuale}:
    
    \begin{center}
        \includegraphics[scale=0.9]{resources/images/conceptual.png}
    \end{center}
    
    \textbf{Modello logico}:
    
    \[\texttt{Supplier(\underline{SuppID}, SuppName, SuppAddress}\]
    
    \[\texttt{PurchaseOrder(\underline{PONo}, PODate, SuppID}\]
    
    \textbf{Modello interno}:
    
    \begin{center}
        \includegraphics[scale=0.85]{resources/images/internal.png}
    \end{center}
        
        
    Riassumendo, quindi, si ha che:
    \begin{itemize}
        \item Un database consiste in un insieme di file
        \item Ogni file può essere visto come una collezione di pagine di dimensione fissa
        \item Ogni pagina archivia più record (corrispondenti a tuple logiche)
        \item Un record consiste di più campi di dimensione fissa a variabile, rappresentanti gli attributi delle tuple
    \end{itemize}
    
    \newpage
    
    \section{Organizzazione dei file}
    
    Una volta studiato il comportamento di un HDD, vogliamo organizzare i file fisici sui piatti in modo da minimizzare al massimo il Seek time e ridurre il più possibile il Rotation time. Per ottenere ciò, ci basta minimizzare gli RBA e massimizzare gli SBA.
    
    \subsection{Organizzazione con file heap e file sequenziali}
    
    \quad
    
    \begin{framedmeth}{Organizzazione con file heap}
        \begin{itemize}
            \item È il modello di organizzazione dei file primaria più basilare
            \item I nuovi record vengono \textbf{inseriti alla fine del file}
            \item Non vi è relazione tra gli attributi dei record e la loro locazione fisica
            \item L'unica opzione per il recupero dei record è la \textbf{ricerca lineare} (ossia controllando sequenzialmente ogni record)
            \item Ad ogni record è associata una \textbf{chiave di ricerca} che lo identifica
            \item Per un file con $N$ blocchi, il \textbf{tempo medio impiegato per trovare un record} in base alla sua chiave univoca di ricerca è $\left \lceil \frac{N}{2} \right \rceil $ SBA
            \item Cercare record in base a chiavi di ricerca non univoche richiede la lettura dell'intero file, in modo da selezionare il record giusto
        \end{itemize}
    \end{framedmeth}
    
    \begin{framedmeth}{Organizzazione con file sequenziali}
        \begin{itemize}
            \item I record vengono \textbf{archiviati in ordine crescente} (o discendente) in base al valore della loro \textbf{chiave di ricerca}
            \item Essendo i record ordinati in base alla loro chiave di ricerca, viene utilizzata la \textbf{ricerca binaria}, rendendo il numero atteso di accessi ai blocchi necessari per recuperare un record pari a $\left \lceil \log_2(N) \right \rceil$ RBA, poiché i blocchi su cui si accede non sono sequenziali per natura stessa dell'algoritmo di ricerca binaria.
            \item Può essere utilizzata anche la \textbf{ricerca lineare}, rendendo il numero atteso di accessi ai blocchi necessari per recuperare un record pari a $\left \lceil \frac{N}{2} \right \rceil$ SBA, risultando tuttavia meno efficiente
            \item Aggiornare i file sequenziali è più laborioso rispetto all'aggiornamento di un file heap, poiché richiede il \textbf{riordinamento delle chiavi}. Per tale motivo, spesso vengono fatti più aggiornamenti simultaneamente
        \end{itemize}
        
    \end{framedmeth}
    
    \newpage
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Dato un numero di record record (NR) pari a 30000, un block size (BS) pari a 2048 Byte e un record size (RS) pari a 100 Byte, la quantità di record per blocco (RpB) è pari a:
        \[ \text{RpB} = \left \lfloor \frac{\text{BS}}{\text{RS}} \right \rfloor = \left \lfloor \frac{2048}{100} \right \rfloor = 20\]
        
        \item Dunque, il numero di blocchi (NB) necessari per archiviare i record è:
        \[ \text{NB} = \left \lceil \frac{\text{NR}}{\text{RpB}} \right \rceil = \left \lceil \frac{30000}{20} \right \rceil = 15000\]
        
        \item Se viene utilizzata la ricerca lineare, il valore atteso del numero di accessi ai blocchi (NA) sarà:
        \[ \text{NA} = \left \lceil \frac{\text{NB}}{2}\right \rceil = \left \lceil\frac{1500}{2} \right \rceil = 750 \text{ SBA}\]
        
        \item Se viene utilizzata la ricerca binaria, il valore atteso del numero di accessi ai blocchi (NA) sarà:
        \[ \text{NA} = \left \lceil \log_2(\text{NB})\right \rceil = \left \lceil \log_2(1500)\right \rceil = 11 \text{ RBA}\]
        
        \item Dunque, nonostante gli SBA richiedano molto meno tempo dei RBA, in questo caso il numero di RBA è talmente basso da rendere comunque più efficiente la ricerca binaria 
    \end{itemize}
    
    \subsection{Organizzazione con file hash}
    
    \quad
    
    \begin{framedmeth}{Organizzazione con file hash}
        \begin{itemize}
            \item Viene utilizzato un \textbf{algoritmo di hashing }per effettuare una conversione da chiave all'indirizzo fisico dove il record è archiviato
            \item Risulta più efficiente quando viene utilizzata una chiave primaria
            \item Poiché viene utilizzata una funzione di hash, non è garantito che tutte le chiavi vengano mappate a valori hash diversi, per via delle possibili collisioni, dunque vengono utilizzati dei "recipienti", detti \textbf{bucket}, che contengono tutti i record il cui hash generato coincide.
            \item Viene mantenuta salvata in memoria principale una \textbf{bucket directory}, ossia un insieme di record dove ogni entrata corrisponde ad un puntatore al primo blocco di un bucket associato. Ogni entrata è indicizzata da un valore assumibile dalla funzione di hash.
            \item L'algoritmo di hashing deve distribuire i record il più possibile in modo \textbf{uniforme}, spesso realizzata tramite l'operatore modulo (ad es: $\text{address(key$_i$)} = \text{key$_i$ } mod \text{ M}$)
        \end{itemize}
    \end{framedmeth}
    
    \newpage
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Consideriamo la seguente serie di chiavi, dove ognuna incrementa di 1 rispetto alla precedente, analizzando il loro comportamento utilizzando il mod 20 e il mod 23:
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Chiavi} & \textbf{Resto in mod 20} & \textbf{Resto in mod 23}\\
            \hline
                3000 & 00 & 10\\
                3001 & 01 & 11\\
                3002 & 02 & 12\\
                3003 & 03 & 13\\
                3004 & 04 & 14\\
                3005 & 05 & 15\\
                3006 & 06 & 16\\
                3007 & 07 & 17\\
                3008 & 08 & 18\\
                3009 & 09 & 19\\
                3010 & 10 & 20\\
                3011 & 11 & 21\\
                3012 & 12 & 22\\
            \hline
            \end{tabular}
        \end{center}
        
        \quad
        
        \item In tal caso, quindi, le chiavi risultano essere ben distribuite uniformemente nei vari recipienti
        
        \item Tuttavia, se l'incremento tra una chiave e l'altra fosse di 25, otterremmo una distribuzione poco uniforme nel caso del mod 20, poiché solo i recipienti 0, 5, 10 e 15 verrebbero utilizzati:
        
        \quad
        
        \begin{center}
            \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Chiavi} & \textbf{Resto in mod 20} & \textbf{Resto in mod 23}\\
            \hline
                3000 & 00 & 10\\
                3025 & 05 & 12\\
                3050 & 10 & 14\\
                3075 & 15 & 16\\
                3100 & 00 & 18\\
                3125 & 05 & 20\\
                3150 & 10 & 22\\
                3175 & 15 & 01\\
                3200 & 00 & 03\\
                3225 & 05 & 05\\
                3250 & 10 & 07\\
                3275 & 15 & 09\\
                3300 & 00 & 11\\
            \hline
            \end{tabular}
        \end{center}
    \end{itemize}
    
    \newpage
    
    \begin{framedobs}{}
        Se si ha una quantità di record mappati allo stesso bucket maggiore della capienza stabilita per il bucket stesso, allora il record viene considerato in \textbf{overflow}. La tecnica più utilizzata per la gestione degli overflow è la tecnica di \textbf{indirizzamento aperto}, dove gli overflow vengono archiviati nel primo slot disponibile
        
        L'\textbf{efficienza dell'algoritmo di hash} utilizzato è misurata in base al numero atteso di RBA e di SBA:
        \begin{itemize}
            \item \textbf{Recuperare un record non in overflow }richiede un singolo RBA per raggiungere l'indirizzo del primo blocco del bucket, ottenuto dall'algoritmo di hash, per poi (potenzialmente) eseguire uno o più SBA, poiché i record nello stesso bucket sono archiviati in modo sequenziale
            \item \textbf{Recuperare un record in overflow} richiede accessi ai blocchi aggiuntivi in base alla percentuale di record in overflow, dipendente dalla tecnica di hashing utilizzata, e in base alla tecnica adottata per gestirli
        \end{itemize}
            
        La scelta di un bucket size maggiore comporta la presenza di meno overflow, aumentando tuttavia la quantità di SBA da effettuare per recuperare i record non in overflow. Dunque, è necessario effettuare un \textbf{compromesso} tra le due cose.
    \end{framedobs}

    \begin{center}
        \includegraphics[scale=0.70]{resources/images/overflow_hash.png}
    \end{center}
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Supponiamo di avere un file di $1857000$ record (NR). Ogni record occupa $256$ byte (RS). Ogni blocco contiene $4096$ byte (BS). Un puntatore a blocco occupa $5$ byte (PS). Il file viene organizzato con una struttura hash con $300$ bucket (NBk). La funzione hash è valutata su un campo che è chiave.
        
        \item La quantità di puntatori per blocco della bucket directory corrisponde a:
        \[\text{PpB} = \left \lfloor \frac{\text{BS}}{\text{PS}} \right \rfloor = \left \lfloor \frac{4096}{5} \right \rfloor = 819\]
        
        \item Il numero di blocchi necessari per la bucket directory sarà:
        \[\text{NBpBD} = \left \lceil \frac{\text{NBk}}{\text{PpB}} \right \rceil = \left \lceil \frac{300}{819} \right \rceil = 1\]
        
        \item La quantità di record per blocco di ogni bucket corrisponde a:
        \[\text{RpB} = \left \lfloor \frac{\text{BS}-\text{PS}}{\text{RS}} \right \rfloor = \left \lfloor \frac{4096-5}{256} \right \rfloor = 15\]
        
        \item Il numero di record che verrà inserito in ogni bucket corrisponde a:
        \[\text{RpBk} = \left \lceil \frac{\text{NR}}{\text{NB}} \right \rceil = \left \lceil \frac{1857000}{300} \right \rceil = 6190\]
        
        \item Il numero di blocchi necessari per ogni bucket sarà:
        \[\text{NBpBk} = \left \lceil \frac{\text{RpBk}}{\text{RpB}} \right \rceil = \left \lceil \frac{6190}{15} \right \rceil = 413\]
        
        \item Il numero di blocchi complessivi necessari per poter contenere la bucket directory e tutti i bucket corrisponde a:
        \[\text{NB}_{\text{TOT}} = \text{NBk} \cdot \text{NBpBk} + \text{NBpBD} = 300 \cdot 413 + 1 = 123901\]
        
        \item Il numero medio di accessi per effettuare una ricerca sarà:
        \[NA = \left \lceil \frac{\text{NBpBk}}{2} \right \rceil = \left \lceil \frac{413}{2} \right \rceil = 207\]
    \end{itemize}
    
    \quad
    
    \subsection{Organizzazione con file indicizzati sequenziali (ISAM)}
    
    \quad
    
    \begin{framedmeth}{Organizzazione ISAM}
        \begin{itemize}
            \item Il \textbf{file principale} contenente i record è diviso in \textbf{partizioni}, ognuna corrispondente ad un blocco, ognuna rappresentata da un'\textbf{entrata} \texttt{<Chiave di} \texttt{ricerca primo record, Puntatore indirizzo fisico primo record>}, le quali vengono archiviate in un \textbf{file indice}.
            \item Il file principale e il file indice sono entrambi \textbf{ordinati} in base alle chiavi di ricerca presenti nelle loro entrate
            \item Il file indice può essere di tipo \textbf{denso}, dove esiste un'entrata per ogni possibile valore della chiave di ricerca, o di tipo \textbf{sparso}, dove esiste solo l'entrata del primo record di ogni partizione, implicando quindi che ogni entrata faccia riferimento ad un gruppo di record
        \end{itemize}
    \end{framedmeth}
    
    \newpage
    
    \begin{center}
        \includegraphics[scale=0.93]{resources/images/index.png}
    \end{center}
    
    \begin{framedobs}{}
        Dato un numero di blocchi del file principale pari a $\text{NB}_{\text{FP}}$ ed un numero di blocchi del file indice pari a $\text{NB}_{\text{FI}}$, l'\textbf{efficienza delle ricerche} risulta essere:
        \begin{itemize}
            \item \textbf{Ricerca lineare sul file principale}: $\text{NB}_{\text{FP}}$ SBA
            \item \textbf{Ricerca binaria sul file principale}: $\left \lceil \log_2(\text{NB}_{\text{FP}}) \right \rceil$ RBA
            \item \textbf{Ricerca binaria tramite file indice}: $\left \lceil \log_2(\text{NB}_{\text{FI}}) \right \rceil +1$ RBA, dove l'ultimo RBA è dovuto all'accesso al blocco dell'entrata trovata
        \end{itemize}
    \end{framedobs}
    
    \begin{framedobs}{}
        Effettuando la \textbf{ricerca binaria sul file indice}, se $k$ è la chiave del record che si sta cercando, $a$ e $b$ sono gli estremi dell'intervallo di chiavi del file indice che si sta considerando attualmente e $m$ è il valore medio di tale intervallo, allora:
        \begin{itemize}
            \item Se $k < m$ allora l'algoritmo controllerà l'insieme di chiavi compreso tra $[a, m-1]$, poiché la chiave $k$ \textbf{sicuramente non si trova all'interno del blocco} $m$
            \item Se $k = m$ allora l'algoritmo selezionerà tale blocco
            \item Se $k > m$ allora l'algoritmo controllerà l'insieme di chiavi compreso tra $[m, b]$, poiché la chiave $k$ \textbf{potrebbe essere all'interno del blocco} $m$
        \end{itemize}
    \end{framedobs}
    
    \newpage
    
    \textbf{Esempio:}
    \begin{itemize}
        \item È dato un file di $1750000$ record (NR). Ogni record occupa 130 byte (RS), di cui 35 per la chiave (KS). Un puntatore a blocco occupa 5 byte (PS). Un blocco di memoria contiene 2048 byte (BS). Utilizziamo un indice ISAM per organizzare i record di tale file.
        
        \item La quantità di record per blocco del file principale corrisponde a:
        \[\text{RpB} = \left \lfloor \frac{\text{BS}}{\text{RS}}\right \rfloor = \left \lfloor \frac{2048}{130}\right \rfloor = 15\]
        
        \item Il numero di blocchi necessari per il file principale corrisponde a:
        \[\text{NBpFP} = \left \lceil \frac{\text{NR}}{\text{RpB}}\right \rceil = \left \lceil \frac{1750000}{15} \right \rceil = 116667\]
        
        \item La dimensione di ogni entrata del file indice corrisponde a:
        \[\text{ES} = \text{KS } + \text{ PS} = 35+5 = 40\]
        
        \item La quantità di entrate per blocco corrisponde a:
        \[\text{EpB} = \left \lfloor \frac{\text{BS}}{\text{ES}}\right \rfloor = \left \lfloor \frac{2048}{40}\right \rfloor = 51\]
        
        \item Il numero di blocchi necessari per il file indice corrisponde a:
        \[\text{NBpFI} = \left \lceil \frac{\text{NBpFP}}{\text{EpB}}\right \rceil = \left \lceil \frac{116667}{51} \right \rceil = 2288\]
        
        \item Numero massimo di accessi necessari per effettuare una ricerca utilizzando la ricerca tramite file indice corrisponde a:
        \[\text{NA} = \lceil \log_2(\text{NBpFI}) \rceil +1= \lceil \log_2(2288)+1 \rceil+1 = 12+1 = 13\]
    \end{itemize}
    
    \quad
    
    \subsection{Organizzazione con B-Tree}
    
    \quad
    
    \begin{frameddefn}{Albero di ricerca ad m-vie}
        Un \textbf{albero di ricerca ad m-vie} è una generalizzazione del normale albero binario di ricerca, avente le seguenti proprietà:
        \begin{itemize}
            \item Ogni nodo può avere \textbf{da 1 ad $m-1$ valori chiave}
            \item Il \textbf{numero di sotto-alberi} di ogni nodo può variare da 0 a $i+1$, dove $i$ è il numero di valori chiave nel nodo.
            \item Il grado di ogni nodo (ossia il numero di figli) è al \textbf{massimo} $m$
            \item Le \textbf{chiavi interne al sottoalbero} puntato da un puntatore compreso tra due chiavi $k$ e $k'$ di un nodo possono assumere solo valori nell'intervallo aperto $(k, k')$
        \end{itemize}
    \end{frameddefn}
    
    \begin{center}
        \includegraphics[scale=0.5]{resources/images/B-tree-search.png}
    \end{center}
    
    \begin{frameddefn}{B-Tree}
        Un \textbf{B-Tree} è un albero di ricerca ad m-vie avente le seguenti proprietà aggiuntive:
        \begin{itemize}
            \item Ogni nodo ha al \textbf{massimo} $m$ nodi figli e massimo $m-1$ \textbf{chiavi}
            \item Ogni nodo (eccetto la radice e le foglie) ha \textbf{minimo} $d := \left \lceil \frac{m}{2} \right \rceil$ nodi figli e minimo $d-1$ \textbf{chiavi}, mentre la radice ha \textbf{minimo} due nodi figli (a meno che non sia essa stessa una foglia)
            \item Tutti i nodi foglia sono allo \textbf{stesso livello}
        \end{itemize}
    \end{frameddefn}
    
    \begin{framedmeth}{Organizzazione con B-Tree}
        Un B-Tree può essere utilizzato come un \textbf{file indice strutturato ad albero}:
        \begin{itemize}
            \item Ogni nodo corrisponde ad un \textbf{blocco} e, per via dei vincoli imposti dalle proprietà, essi sono sempre \textbf{carichi almeno a metà} (ossia almeno metà della loro capienza è occupata), implicando che esistano almeno $d$ nodi figli
            \item Ogni nodo contiene:
            \begin{itemize}
                \item Un \textbf{insieme di chiavi di ricerca}
                \item Un \textbf{insieme di puntatori ai nodi figli}
                \item Un \textbf{insieme di puntatori ai dati} che fanno riferimento ai blocchi del \textbf{file principale}, contenente i record
            \end{itemize}
            \item Per comodità, i \textbf{blocchi del file principale} vengono tutti puntati dai nodi posti al livello più basso dell'albero (i blocchi del file principale vengono archiviati separatamente, dunque essi non fanno parte del B-Tree)
        \end{itemize}
        
    \end{framedmeth}
    
    \textbf{Esempio:}
    
    \begin{itemize}
        \item Consideriamo un B-Tree a 5 vie, implicando che il numero massimo di nodi figli per ogni nodo sarà $5$, mentre il numero minimo di nodi figli per ogni nodo sia $\left \lceil \frac{5}{2} \right \rceil = 3$ (fatta eccezione per la radice, la quale avrà minimo $2$ figli, a meno che essa non sia una foglia)
        
        \begin{center}
            \includegraphics[scale=0.475]{resources/images/tree1.png}
        \end{center}
        
        \item Inserendo la chiave 10, procediamo come un normale inserimento di un alberi binario di ricerca, aggiungendo quindi 10 al figlio sinistro della radice
        
        \begin{center}
            \includegraphics[scale=0.475]{resources/images/tree2.png}
        \end{center}
        
        \newpage

        \item Nel caso in cui volessimo inserire la chiave 11, essa verrebbe posta all'interno del figlio sinistro, il quale tuttavia può avere una capienza massima pari a 5, dunque l'inserimento della chiave 11 porterebbe il nodo ad essere sovraccarico
        
        \begin{center}
            \includegraphics[scale=0.475]{resources/images/tree3.png}
        \end{center}
        
        \item Per poter inserire la chiave 11, quindi, è necessario separare il nodo a metà, aggiungendo un nuovo nodo figlio alla radice e muovendo i valori affinché le regole di un normale albero binario vengano rispettate (ad esempio, il puntatore al figlio destro di 8 e sinistro di 12 conterrà tutti i valori compresi tra 8 e 12)
        
        \begin{center}
            \includegraphics[scale=0.475]{resources/images/tree4.png}
        \end{center}
        
        \item Nel caso in cui volessimo rimuovere la chiave 8 dalla radice, saremmo costretti a spostare nella radice la chiave 3 o la chiave 10, in modo che possano rimpiazzare l'8 mantenendo le proprietà dell'albero di ricerca. Tuttavia, muovendo una delle due chiavi si otterrebbe che uno dei due nodi figli abbia meno del numero minimo di figli, ossia 3. Di conseguenza, l'unica soluzione è fondere i due nodi figli, senza spostare una delle due chiavi nella radice
        \begin{center}
            \includegraphics[scale=0.475]{resources/images/tree5.png}
        \end{center}
    \end{itemize}
    
    \begin{framedobs}{Ricerca dei record in un B-Tree}
        La \textbf{ricerca di record} all'interno di un B-Tree risulta essere simile a quella di un albero di ricerca normale:
        \begin{itemize}
            \item Partendo dalla radice, la ricerca viene effettuata \textbf{ricorsivamente}
            \item Se il valore chiave X desiderato viene trovato in un nodo, ad esempio $X$ corrisponde alla chiave $K_i$, allora il record corrispondente può essere acceduto tramite il puntatore ai dati $Pd_i$
            \item Se invece il valore non è presente nel nodo, allora si procede ricorsivamente tramite il puntatore al figlio $P_i$, dove $i$ è il valore più piccolo per cui $X < K_i +1$. Se $X > K_j, \forall K_j$ in un nodo, allora si procede col puntatore figlio $P_i+1$
        \end{itemize}
        
        Poiché nel caso peggiore viene traversato un intero ramo dell'albero fino al raggiungimento di una foglia, il \textbf{costo della ricerca} risulta essere $O(h-1+1)$, dove $h$ è l'\textbf{altezza dell'albero}, il -1 è dovuto alla presenza della radice nella RAM (dunque richiedendo nessun accesso ai blocchi) e il +1 è dovuto all'accesso ai blocchi finale al record puntato dal puntatore dati corrispondente alla chiave trovata
    \end{framedobs}
    
    \begin{framedprop}{Altezza di un B-Tree}
        Dato un B-Tree avente $N$ chiavi, posto $m$ il numero massimo di figli che un nodo possa avere e $d := \left \lceil \frac{m}{2} \right \rceil$ il numero minimo di figli che un nodo possa avere, l'\textbf{altezza} $h$ del B-Tree è compresa tra:
        \[\left \lceil \log_{m}(N+1)\right \rceil \leq h \leq \left \lfloor \log_{d} \left ( \frac{N+1}{2}\right ) \right \rfloor +1\]
        
        Dunque, l'\textbf{altezza massima} viene raggiunta quando l'albero possiede il \textbf{minimo numero di nodi}, mentre l'\textbf{altezza minima} quando possiede il \textbf{massimo numero di nodi}
    \end{framedprop}
    
    \textit{Dimostrazione:}
    
    \begin{itemize}
        \item Osserviamo che, per definizione stessa di B-Tree, ogni nodo possiede un numero di figli compreso tra $[d, m]$ e un numero di chiavi compreso tra $[d-1, m-1]$
        \item Sia $N$ il numero di chiavi nel B-Tree e sia $b$ il numero di nodi figli presenti nel B-Tree
        \item Osserviamo che il numero massimo di nodi dell'albero è raggiunto quando tutti i nodi hanno capienza massima, dunque quando ognuno di essi possiede $m$ figli (eccetto le foglie) e $m-1$ chiavi
        
        Per la natura ricorsiva dell'albero, quindi, si ha che:
        \[b_{max} = \sum_{i=0}^{h-1}m^i = \frac{m^{h}-1}{m-1}\]
        
        Dunque, siccome ogni nodo possiede massimo $m$ figli, si ha che:
        \[N_{max} = (m-1) \cdot b_{max} = (m-1) \cdot \frac{m^{h}-1}{m-1} = m^h-1\]
        
        \item Analogamente, il numero minimo di nodi dell'albero è raggiunto quando tutti i nodi hanno capienza minima, dunque quando la radice possiede due soli figli (dunque una sola chiave) mentre ogni nodo interno possiede $d$ figli e $d-1$ chiavi
        
        Per la natura ricorsiva dell'albero, quindi, si ha che:
        \[b_{min} = 1+2\sum_{i=0}^{h-2}d^i = 1+2\frac{d^{h-1}-1}{d-1}\]
        
        Dunque, siccome la radice possiede una chiave ed ogni nodo figlio possiede minimo $d$ chiavi, si ha che:
        \[N_{min} = 1+(d-1)(b_{min}-1) = 1+ (d-1) \left ( 1+2\frac{d^{h-1}-1}{d-1} -1\right ) = 2d^{h-1}-1\]
        
        \item In definitiva, quindi, concludiamo che
        \[  2d^{h-1}-1 \leq N \leq m^h-1\]
        
        da cui ricaviamo che:
        \[\left \lceil \log_{m}(N+1)\right \rceil \leq h \leq \left \lfloor \log_{d} \left ( \frac{N+1}{2}\right ) \right \rfloor +1\]

        $\hfill\qed$
    \end{itemize}
    
    \begin{framedobs}{Performance di un B-Tree}
        Data l'altezza $h$ di un B-Tree, si ha che:
        \begin{itemize}
            \item L'operazione \texttt{get(k)} impiega massimo $h$ accessi al disco
            \item L'operazione \texttt{put(k)} impiega massimo $3h+1$ accessi al disco
            \item L'operazione \texttt{remove(k)} impiega massimo $3h$ accessi al disco
        \end{itemize}
    \end{framedobs}
    
    \begin{frameddefn}{B$^+$-Tree}
        Un \textbf{B$^+$-Tree} è un B-Tree avente le seguenti proprietà aggiuntive:
        \begin{itemize}
            \item Tutti i valori chiave presenti in nodi non foglia sono \textbf{ripetuti} nei nodi foglia, in modo che ogni possibile  chiave dell'albero sia presente nei nodi foglia stessi
            \item I nodi di livello più alto contengono sottoinsiemi delle chiavi presenti nei nodi foglia
            \item Ogni nodo foglia ha un \textbf{puntatore aggiuntivo}, il quale punta ad un nodo foglia adiacente
        \end{itemize}
        
        Per via di tali proprietà, un B$^+$-Tree risulta essere più efficiente rispetto ad un normale B-Tree, poiché la sua altezza è generalmente inferiore
    \end{frameddefn}
    
    \begin{center}
        \includegraphics[scale=0.8]{resources/images/b+tree.png}
    \end{center}
    
    \textbf{Esempio:}
    
    \begin{enumerate}
    
        \item 
        \begin{itemize}
            \item Supponiamo di avere un file di $1700000$ record (NR). Ogni record occupa 250 byte (RS), di cui 45 per il campo chiave (KS). Ogni blocco contiene 2048 byte (BS). Un puntatore a blocco occupa 4 byte (PS). Utilizzando un'organizzazione B-tree, vogliamo sapere il minimo numero di accessi per effettuare una ricerca.
            
            \item Il minimo numero di accessi è raggiunto quanto l'altezza dell'albero è minima, dunque quando ogni nodo possiede il massimo numero di figli, implicando che ogni blocco sia carico al $100\%$,  
            
            \item Sia $d$ il numero minimo di figli di un nodo e sia $k_{min} := d-1$ il numero minimo di chiavi in un nodo
        \item Poiché il minimo numero di accessi necessari è raggiunto quando l'altezza dell'albero è minima, è necessario che l'albero sia carico al massimo. Sia $m$ il numero massimo di figli di un nodo e sia $k_{max} := m-1$ il numero massimo di chiavi in un nodo
        \item Il massimo numero di chiavi per nodo (dunque per blocco) corrisponde a:
        \[\text{BS} = k_{max}(\text{KS}+\text{PS})+\text{PS} \implies k_{max} = \left \lfloor \frac{\text{BS}-\text{PS}}{\text{KS}+\text{PS}} \right \rfloor\]
        da cui traiamo che il massimo numero di figli per nodo corrisponde a:
        \[ m = \left \lfloor \frac{\text{BS}-\text{PS}}{\text{KS}+\text{PS}} \right \rfloor +1 = \left \lfloor \frac{2048-4}{45+4} \right \rfloor +1 = 41+1 = 42\]
        
        \item La quantità di record per blocco del file principale corrisponde a:
        \[\text{RpB} = \left \lfloor \frac{\text{BS}}{\text{RS}}\right \rfloor = \left \lfloor \frac{2048}{250}\right \rfloor = 8\]
        
        \item Il numero di blocchi necessari per il file principale corrisponde a:
        \[\text{NBpFP} = \left \lceil \frac{\text{NR}}{\text{RpB}}\right \rceil = \left \lceil \frac{1700000}{8} \right \rceil = 21250\]
        
        \item Il numero di nodi/blocchi del livello L0 del file indice (ossia il più basso) corrisponde a:
        \[\text{NBpL0} = \left \lceil \frac{\text{NBpFP}}{\text{m}}\right \rceil = \left \lceil \frac{21250}{42} \right \rceil = 506\]
        
        \item Il numero di nodi/blocchi del livello L1 del file indice (ossia il penultimo) corrisponde a:
        \[\text{NBpL1} = \left \lceil \frac{\text{NBpL0}}{\text{m}}\right \rceil = \left \lceil \frac{506}{42} \right \rceil = 13\]
        
        \item Il numero di nodi/blocchi del  livello L2 del file indice corrisponde a:
        \[\text{NBpL2} = \left \lceil \frac{\text{NBpL1}}{\text{m}}\right \rceil = \left \lceil \frac{13}{42} \right \rceil =1\]
        
        \item Il livello L2, quindi, corrisponderà con la radice dell'albero, implicando che l'albero abbia un'altezza pari a $h = 3$. Dunque, il costo minimo di una ricerca sarà:
        \[\text{NA}_{min} = O(h) = 3\]
        
        \item Il numero di blocchi necessari per il file indice sarà:
        \[\text{NBpFI} = \text{NBpL0 } + \text{ NBpL1 } +\text{ NBpL2 } =21250 +506+13+1 =21770\]
        \end{itemize}

        \item \begin{itemize}
            \item Supponiamo di voler calcolare il massimo numero di accessi necessari ad effettuare una ricerca con gli stessi dati dell'esercizio precedente.
            
            \item Il massimo numero di accessi è raggiunto quanto l'altezza dell'albero è massima, dunque quando ogni nodo possiede il minimo numero di figli, implicando che ogni blocco sia carico al $50\%$
            \item Sia $d$ il numero minimo di figli di un nodo e sia $k_{min} := d-1$ il numero minimo di chiavi in un nodo
            
            \item Il minimo numero di chiavi per nodo (dunque per blocco) corrisponde a:
            \[\text{BS} \cdot 0.5 = k_{min}(\text{KS}+\text{PS})+\text{PS} \implies k_{min} = \left \lceil \frac{\text{BS} \cdot 0.5 - \text{PS}}{\text{KS} + \text{PS}}\right \rceil\]
            
            da cui traiamo che il minimo numero di figli per nodo corrisponde a:
            \[d = \left \lceil \frac{\text{BS} \cdot 0.5 - \text{PS}}{\text{KS} + \text{PS}}\right \rceil +1 = \left \lceil \frac{2048 \cdot 0.5 -4}{45+4} \right \rceil +1 = 21+1 = 22\]
            
            \item La quantità di record per blocco del file principale corrisponde a:
            \[\text{RpB} = \left \lfloor \frac{\text{BS} \cdot 0.5}{\text{RS}}\right \rfloor = \left \lfloor \frac{2048 \cdot 0.5}{250}\right \rfloor = 4\]
            
            \item Il numero di blocchi necessari per il file principale corrisponde a:
            \[\text{NBpFP} = \left \lceil \frac{\text{NR}}{\text{RpB}}\right \rceil = \left \lceil \frac{1700000}{4} \right \rceil = 42500\]
            
            \item Il numero di nodi/blocchi del livello L0 del file indice (ossia il più basso) corrisponde a:
            \[\text{NBpL0} = \left \lceil \frac{\text{NBpFP}}{\text{m}}\right \rceil = \left \lceil \frac{42500}{22} \right \rceil = 1932\]
            
            \item Il numero di nodi/blocchi del livello L1 del file indice (ossia il penultimo) corrisponde a:
            \[\text{NBpL1} = \left \lceil \frac{\text{NBpL0}}{\text{m}}\right \rceil = \left \lceil \frac{1932}{22} \right \rceil = 88\]
            
            \item Il numero di nodi/blocchi del  livello L2 del file indice corrisponde a:
            \[\text{NBpL2} = \left \lceil \frac{\text{NBpL1}}{\text{m}}\right \rceil = \left \lceil \frac{88}{22} \right \rceil = 4\]
            
            \item Il numero di nodi/blocchi del  livello L3 del file indice corrisponde a:
            \[\text{NBpL3} = \left \lceil \frac{\text{NBpL2}}{\text{m}}\right \rceil = \left \lceil \frac{4}{22} \right \rceil = 1\]
            
            \item Il livello L3, quindi, corrisponderà con la radice dell'albero, implicando che l'albero abbia un'altezza pari a $h = 4$. Dunque, il costo minimo di una ricerca sarà:
            \[\text{NA}_{max} = O(h) = 4\]
            
            \item Il numero di blocchi necessari per il file indice sarà:
            \[\text{NBpFI} = \text{NBpL0 } + \text{ NBpL1 } +\text{ NBpL2 } + \text{ NBpL3 } =\]
            \[ = 42500+1932+88+4+1 = 44525\]
        \end{itemize}
    \end{enumerate}
    
\end{document}

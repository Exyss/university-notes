\documentclass[a4paper, 12pt]{report}

\usepackage[dvipsnames]{xcolor}

%%%%%%%%%%%%%%%%
% Set Variables %
%%%%%%%%%%%%%%%%

\def\useItalian{1}  % 1 = Italian, 0 = English

\def\courseName{Sistemi Operativi II}

\def\coursePrerequisites{Apprendimento del materiale relativo al corso \textit{Sistemi Operativi I} e conoscenze discrete di programmazione.}

\def\book{\curlyquotes{Advanced Programming in the UNIX environment}, W. R. Stevens, S. A. Rago}

\def\authorName{Simone Bianco}
\def\email{bianco.simone@outlook.it}
\def\github{https://github.com/Exyss/university-notes}
\def\linkedin{https://www.linkedin.com/in/simone-bianco}


%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage{../../../packages/Nyx/nyx-packages}
\usepackage{../../../packages/Nyx/nyx-styles}
\usepackage{../../../packages/Nyx/nyx-frames}
\usepackage{../../../packages/Nyx/nyx-macros}
\usepackage{../../../packages/Nyx/nyx-title}
\usepackage{../../../packages/Nyx/nyx-intro}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{../../../packages/Nyx/logo.png}

\if\useItalian1
    \institute{\curlyquotes{\hspace{0.25mm}Sapienza} Università di Roma}
    \faculty{Ingegneria dell'Informazione,\\Informatica e Statistica}
    \department{Dipartimento di Informatica}
    \ifdefined\book
        \subtitle{Appunti integrati con il libro \book}
    \fi
    \author{\textit{Autore}\\\authorName}
\else
    \institute{\curlyquotes{\hspace{0.25mm}Sapienza} University of Rome}
    \faculty{Faculty of Information Engineering,\\Informatics and Statistics}
    \department{Department of Computer Science}
    \ifdefined\book
        \subtitle{Lecture notes integrated with the book \book}
    \fi
    \author{\textit{Author}\\\authorName}
\fi


\title{\courseName}
\date{\today}

% \supervisor{Linus \textsc{Torvalds}}
% \context{Well, I was bored\ldots}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
    \maketitle

    % The following style changes are valid only inside this scope 
    {
        \hypersetup{allcolors=black}
        \fancypagestyle{plain}{%
        \fancyhead{}        % clear all header fields
        \fancyfoot{}        % clear all header fields
        \fancyfoot[C]{\thepage}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}}

        \romantableofcontents
    }

    \introduction

    %%%%%%%%%%%%%%%%%%%%%

    \chapter{Introduzione all'ambiente Linux}

    \section{Breve storia di Unix}
    
    Il sistema operativo \tbf{Multics (Multiplexed Information and Computing Service)} fu uno dei primi sistemi operativi a \tbf{condivisione di tempo (time-sharing)}, ossia multi-processo e multi-utente, sviluppato attivamente a partire dal 1964 da parte dei centri di ricerca delle compagnie Bell Labs (AT\&T Corp., una compagnia telefonica americana) e General Electric, assieme all'università MIT. 
    
    Multics mise sul campo tutta una serie di concetti e tecniche costruttive che sono ancora oggi elementi essenziali dei moderni sistemi operativi. Sebben rivoluzionario, il progetto Multics fu presto abbandonato da Bell Labs, poiché ritenuto troppo complesso da gestire.
    
    A seguito di ciò, Ken Thompson e Dennis Ritche, due ricercatori di Bell Labs, svilupparono tramite un \tbf{microcomputer PDP-7} la prima versione di \tbf{Unics (Uniplexed Information and Computing Service)}, scritta totalmente in Assembly. Successivamente, sotto proposta di Brian Kernighan, il nome di Unics venne cambiato definitivamente in \tbf{Unix}.

    Il sistema operativo Unix si diffuse rapidamente nei successivi 3-5 anni, portandolo allo sviluppo di versioni scritte tramite il \tbf{linguaggio B} e successivamente (e definitivamente) tramite il \tbf{linguaggio C}. Le versioni scritte in tale linguaggio permisero di portare Unix su varie architetture.
    
    Il \tbf{linguaggio C} fu sviluppato da Dennis Ritchie stesso al fine di migliorare il linguaggio B precedentemente sviluppato dal suo collega Ken Thompson. La miglioria principale rispetto al B consiste nell'aggiunta dei \tbf{tipi di dato} (int, float, char, ...) rispetto alle sole generiche word da 4 byte del linguaggio B.

    Successivamente, il codice sorgente del sistema operativo Unix venne distribuito ad università e centri di ricerca interamente assieme al proprio codice sorgente, il quale venne anche venduto ad aziende private, portando alla nascita di molte versioni (System V AT\&T, BSD, Xenix, SunOS/Solaris, ...), tuttavia utilizzabili solo da personale specializzato su dei mainframe. Del corso del tempo, il supporto di AT\&T ad Unix iniziò a diminuire, portando le prime comunità di ricercatori e sviluppatori a prendere in mano il progetto.
    
    Negli anni 80', Richard Stallman sviluppò il sistema operativo \tbf{GNU (GNU is Not Unix - acronimo ricorsivo)}, basato su Unix ma diverso da esso in quanto non contenente codice del sistema operativo Unix, e inventò \tbf{GPL (GNU General Public Licence)}, una licenza pubblica utilizzata per il \tbf{software libero}. Unix venne inoltre riscritto completamente, aggiungendo pacchetti importanti ad esso, molti presi direttamente da GNU (es: gcc, make, ...). 

    Negli anni 90', Linus Torvalds sviluppa il \tbf{kernel Linux}, il quale verrà poi utilizzato da altri sistemi operativi basati su Unix o derivati da esso. In particolare, nel 1994 viene definito lo \tbf{standard Unix}, dove un sistema operativo può avere marchio UNIX solo se esso rispetta le \tbf{SUS (Single Unix Specification)} e paga le royalties per l'uso del marchio.

    Attualmente, i vari sistemi Unix rientrano in tre categorie:
    \begin{itemize}
        \item \tbf{Generic Unix}, ossia sistemi Unix che provengono da quello originale o da lui derivati
        \item \tbf{Trademark Unix}, ossia i sistemi che rientrano nelle specifiche SUS e pagano per il marchio UNIX
        \item \tbf{Functional Unix}, ossia sistemi operativi che si ispirano a Unix (detti anche \tbf{Unix-based}), come GNU e GNU/Linux, ossia la versione di GNU utilizzante kernel Linux (\tit{erroneamente} definita direttamente come sistema operativo Linux nel linguaggio comune - ricordiamo che Linux è solamente il kernel, non l'intero sistema operativo). I sistemi operativi derivanti da Linux (o meglio, da GNU/Linux) sono utilizzati ovunque.
    \end{itemize}
    
    Le caratteristiche di un moderno sistema operativo Unix, indipendentemente dalla sua categoria, sono:
    \begin{itemize}
        \item \tbf{Multi-utente} e \tbf{multi-processo}
        \item \tbf{File system gerarchico}
        \item \tbf{Kernel} in grado di gestire la memoria principale, la memoria secondaria, i processi, le operazioni I/O e le risorse hardware in generale
        \item \tbf{System call} utilizzabili tramite funzioni C che possono essere chiamate per interfacciarsi con il kernel
        \item Possiedono una \tbf{shell di sistema}, ossia un programma che "esegue programmi" interpretando i comandi dell'utente
        \item Modularità, programmi di utilità e supporto ad ambienti di programmazione
        \item Composto da una \tbf{serie di piccoli programmi} che eseguono un compito specifico, limitato, ma in maniera esatta e semplice
        \item I programmi sono silenziosi, il loro output è \tbf{minimale e ridotto} a ciò che è stato esplicitamente richiesto
        \item Ogni lavoro complesso può essere svolto come articolazione del lavoro svolto da programmi semplici
        \item I programmi manipolano \tbf{solo testo e mai i file binari} (es: altri programmi)
    \end{itemize}

    \begin{framedprop}{File e Processi}
        Nei sistemi operativi Unix, \tbf{qualsiasi risorsa} può essere rappresentata come un \tbf{file}, indipendentemente dall'essere una risorsa hardware o software (es: è possibile interagire con un dispositivo hardware tramite il file che lo rappresenta), o come \tbf{processo}.
    \end{framedprop}

    \quad

    \section{Utilizzo della Shell di sistema}

    \begin{frameddefn}{Shell di sistema}
        Informalmente, una \tbf{shell di sistema} (spesso detta \tbf{terminale}) è un programma che "esegue programmi".
        
        Più formalmente, invece, la shell è un programma interattivo e/o batch (ossia "a lotti") che accetta \tbf{comandi da far eseguire al kernel} (pertanto il suo nome, in quanto \tit{shell} tradotto sia \tit{guscio} e \tit{kernel} tradotto sia \tit{nucleo}). 
        
        Tali comandi non sono necessariamente dei programmi, bensì possono essere anche dei comandi definiti all'interno della shell stessa.
    \end{frameddefn}

    Esistono vari tipi di shell:
    \begin{itemize}
        \item \ttt{sh}, la prima shell inventata da Thompson e Bourne
        \item \ttt{bash}, una versione migliorata di \ttt{sh} (il nome deriva da Bourne Again Shell, un gioco di parole tra le parole \tit{Bourne} e \tit{Born})
        \item \ttt{ksh} (KornShell)
        \item \ttt{fish} (Friendly Interactive Shell)
        \item ...
    \end{itemize}

    In particolare, nei capitoli e sezioni successive considereremo l'uso della shell \ttt{bash}.

    \newpage

    Per utilizzare \ttt{bash} (o una qualsiasi altra shell), è necessario eseguire quello che viene comunemente detto \tbf{terminale} (es: programmi come \ttt{tty}, \ttt{kitty}, \ttt{alacritty}, ...). 

    \quad

    \begin{center}
        \includegraphics[scale=0.8]{images/shell_1.png}
    \end{center}

    Prima di eseguire un comando, la shell stampa a video un \tbf{prompt}, ossia una stringa nel formato
    \[\ttt{[nome\_utente@nome\_macchina cwd]\$}\]

    dove \ttt{cwd} è la \tbf{current working directory}
    
    \begin{frameddefn}{Current Working Directory}
        Definiamo come \tbf{current working directory di una shell (cwd)} la cartella attualmente "aperta" all'interno della shell stessa.
        
        Se la \ttt{cwd} è impostata sulla home dell'utente attivo (ossia \ttt{/home/nome\_utente}), essa verrà sostituita direttamente dal simbolo $\sim$.
    \end{frameddefn}

    Ogni \tbf{comando} segue la seguente struttura
    \[\ttt{nome\_comando [argomenti\_opzionali] argomenti\_obbligatori}\]
    Ad esempio, nel comando \ttt{cp -r -i -a -u file\_sorgente file\_destinazione}, gli \tbf{argomenti} \ttt{-r, -i, -a, -u} sono \tbf{opzionali}, mentre i rimanenti sono \tbf{obbligatori}. Tipicamente, gli argomenti opzionali possono essere utilizzati anche con \tbf{sintassi alternative} (es: per il comando \ttt{cp} gli argomenti \ttt{--interactive, --recursive} sono uguali agli argomenti \ttt{-i, -r}). Inoltre, eventualmente essi possono avere un \tbf{valore aggiuntivo} in input (es: l'argomento \ttt{--key=1} assegna il valore 1 all'argomento \ttt{--key}) e possono essere \tbf{raggruppati} (es: \ttt{cp -ri} è equivalente a \ttt{cp -r -i}).

    \newpage

    Tutti i comandi lanciati nella shell vengono salvati in una \tbf{cronologia}. Utilizzando le freccette su e giù della tastiera, è possibile scorrere i comandi presenti nella cronologia.

    Sebbene siano più o meno simili, ogni comando/programma eseguibile tramite shell segue una propria struttura per gli argomenti opzionali ed obbligatori. Tramite il comando \tbf{\ttt{man nome\_comando}} è possibile aprire la \tbf{pagina del manuale} relativa al comando \ttt{nome\_comando}.

    Ad esempio, eseguendo il comando \ttt{man cp} verrà visualizzata la seguente pagina del manuale:

    \quad

    \begin{center}
        \includegraphics[scale=0.7]{images/man.png}
    \end{center}

    Il manuale possiede un totale di \tbf{9 sezioni}:
    \begin{enumerate}
        \item Programmi eseguibili e comandi shell
        \item System call fornite dal kernel
        \item Library calls fornite dalle librerie dei programmi
        \item File speciali (solitamente situati nella cartella \ttt{/dev/})
        \item Formati dei file e convenzioni
        \item Informazioni su giochi comuni
        \item Varie informazioni
        \item Comandi di amministrazione di sistema
        \item Routine del kernel (non standard)
    \end{enumerate}
    
    È possibile specificare la \tbf{sezione} della pagina che si vuole aprire aggiungendo il numero di sezione come parametro opzionale. Se tale sezione non esiste, verrà comunicato (es: non esiste una sezione 2 per la pagina del comando \ttt{cp}, dunque \ttt{man 2 cp} restituirà solamente un messaggio di avviso). Se non viene specificata la sezione da aprire, verrà aperta la sezione di default (solitamente la sezione 1).

    \quad

    \section{Utenti e Gruppi del sistema}

    Durante l'installazione di un qualsiasi sistema operativo Linux-based è necessario specificare almeno un \tbf{utente}, il quale sarà l'\tbf{utente principale}. Alcune distribuzioni creano un utente automaticamente. Per creare un nuovo utente, è possibile utilizzare il comando \ttt{adduser nome\_nuovo\_utente}. Ogni utente è identificato univocamente da un valore intero detto \tbf{User ID (UID)}.

    Gli utenti possono appartenere a dei \tbf{gruppi utente}. In particolare, ogni utente appartiene ad almeno un gruppo, ossia il gruppo avente lo stesso nome dell'utente principale, generato automaticamente alla creazione dell'utente stesso. Per ogni gruppo possono essere impostati \tbf{privilegi diversi}. Inoltre, come per gli utenti, ogni gruppo è identificato univocamente da un \tbf{Group ID (GID)}.
    
    Per listare i gruppi a cui appartiene un utente, è possibile utilizzare il comando \ttt{groups [nome\_utente]}, mentre per aggiungere un utente ad un gruppo è possibile utilizzare il comando \ttt{adduser nome\_utente nome\_gruppo}.

    \begin{frameddefn}{Super utente (root)}
        Ogni sistema operativo Linux-based possiede un \tbf{super utente} detto \tbf{root}, il quale possiede \tbf{tutti i privilegi di sistema}. Pertanto, tale utente possiede accesso ad ogni operazione o comando possibile all'interno del sistema stesso.
        
        L'utente \ttt{root} possiede sempre UID pari a 0.
    \end{frameddefn}
    
    È necessario notare che non tutti gli utenti possono effettuare il login nel sistema. Ad esempio, l'utente root non può effettuare il login, ma un utente può acquisire i diritti di root tramite i comandi \tbf{\ttt{su}} e \tbf{\ttt{sudo}}.

    Gli utenti appartenenti al \tbf{gruppo sudo} (un gruppo predefinito speciale) vengono detti \tbf{sudoer} e sono in grado di eseguire il comando \ttt{sudo nome\_comando}, il quale permette loro di eseguire il comando dato \tbf{impersonando root}. In alcune distribuzioni della famiglia Ubuntu, l'utente principale è già un \tit{sudoer}.
    
    Per \tbf{cambiare utente}, invece, è possibile utilizzare il comando \ttt{su [-l] nome\_utente} (solitamente utilizzato per cambiare utente attivo in root). Inoltre, l'opzione \ttt{[-c command]} del comando \ttt{su} permette di eseguire un singolo comando impersonando l'utente dato, invece di cambiare utente. Per tanto, è possibile ottenere tramite \ttt{su -c command root} lo stesso effetto del comando \ttt{sudo command}.


    \newpage

    \chapter{File System}

    \section{Introduzione al file system Linux}

    \begin{frameddefn}{File system}
        Col termine \tbf{file system} si intende una struttura dati atta all'organizzazione di un'area di memoria di massa basata sul concetto di \tbf{file} e di \tbf{directory}, dove quest'ultime possono contenere al loro interno dei file ed altre directory, creando così una \tbf{struttura gerarchica ad albero}, dove solo le directory possono avere figli e i file corrispondono alle foglie dell'albero.
    \end{frameddefn}

    Come già espresso nel capitolo precedente, nei sistemi operativi Linux-based \tbf{ogni cosa può essere rappresentata come un file o un processo}. Per tanto, all'interno del file system è necessario distinguere tra \tbf{file regolari}, i quali contengono sequenze di bit dell'area di memoria sulla quale è installato il file system, e \tbf{file non regolari}, ad esempio utilizzati per l'accesso di basso livello a periferiche o dispositivi vari.

    Inoltre, all'interno di una directory valgono le seguenti regole:
    \begin{itemize}
        \item Non possono esistere due file o due sotto-directory con lo stesso nome
        \item Non possono esistere un file ed una sotto-directory con lo stesso nome
        \item I nomi dei file e delle sotto-directory sono \tbf{case sensitive} (es: \ttt{ciao.txt} è diverso da \ttt{Ciao.txt})
    \end{itemize}

    Nei sistemi operativi Unix-based e Linux-based vi è \tbf{un solo file system principale} avente una \tbf{directory radice (root directory)}, ossia la directory \ttt{/}. Essendo la radice del file system, ogni altro file o directory è contenuto direttamente o indirettamente all'interno della root directory.
    
    \newpage
    
    Pertanto, ogni file o directory è raggiungibile dalla root directory mediante un \tbf{percorso (path)}, il quale può essere di due tipologie:
    \begin{itemize}
        \item \tbf{Percorso assoluto}, ossia una sequenza di directory separate da uno / che specifica la posizione di un file o una directory a partire dalla root directory
        
        (es: \ttt{/home/utente/dir/subdir/file.pdf})
        
        \item \tbf{Percorso relativo}, ossia una sequenza di directory separate da uno / che specifica la posizione di un file o una directory a partire dalla \tbf{current working directory (cwd)}, ossia la cartella attualmente "aperta"
        
        (es: se la cwd è \ttt{/home/utente} allora il percorso relativo \ttt{dir/subdir/file.pdf} è equivalente al percorso assoluto \ttt{/home/utente/dir/subdir/file.pdf})
    \end{itemize}

    \begin{framedobs}{}
        Ogni percorso relativo risulta essere valido \tbf{solo se la cwd attuale è corretta}, mentre ogni percorso assoluto risulta essere \tbf{valido indipendentemente dalla cwd}.
    \end{framedobs}
        
    Inoltre, è necessario puntualizzare che, come accennato nel capitolo precedente, il simbolo $\sim$ sia un abbreviativo del percorso \ttt{/home/utente} (se l'utente che usa tale simbolo si chiama effettivamente \ttt{utente}). Per tanto, i percorsi avente $\sim$ come prefisso, sebben sembrino dei percorsi relativi, risultano essere effettivamente dei percorsi assoluti.
    
    (es: per l'utente \ttt{marco}, il percorso \ttt{$\sim$/ciao.txt} equivale a \ttt{/home/marco/ciao.txt})

    All'interno dei percorsi (sia assoluti che relativi) è possibile utilizzare due \tbf{directory speciali} presenti all'interno di ogni directory:
    \begin{itemize}
        \item La \tbf{current directory} (ossia \ttt{.}), corrispondente alla directory stessa in cui ci si trova
        
        (es: il percorso \ttt{$\sim$/dir/./ciao.txt} è equivalente a \ttt{$\sim$/dir/ciao.txt})
        \item La \tbf{parent directory} (ossia \ttt{..}), corrispondente alla directory direttamente superiore a quella in cui ci si trova
        
        (es: se la cwd attuale è \ttt{$\sim$/dir/subdir1/}, il percorso \ttt{../subdir2} è equivalente al percorso \ttt{$\sim$/dir/subdir2})
    \end{itemize}

    Per \tbf{sapere la cwd attuale}, è possibile utilizzare il comando \ttt{pwd}, mentre per \tbf{cambiare cwd} è possibile utilizzare il comando \ttt{cd [path]} (se l'argomento \ttt{path} viene omesso, la cwd verrà impostata sulla home dell'utente, ossia\ttt{ $\sim$/}).

    Per \tbf{visualizzare il contenuto di una directory}, invece, è possibile utilizzare il comando \ttt{ls [path]}, restituente una lista dei file e le sotto-directory contenute in una directory (se l'argomento \ttt{path} viene omesso, viene utilizzata la cwd come path). Se si vuole visualizzare \tbf{ricorsivamente} il contenuto della directory (dunque eseguendo ricorsivamente \ttt{ls} sulle sotto-directory), è possibile utilizzare l'argomento opzionale \ttt{-R}.

    In una directory alcuni file possono essere \tbf{nascosti}, tipicamente file di configurazione o file usati come supporto a comandi ed applicazioni (es: il file \ttt{.bash\_history} contiene la cronologia dei comandi eseguiti), i quali tuttavia non sono realmente invisibili, bensì essi vengono solamente omessi nell'output del comando \ttt{ls}, a meno che non venga utilizzato il parametro opzionale \ttt{-a} (dunque il comando \ttt{ls -a}). Un file può essere reso nascosto semplicemente aggiungendo un punto all'inizio del nome.
    
    (es: il file \ttt{ciao.txt} può essere reso nascosto cambiando il suo nome in \ttt{.ciao.txt})

    \quad

    \begin{center}
        \includegraphics[scale=1]{images/ls.png}
    \end{center}

    Similmente a \ttt{ls -R}, il comando \ttt{tree [path]} permette di listare il ricorsivamente il contenuto di una directory, ma sotto forma di albero.

    \quad

    \begin{center}
        \includegraphics[scale=1]{images/tree.png}
    \end{center}

    Per \tbf{creare una directory}, è possibile utilizzare il comando \ttt{mkdir nome\_dir}. Utilizzando l'opzione \ttt{-p}, verranno create a catena tutte le sotto-directory del percorso indicato.

    (es: \ttt{mkdir -p dir1/dir2/dir3} crea anche le directory \ttt{dir1} e \ttt{dir1/dir2})

    Per \tbf{creare un file vuoto}, invece, è possibile utilizzare il comando \ttt{touch nome\_file}, il quale potrà poi essere modificato utilizzando un editor di testo (come \ttt{nano}, \ttt{vim}, ...).

    Per \tbf{copiare un file}, è possibile utilizzare il comando \ttt{cp [-r] [-i] [-u] src\_file dest\_file}, dove:
    \begin{itemize}
        \item L'opzione \ttt{[-r]} permette di effettuare una copia ricorsiva sulle directory
        \item L'opzione \ttt{[-i]} avvisa l'utente nel caso in cui il file di destinazione esista gia
        \item L'opzione \ttt{[-u]} effettua la sovrascrittura di un file già esistente solo se l'\ttt{mtime} del file sorgente è più recente di quello di destinazione
    \end{itemize}

    Per \tbf{spostare (o rinominare) un file} è possibile utilizzare il comando \ttt{mv [-i] [-u] [-f] src\_file dest\_file}, dove:

    \begin{itemize}
        \item Le opzioni \ttt{[-i]} e \ttt{[-u]} sono identiche a quelle del comando \ttt{cp}
        \item L'opzione \ttt{[-f]} forza l'operazione
    \end{itemize}

    Per \tbf{eliminare un file} è possibile utilizzare il comando \ttt{rm [-r] [-i] [-f] src\_file dest\_file}, dove:
    \begin{itemize}
        \item Le opzioni \ttt{[-r]} e \ttt{[-i]} sono identiche a quelle del comando \ttt{cp}
        \item L'opzione \ttt{[-f]} forza l'operazione è identica a quella del comando \ttt{mv}
    \end{itemize}
        
    \begin{framedobs}{}
        A differenza del sistema operativo Windows, nei sistemi Linux-based \underline{non esiste} il "cestino". Per tanto, eseguendo il comando \ttt{rm} il file verrà completamente eliminato dal disco. 
    \end{framedobs}

    Per \tbf{convertire o copiare file} in modo avanzato, è possibile utilizzare il comando \ttt{dd [opt]} dove l'argomento \ttt{[opt]} è una sequenza di entrate nel formato \ttt{variabile=valore}. Le variabili principali utilizzabili sono:
    \begin{itemize}
        \item \ttt{if}, ossia il file di input (se non specificato, l'input viene letto da tastiera)
        \item \ttt{of}, ossia il file di output (se non specificato, l'output viene scritto sul terminale)
        \item \ttt{bs}, ossia la dimensione di un singolo blocco in lettura/scrittura
        \item \ttt{count}, ossia il numero di blocchi da copiare
        \item \ttt{skip}, ossia il numero di blocchi da saltare nell'input prima di leggere effettivamente
        \item \ttt{seek}, ossia il numero di blocchi da saltare nell'output prima di scrivere effettivamente (dunque il numero di blocchi da scartare da quelli letti in input)
    \end{itemize}

    \tbf{Esempio:}

    \begin{itemize}
        \item Il comando \ttt{dd if=filein of=fileout bs=1 skip=1 count=100} salta un carattere (1 blocco da 1 carattere), per poi leggere 100 caratteri (100 blocchi da 1 carattere)
        \item Il comando \ttt{dd if=filein of=fileout bs=100 skip=1 count=1} salta 100 caratteri (1 blocco da 100 caratteri), per poi leggere 100 caratteri (1 blocco da 100 caratteri)
        \item Il comando \ttt{dd if=filein of=fileout bs=100 seek=1 count=1} legge 100 caratteri (1 blocco da 100 caratteri), per poi scartare 100 caratteri da quelli letti (1 blocco da 100 caratteri)
    \end{itemize}

    \newpage

    \section{Mounting, Partizioni e Tipi di file system}

    Il file system principale (ossia \ttt{/}) può contenere al suo interno elementi \tbf{eterogenei} tra loro, ad esempio:
    \begin{itemize}
        \item Dischi interni solidi o magnetici, solitamente contenenti il file system root
        \item File system su disco esterno
        \item File system di rete
        \item File system virtuali 
        \item File system in memoria principale
    \end{itemize}

    \begin{frameddefn}{Mounting}
        Una qualsiasi directory $D$ all'interno del file system root può diventare il \tbf{punto di mount} per un altro file system $F$ se e solo se la directory di root $R_F$ del file system $F$ diventa accessibile da $F$.
    \end{frameddefn}

    \tbf{Esempio:}

    \begin{itemize}
        \item Consideriamo il seguente file system root e il seguente file system presente su una chiavetta USB
    \end{itemize}

    \begin{center}
        \begin{tabular}{ccc}
            \includegraphics[scale=0.2]{images/mount_1.png}
            & \qquad\qquad &
            \includegraphics[scale=0.2]{images/mount_2.png}
        \end{tabular}
    \end{center}
    
    \begin{itemize}
        \item Effettuando il mounting del secondo file system sulla directory \ttt{/mount} del file system root, esso diventa accessibile tramite la directory stessa
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.19]{images/mount_3.png}
    \end{center}

    \begin{framedobs}{}
        Effettuare il mounting di un file system $F$ su una directory $D$ \underline{non sovrascrive} il contenuto della directory, bensì esso viene solamente \tbf{temporaneamente sostituito}.

        Per tanto, se la directory $D$ non è vuota, il suo contenuto originale sarà nuovamente accessibile dopo l'unmount di $F$
    \end{framedobs}

    Per montare un file system e visualizzare i file system montati è possibile utilizzare il comando \ttt{mount} (consultare il manuale per le varie opzioni).

    Inoltre, per visualizzare i \tbf{file system attualmente montati} è possibile esaminare anche il contenuto del file \ttt{/etc/mtab}, mentre per visualizzare i \tbf{file system montati all'avvio (bootstrap)} è possibile esaminare il contenuto del file \ttt{/etc/fstab}.

    \begin{frameddefn}{Partizione}
        Un disco solido o magnetico può essere suddiviso in due o più \tbf{partizioni}, le quali possono essere gestite \tbf{indipendentemente}, come se fossero in realtà due dischi separati.
    \end{frameddefn}

    \tbf{Esempio:}

    \begin{itemize}
        \item Supponiamo che un disco sia partizionato in due partizioni $A$ e $B$
        \item La partizione $A$ può contenere il sistema operativo, mentre la seconda può contenere i dati degli utenti (dunque la home directory dei vari utenti)
        \item Pertanto, la partizione $A$ verrà montata sulla directory \ttt{/}, mentre la partizione $B$ verrà montata sulla directory \ttt{/home}
        \item Tale partizionamento risulta vantaggioso per alcune situazioni (es: se si necessita di reinstallare il sistema operativo, è possibile farlo direttamente sulla partizione $A$, senza intaccare la partizione $B$)
    \end{itemize}

    I tipi di file system Linux si differenziano in:
    
    \begin{center}
        \begin{tabular}{c|c|c|c|c}
            \tbf{Nome} & \tbf{Dim$_{\text{max}}$ Part.} & \tbf{Dim$_{\text{max}}$ File } & \tbf{Lung$_{\text{max}}$ Nome file} & \tbf{Journal}\\
            \hline
            \ttt{ext2} & 32 TB & 2 TB & 255 B & No\\
            \ttt{ext2} & 32 TB & 2 TB & 255 B & Si\\
            \ttt{ext4} & 1000 TB & 16 TB & 255 B & Sì\\
            \ttt{ReiserFS} & 16 TB & 8 TB & 4032 B & Sì\\
        \end{tabular}
    \end{center}

    \quad

    Dove un \tbf{journaling file system} tratta ogni scrittura su disco come transazione, tenendo traccia delle operazioni svolte su un file di log. Inoltre, ogni file system differisce per il modo in cui vengono codificati i dati al suo interno.

    Tra i vari file system non Linux, invece, troviamo \ttt{NTFS}, \ttt{MSDOS}, \tbf{FAT16}, \tbf{FAT32} e \tbf{FAT64}. I file system \ttt{FAT} e \ttt{NTFS} possono essere montati anche su un file system Linux.

    Per \tbf{formattare un disco o una partizione}, ossia creare su di essi un nuovo file system da zero, può essere utilizzato il comando \ttt{mkfs [-t type] device} (consultare il manuale).

    Per \tbf{visualizzare la dimensione e l'occupazione di un file system}, è possibile utilizzare il comando \ttt{df [-h] [-l] [-i] [file]} (consultare il manuale).

    \quad

    \section{Directory di primo livello}

    Tipicamente, la directory \ttt{/}, contiene al suo interno le seguenti \tbf{directory di primo livello}, le quali possono essere montate o non:
    \begin{itemize}
        \item \ttt{/boot}, contenente il kernel e i file per il bootstrap. Non viene montata ed è per tanto salvata direttamente all'interno della root directory.
        \item \ttt{/bin}, contenente i file binari (ossia i file eseguibili) di base. Non viene montata ed è per tanto salvata direttamente all'interno della root directory.
        \item \ttt{/sbin}, contenente i file binari (ossia i file eseguibili) di sistema. Non viene montata ed è per tanto salvata direttamente all'interno della root directory.
        \item \ttt{/dev}, contenente i file non regolari relativi all'uso delle periferiche hardware e virtuali. Viene montata in fase di bootstrap.
        \item \ttt{/proc}, contenente i file relativi a dati e statistiche dei processi e ai parametri del kernel. Viene montata in fase di bootstrap.
        \item \ttt{/sys}, contenente i file relativi ad informazioni e statistiche dei dispositivi di sistema. Viene montata in fase di bootstrap.
        \item \ttt{/media} e \ttt{/mnt}, utilizzate come punto di mount per i dispositivi I/O (es: CD, DVD, USB, ...). Vengono montate solo quando necessario.
        \item \ttt{/etc}, contenente i file di configurazione di sistema. Non viene montata ed è per tanto salvata direttamente all'interno della root directory.
        \item \ttt{/var}, contenente i file variabili. Non viene montata ed è per tanto salvata direttamente all'interno della root directory.
        \item \ttt{/tmp}, contenente i file temporanei. Non viene montata ed è per tanto salvata direttamente all'interno della root directory.
        \item \ttt{/lib}, contenente le librerie necessarie ai file binari. Non viene montata ed è per tanto salvata direttamente all'interno della root directory.
    \end{itemize}

    In particolare, all'interno della directory \ttt{/etc} possiamo trovare due file di fondamentale importanza all'interno del sistema operativo:
    \begin{itemize}
        \item Il file \ttt{/etc/passwd}, contenente una lista di tutti gli utenti del sistema e informazioni ad essi associate. Ogni riga della lista possiede la seguente struttura:
        \[\ttt{username:password:uid:gid:gecos:homedir:shell}\]
        dove il campo \ttt{gid} contiene il GID del gruppo principale dell'utente, il campo \ttt{gecos} contiene una breve descrizione dell'utente, il campo \ttt{homedir} contiene il percorso verso la cartella home dell'utente e il campo \ttt{shell} contiene il percorso verso la shell predefinita per l'utente.
        
        Solitamente, inoltre, il campo \ttt{password} di ognuna di tali righe viene mascherato dal carattere \ttt{x} Difatti, la vera password di un utente viene conservata all'interno del file \ttt{/etc/shadow}, sotto forma di hash stesso della password.
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.8]{images/passwd.png}
    \end{center}

    \begin{itemize}
        \item Il file \ttt{/etc/group}, contenente una lista di tutti i gruppi del sistema e informazioni ad essi associate. Ogni riga della lista possiede la seguente struttura:
        \[\ttt{groupname:password:gid:utente1,utente2,...}\]
        Anche in tal caso, il campo \ttt{password} viene censurato da una \ttt{x}.
    \end{itemize}

    \quad

    \section{Index Node (inode)}

    \begin{frameddefn}{Index Node (inode)}
        All'interno di un file system Linux-based, ogni file (regolare e non, directory e non) è rappresentato da una struttura dati detta \tbf{index node (inode)}.
    \end{frameddefn}

    Tra i principali attributi di un inode troviamo:
    \begin{itemize}
        \item \tbf{inode number}, univoco per ogni inode
        \item \tbf{Type}, indicante il tipo di file
        \item \tbf{User ID (UID)}, ossia l'ID dell'utente proprietario del file
        \item \tbf{Group ID (GID)}, ossia l'ID del gruppo a cui è associato il file
        \item \tbf{Mode}, ossia i permessi di accesso al file per il proprietario, il gruppo associato ed ogni altro utente (vedi sezioni successive)
        \item \tbf{Size}, ossia la dimensione in byte del file
        \item \tbf{Timestamps}, ossia tre istanti di tempo:
        \begin{itemize}
            \item \tbf{ctime (change time)}, l'istante dell'ultima modifica di un attributo dell'inode
            \item \tbf{mtime (modification time)}, l'istante dell'ultima scrittura sul file associato
            \item \tbf{atime (access time)}, l'istante dell'ultima lettura del file associato
        \end{itemize}
        \item \tbf{Link count}, ossia il numero di hard links dell'inode (vedi sezioni successive)
        \item \tbf{Data pointers}, ossia il puntatore alla lista dei blocchi su disco che compongono il file.
    \end{itemize}

    \begin{framedobs}{}
        La vera funzionalità del comando \ttt{touch} risulta essere quella di \tbf{aggiornare tutti i timestamp} di un file all'istante corrente. Se il file indicato non esiste, esso verrà creato. La creazione del file, dunque, è solo un \underline{effetto secondario}.
    \end{framedobs}

    All'interno del file system (in particolare all'inizio del disco o partizione su cui è installato il file system) si trova una \tbf{tabella degli inode}. Ad esempio, nei file system \ttt{ext2} la tabella degli inode viene conservata all'interno del primo gruppo di blocchi:
    \begin{center}
        \includegraphics[scale=0.44]{images/inode_1.png}
    \end{center}

    \begin{framedobs}{}
        Una directory non è altro che un \tbf{file speciale}; il cui contenuto è costituito da blocchi su disco contenenti \tbf{tabelle} formate da tuple nel formato \ttt{(inode\_file, nome\_file)}.
    \end{framedobs}

    Ad esempio, il path \ttt{/home/ealtieri/hello.txt} viene seguito esaminando uno ad uno il contenuto dei file puntati dagli inode delle directory intermedie:
    \begin{center}
        \includegraphics[scale=0.4]{images/inode_2.png}
    \end{center}

    Per visualizzare le informazioni contenute dell'inode di un file, il comando \ttt{ls} fornisce numerevoli opzioni:
    \begin{itemize}
        \item L'opzione \ttt{[-l]} permette di visualizzare permessi di accesso, numero di sottodirectory UID, GID, size, mtime dei file.
        
        Inoltre, all'inizio dell'output viene visualizzato il numero di blocchi totali occupati dalla directory (\ttt{non} è incluso il numero di blocchi occupati dalle sottodirectory), dove, normalmente, un blocco è grande tra 1kB e 4kB.
        \begin{itemize}
            \item Se usato assieme a \ttt{[-c]}, viene visualizzato il ctime al posto dell'mtime
            \item Se usato assieme a \ttt{[-u]}, viene visualizzato l'atime al posto dell'mtime
        \end{itemize}
        \item L'opzione \ttt{[-i]} permette di visualizzare gli inode number dei file
        \item L'opzione \ttt{[-n]} permette di visualizzare i numeri associati all'UID e al GID, invece del loro nome
    \end{itemize}

    \quad

    \begin{center}
        \includegraphics[scale=0.5]{images/inode_3.png}
    \end{center}

    \quad

    Oltre al comando \ttt{ls}, il comando \ttt{stat} permette di visualizzare in modo dettagliato tutte le informazioni dell'inode di un file.
    \begin{center}
        \includegraphics[scale=0.9]{images/inode_4.png}
    \end{center}

    Per \tbf{sommare le dimensioni di vari file e/o directory}, è possibile utilizzare il comando \ttt{du [files...]} (consultare il manuale).

    \quad

    \subsection{Hard link e Soft link}

    \begin{frameddefn}{Hard link e Soft link}
        Un \tbf{hard link (o collegamento fisico)} è un collegamento che associa un nome ad un file (e di conseguenza al suo inode). Ogni file possiede \tbf{almeno un hard link}.

        Un \tbf{soft link (o shortcut)}, invece, è un puntatore al path di un hard link o un altro soft link.
    \end{frameddefn}

    \begin{framedobs}{}
        Se un file possiede più hard link, esso sarà accessibile tramite ognuno di tali link e la dimensione e l'inode number di tali hard link saranno quelli del file stesso, risultando dunque \tbf{identici}. Inoltre, eseguendo il comando \ttt{rm}, tale file verrà effettivamente rimosso dal disco solamente quando \tbf{verranno rimossi tutti i suoi hard link}.
    \end{framedobs}

    \begin{framedobs}{}
        La dimensione di un soft link corrisponde al numero di byte necessari a conservare il path puntato.
    \end{framedobs}

    Per \tbf{creare un link} è possibile utilizzare il comando \ttt{ln [-s] src\_link new\_link}. Se l'opzione \ttt{[-s]} non viene utilizzata, verrà creato un hard link, mentre in caso contrario verrà creato un soft link.

    \begin{center}
        \includegraphics[scale=0.9]{images/links.png}
    \end{center}

    \begin{framedobs}{}
        Poiché un soft link è un puntatore ad un path, se il file relativo a tale path viene \tbf{spostato}, \tbf{rinominato} o \tbf{rimosso}, tale soft link non sarà più valido.
    \end{framedobs}

    \begin{center}
        \includegraphics[scale=0.95]{images/links_2.png}
    \end{center}

    \quad
    
    \section{Permessi di accesso ai file}

    Come già accennato, all'interno di ogni inode vengono specificati i \tbf{permessi di accesso} al file associato a tale inode.

    Tali permessi di accesso corrispondono ad una \tbf{terna di terne bit}: tre bit per i permessi di accesso del \tbf{proprietario (user)}, tre bit per i permessi di accesso del \tbf{gruppo associato (group)} e tre bit per \tbf{qualsiasi altro utente (other)}.

    Per ognuna delle terne di bit, ognuno di essi corrisponde ad un permesso:
    \begin{enumerate}
        \item Il primo bit (partendo da destra) corrisponde al \tbf{permesso di esecuzione (execute)}, indicato anche con una \tbf{x}. Se attivo, permette di eseguire il file (nel caso sia eseguibile).
        \item Il secondo bit corrisponde al \tbf{permesso di scrittura (write)}, indicato anche con una \tbf{w}. Se attivo, permette di sovrascrivere, appendere in scrittura o cancellare direttamente il file.
        \item Il terzo bit corrisponde al \tbf{permesso di lettura (read)}, indicato anche con una \tbf{r}. Se attivo, permette di accedere al contenuto del file.
    \end{enumerate}

    Ognuno di tali bit può essere \tbf{impostato o non}, concedendo o meno il permesso ad esso associato. Ad esempio, se i tre bit sono impostati su \ttt{011}, vengono concessi solo i permessi di scrittura ad esecuzione. Difatti, utilizzando la \tbf{notazione alfabetica}, il permesso \ttt{011} corrisponde a \ttt{-wx}. Inoltre, trattandosi di \tbf{terne di bit}, il loro valore può essere interpretato anche in \tbf{base ottale}.

    \begin{center}
        \begin{tabular}{ccc}
            \tbf{Permesso} & \tbf{Valore binario} & \tbf{Valore ottale}\\
            \hline
            \ttt{- - -} & 000 & 0\\
            \ttt{- - x} & 001 & 1\\
            \ttt{- w -} & 010 & 2\\
            \ttt{- w x} & 011 & 3\\
            \ttt{r - -} & 100 & 4\\
            \ttt{r - x} & 101 & 5\\
            \ttt{r w -} & 110 & 6\\
            \ttt{r w x} & 111 & 7\\
        \end{tabular}
    \end{center}

    \quad

    Dunque, ogni terna di permessi associati ad un inode può essere interpretata come:
    \[\underbrace{\underbrace{\ttt{rwx}}_{\text{User}} \underbrace{\ttt{rwx}}_{\text{Group}} \underbrace{\ttt{rwx}}_{\text{Other}}}_{\text{All}}\]

    \tbf{Esempi:}

    \begin{itemize}
        %boh a quanto pare -- corrisponde ad un solo - ???

        \item I permessi \ttt{rw-r----r----} (corrispondente a \ttt{644}) indicano che tutti gli utenti possono leggere il contenuto del file, ma solo il proprietario possa scrivere su di esso
        \item I permessi \ttt{rwx-wx---w---} (corrispondente a \ttt{732}) indicano che il proprietario può svolgere qualsiasi operazione, gli utenti del gruppo associato può scrivere ed eseguire il file e tutti gli altri possano solo scrivere sul file.
        \item I permessi \ttt{rwxrwxrwx} (corrispondente a \ttt{777}) indicano che tutti gli utenti possano eseguire qualsiasi operazione.
        \item I permessi \ttt{------------------} (corrispondente a \ttt{000}) indicano che nessun utente possa eseguire alcuna operazione.
        
    \end{itemize}

    Solitamente, a tale terna viene anche associato come prefisso anche il campo \ttt{type} del inode, in modo da poter distinguere se tali permessi siano relativi ad un file regolare o solitamente una directory.

    \tbf{Esempi:}

    \begin{itemize}
        \item I permessi \ttt{-rwxrwxrwx} indicano che l'inode è relativo ad un file regolare su cui ogni utente può svolgere qualsiasi operazione
        \item I permessi \ttt{drwxrwxrwx} indicano che l'inode è relativo ad una directory su cui ogni utente può svolgere qualsiasi operazione,
    \end{itemize}

    In particolare, nel caso delle \tbf{directory} gli effetti ottenuti in base ai permessi associati non risultano del tutto intuitivi:
    \begin{center}
        \begin{tabular}{ccl}
            \tbf{Permesso} & \tbf{Ottale} & \tbf{Effetto sulla directory}\\
            \hline
            \ttt{- - -} & 0 & Nessuna operazione concessa\\
            \hline

            & & La directory può essere impostata come \ttt{cwd}, ma solo\\
            \ttt{- - x} & 1 & se tale permesso è concesso per ogni directory del path.\\
            & & Inoltre, è possibile "attraversarla" se il contenuto è già conosciuto\\
            \hline

            \ttt{- w -} & 2 & Nessuna operazione concessa\\
            \hline

            & & È possibile aggiungere file e directory, cancellare file\\
            \ttt{- w x} & 3 & contenuti in essa (anche senza avere il permesso di scrittura \\
            & & su tali file), cancellare directory contenute in essa\\
            & & (se si hanno tutti i permessi su tali directory)\\
            \hline

            \ttt{r - -} & 4 & Può essere solo elencato il contenuto della directory\\
            & & (senza gli attributi dei file) e non può essere "attraversata"\\
            \hline

            & & È possibile elencare il contenuto della directory (attributi compresi), \\
            \ttt{r - x} & 5 & impostare come \ttt{cwd} ed "attraversare". Tuttavia, non è\\
            & & possibile cancellare o aggiungere file alla directory\\
            \hline

            \ttt{r w -} & 6 & Come il permesso 4\\
            \hline

            \ttt{r w x} & 7 & Come il permesso 3, ma si può anche elencare il\\
            & & contenuto della directory (attributi compresi)\\
            \hline
        \end{tabular}
    \end{center}

    \quad

    Per \tbf{modificare i permessi di accesso} di un file è possibile utilizzare il comando \ttt{chmod perms nome\_file}, dove nell'argomento \ttt{perms} possono essere specificati (in più formati) i permessi da aggiungere, rimuovere o impostare per il file
    
    \tbf{Esempi:}

    \begin{itemize}
        \item Il comando \ttt{chmod 644 ciao.txt} imposta i permessi \ttt{rw--r----r----}
        \item Il comando \ttt{chmod +x ciao.txt} aggiunge il permesso di esecuzione per tutte e tre le terne
        \item Il comando \ttt{chmod u+r,g+w,o+x ciao.txt} aggiunge il permesso \tbf{r} per la terna \ttt{User}, il permesso \tbf{w} per la terna \ttt{Group} e il permesso \tbf{x} per la terna \ttt{Other}
    \end{itemize}

    Per \tbf{modificare il proprietario} o il \tbf{gruppo di appartenenza} di un file, invece, possono essere utilizzati i comandi \ttt{chown [-R] user nome\_file} e \ttt{chgrp [-R] group nome\_file}, dove l'opzione \ttt{[-R]} applica il comando ricorsivamente su tutte le sotto-directory nel caso in cui \ttt{nome\_file} sia una directory. Tali comandi possono essere utilizzati solo da \ttt{root}, richiedendo quindi l'uso di \ttt{sudo}.


    \quad

    \subsection{Permessi speciali}

    Oltre alle tre terne di bit per i permessi di accesso, all'interno dell'inode di un file vi è un'\tbf{aggiuntiva terna di bit} utilizzata per i \tbf{permessi speciali}:
    \begin{itemize}
        \item Il primo bit (partendo da destra) corrisponde allo \tbf{sticky bit}.
        
        Se utilizzato sui file, esso risulta inutile. Se utilizzato sulle directory, invece, \tbf{corregge il comportamento del permesso \ttt{-wx} per ogni terna}, permettendo la cancellazione dei file \underline{solo} se si hanno permessi di scrittura \underline{anche} su di essi.
        \item Il secondo bit corrisponde al \tbf{SetGID bit}.
        
        Se utilizzato su un file non eseguibile, esso risulta inutile. Se utilizzato su un file eseguibile, invece, alla sua esecuzione i privilegi con cui opera il corrispondente processo vengono \tbf{sostituiti con quelli del gruppo associato al file}, facendo quindi prevalere i permessi della terna \ttt{Group}.
        \item Il terzo bit corrisponde al \tbf{SetUID bit}, analogo al SetGID bit ma con la terna \ttt{User}. Spesso, tale bit risulta essere "troppo potente", richiedendo limitazioni.
    \end{itemize}

    \[\underbrace{\ttt{sst}}_{\text{Special}} \underbrace{\underbrace{\ttt{rwx}}_{\text{User}} \underbrace{\ttt{rwx}}_{\text{Group}} \underbrace{\ttt{rwx}}_{\text{Other}}}_{\text{All}}\]

    \tbf{Esempi:}

    \begin{enumerate}
        \item \begin{itemize}
            \item Siano $D$ una directory, $f$ un file in $D$ e \ttt{User1} e \ttt{User2} due utenti tali che \ttt{User1} $\neq$ \ttt{User2}. Supponiamo inoltre che $D$ appartenga a \ttt{User1} e che $D$ non appartenga al gruppo di \ttt{User2}
            \item Se lo sticky bit non è impostato su $D$,  affinché \ttt{User2} possa cancellare $f$ è sufficiente che sia impostato il bit di scrittura nella terna \ttt{Other} di $D$.
            \item Se invece lo sticky bit è impostato su $D$, affinché \ttt{User2} possa cancellare $f$ è necessario che sia impostato anche il bit di scrittura nella terna \ttt{Other} del file $f$ e non solo della directory $D$
        \end{itemize}

        \item \begin{itemize}
            \item Il comando \ttt{passwd} (non il file \ttt{/etc/passwd}) ha il SetUID bit impostato, permettendo ad un utente di modificare la propria password (il proprietario dell'eseguibile è \ttt{root}).
        \end{itemize}
    \end{enumerate}

    \quad

    Nonostante a livello effettivo sia presente un'ulteriore terna di bit, nella \tbf{notazione alfabetica} tali bit \underline{non vengono rappresentati} come una terna aggiuntiva. Difatti se impostati, essi vengono visualizzati \tbf{al posto dei tre bit di esecuzione}:
    \begin{itemize}
        \item Se lo \tbf{sticky bit} è impostato, esso rimpiazzerà il bit di esecuzione della terna \ttt{Other}, visualizzando una \tbf{t} minuscola nel caso in cui anche tale bit di esecuzione sia impostato oppure una \tbf{T} maiuscola in caso contrario.
        \item Se il \tbf{SetGID bit} è impostato, esso rimpiazzerà il bit di esecuzione della terna \ttt{Group}, visualizzando una \tbf{s} minuscola nel caso in cui anche tale bit di esecuzione sia impostato oppure una \tbf{S} maiuscola in caso contrario.
        \item Se il \tbf{SetUID bit} è impostato, esso rimpiazzerà il bit di esecuzione della terna \ttt{User}, visualizzando una \tbf{s} minuscola nel caso in cui anche tale bit di esecuzione sia impostato oppure una \tbf{S} maiuscola in caso contrario.
    \end{itemize}

    \tbf{Esempi:}

    \begin{itemize}
        \item I permessi \ttt{rw--r----r----} (corrispondenti a 0644) indicano che nessun bit speciale è attivo.
        \item I permessi \ttt{rwSr----r----} (corrispondenti a 4644) indicano che il SetUID bit è attivo, ma il bit di esecuzione della terna \ttt{User} no.
        \item I permessi \ttt{rwsr----r----} (corrispondenti a 4744) indicano che sia il SetUID bit sia il bit di esecuzione della terna \ttt{User} sono entrambi attivi.
    \end{itemize}

    \begin{frameddefn}{User File-Creation Mask (umask)}
        La \tbf{User File-Creation Mask (umask)} definisce la maschera dei file creati dall'utente attuale, ossia i permessi di accesso \tbf{bloccati di default} per ogni file creato da tale utente stesso:
        \begin{itemize}
            \item Alla creazione di una directory, i suoi permessi di accesso vengono impostati automaticamente a \ttt{0777 AND NOT(umask)}
            \item Alla creazione di un file, i suoi permessi di accesso vengono impostati automaticamente a \ttt{0666 AND NOT(umask)}
        \end{itemize}
    \end{frameddefn}

    \tbf{Esempio:}

    \begin{itemize}
        \item Supponiamo che per l'utente attuale si abbia che \ttt{umask = 0022}
        \item Se tale utente creasse una directory, i suoi permessi verrebbero impostati a 
        \[\ttt{0777 AND NOT(umask) = 0777 AND NOT(0022) = 0777 AND 7755} = 0755\]
        e dunque impostati a \ttt{rwxr--xr--x}
        \item Se tale utente creasse un file, i suoi permessi verrebbero impostati a 
        \[\ttt{0666 AND NOT(umask) = 0666 AND NOT(0022) = 0666 AND 7755} = 0644\]
        e dunque impostati a \ttt{rw--r----r----}
    \end{itemize}

    Per \tbf{modificare la umask} dell'utente attuale, è possibile utilizzare il comando \ttt{umask [mask]}. È necessario sottolineare che all'interno della umask i primi tre bit non possano essere modificati, implicando che il primo valore ottale sia sempre 0.

    \chapter{Processi}

    \begin{frameddefn}{Programmi e Processi}
        Un \tbf{programma} è un file eseguibile salvato in memoria secondaria. Contiene l'insieme di istruzioni necessarie a svolgere un compito richiesto.
        
        Un \tbf{processo} è una particolare istanza attiva di un programma caricata in memoria principale, eseguendo sequenzialmente le istruzioni descritte nel programma stesso.
    \end{frameddefn}
    
    \begin{framedobs}{}
        Non tutti i \tbf{comandi} avviano un processo:
        \begin{itemize}
            \item I comandi corrispondenti a \tbf{programmi} avviano un nuovo processo quando vengono eseguiti
            \item I comandi \tbf{build-in nella shell} non avviano un nuovo processo, venendo eseguiti all'interno del processo relativo alla shell stessa
        \end{itemize}
    \end{framedobs}

    Per avviare un processo è per tanto necessario eseguire un programma, digitando in una shell il nome del file associato. Poiché i sistemi operativi Unix sono \tbf{multi-processo}, prima di poter eseguire nuovamente tale programma, non occorre aspettare il termine dell'esecuzione del processo precedente. Per tanto, tale file eseguibile può essere \tbf{eseguito più volte}, dando vita ogni volta ad un nuovo processo.

    \newpage

    \section{Canali dei processi}

    \begin{frameddefn}{Canali e File descriptor}
        Ogni processo può avere accesso a dei \tbf{canali}, ossia dei flussi di dati in uscita o in entrata verso dispositivi o file. Ogni canale viene identificato univocamente all'interno del processo stesso tramite un valore intero detto \tbf{file descriptor}.
    \end{frameddefn}

    \begin{framedprop}{Canali standard}
        Ogni processo Unix ha accesso ad \tbf{almeno tre canali standard}:
        \begin{itemize}
            \item \tbf{Standard Input (stdin)}, ossia il flusso dati predefinito in ingresso, corrispondente di default all'input da tastiera. Il suo \tbf{file descriptor corrisponde a 0}.
            \item \tbf{Standard Output (stdout)}, ossia il flusso dati predefinito in uscita, corrispondente di default alla shell su cui è eseguito il processo. Il suo \tbf{file descriptor corrisponde a 1}.
            \item \tbf{Standard Error (sterr)}, ossia il flusso dati predefinito per segnalazione di eventuali messaggi di errore e/o diagnostica, corrispondente di default alla shell su cui è eseguito il processo. Il suo \tbf{file descriptor corrisponde a 2}.
        \end{itemize}
        
        \begin{center}
            \includegraphics[scale=0.6]{images/channels.png}
        \end{center}
    \end{framedprop}

    All'interno della shell \ttt{bash}, ogni canale può essere \tbf{ridirezionato} :
    \begin{itemize}
        \item Tramite \ttt{cmd < nome\_file} è possibile ridirezionare \tbf{verso lo stdin} del comando \ttt{cmd} il contenuto del file \ttt{nome\_file}.
        
        \item Tramite \ttt{cmd N> nome\_file} è possibile di ridirezionare il canale identificato dal file descriptor \ttt{N} del comando \ttt{cmd} \tbf{verso il file} \ttt{nome\_file}. Se non viene specificato alcun file descriptor, viene utilizzato lo stdout come canale.
        
        Se il file possedeva già del contenuto, esso viene sovrascritto. Inoltre, se il file non esiste, esso viene automaticamente creato.

        \item Tramite \ttt{cmd N>\.> nome\_file} si ottiene lo stesso effetto di \ttt{cmd N> nome\_file}, con la differenza che il contenuto venga \tbf{appeso alla fine del file}, invece che sovrascritto.
        
        \item Tramite \ttt{cmd N>\&M} è possibile ridirezionare il canale legato al file descriptor \ttt{N} del comando \ttt{cmd} \tbf{verso il canale} legato al file descriptor \ttt{M} dello stesso comando. 
    \end{itemize}

    \tbf{Esempi:}

    \begin{itemize}
        \item Il programma \ttt{cat nome\_file} restituisce sullo stdout il contenuto del file dato. Se non viene passato alcun file come argomento, il programma \ttt{cat} leggerà l'input direttamente da stdin fino a quando non verrà premuto \ttt{CTRL+d}. Per tanto, è possibile ottenere lo stesso effetto di \ttt{cat nome\_file} tramite \ttt{cat < nome\_file}

        \item Tramite \ttt{ls > out.txt}, viene ridirezionato lo stdout del comando \ttt{ls} verso il file \ttt{out.txt}, sovrascrivendone il contenuto
        \item Tramite \ttt{ls 2> out.txt}, viene ridirezionato lo stderr del comando \ttt{ls} verso il file \ttt{out.txt}, sovrascrivendone il contenuto
        \item Tramite \ttt{ls >\.> out.txt}, viene ridirezionato lo stdout del comando \ttt{ls} verso il file \ttt{out.txt}, appendendo l'output alla sua fine
        \item Tramite \ttt{ls 2>\&1}, viene ridirezionato lo stderr del comando \ttt{ls} verso il suo stdout
        \item Tramite \ttt{ls 2> /dev/null}, viene ridirezionato lo stderr del comando \ttt{ls} verso il dispositivo \ttt{/dev/null}, un dispositivo virtuale che funge da "buco nero" del sistema operativo. Per tanto, in tal modo lo stderr verrà completamente ignorato.
    \end{itemize}

    \begin{framedobs}{}
        Le ridirezioni effettuate tramite \ttt{<}, \ttt{>} e \ttt{>\.>} \underline{non sono transitive}
    \end{framedobs}

    \tbf{Esempi:}
    \begin{itemize}
        \item Tramite \ttt{ls 2>\&1 > out.txt}, viene ridirezionato lo stderr del comando \ttt{ls} verso il suo stdout, mentre il suo stdout viene ridirezionato verso il file \ttt{out.txt}, sovrascrivendone il contenuto, il cui contenuto corrisponderà esclusivamente al flusso dati inserito nello stdout \underline{prima} del ridirezionamento dello stderr verso lo stdout.
    \end{itemize}

    \begin{frameddefn}{Pipelining}
        Definiamo come \tbf{pipelining} il ridirezionamento dello stdout o stderr di un comando verso lo stdin di un altro comando. Il pipelining può essere \tbf{effettuato ripetute volte}, permettendo la realizzazione di programmi complessi tramite l'unione di programmi più semplici.
    \end{frameddefn}

    All'interno della shell \ttt{bash}, il pipelining può essere effettuato tramite:
    \begin{itemize}
        \item Il simbolo \ttt{|}, il quale ridireziona lo stdout del comando alla sua sinistra verso lo stdin del comando alla sua destra (es: \ttt{cmd1 | cmd2 | ...}).
        \item Il simbolo \ttt{|\&}, il quale ridireziona lo stderr del comando alla sua sinistra verso lo stdin del comando alla sua destra (es: \ttt{cmd1 |\& cmd2 |\& ...}).
    \end{itemize}

    \newpage

    \section{Attributi e rappresentazione dei processi}

    \begin{frameddefn}{Process ID (PID)}
        Ogni processo è dotato di un valore intero, chiamato \tbf{Process ID (PID)}, che lo identifica univocamente
    \end{frameddefn}

    Nello stesso istante, all'interno della stessa macchina non possono essere presenti due processi aventi lo stesso PID. Una volta che un processo è terminato, il suo PID viene liberato, implicando che esso possa essere (prima o poi) riassegnato ad un nuovo processo.

    \begin{framedobs}{}
        In alcuni sistemi operativi, inclusi quelli Linux-based, i PID dei processi vengono assegnati \tbf{casualmente} tra quelli disponibili, rispetto ad un assegnamento incrementale.
        
        In tal modo, all'riavvio di una macchina i processi avranno PID diversi rispetto alla sessione precedente, incrementando la sicurezza del sistema stesso.
    \end{framedobs}

    \begin{frameddefn}{Niceness}
        Ogni comando è dotato di un valore intero nel range $[-19, 20]$, detto \tbf{niceness}, che viene sommato al \tbf{valore di priorità di scheduling} dei processi di tale comando.

        \tbf{Maggiore} è il valore di priorità del processo, \tbf{minore} sarà la priorità data alla sua selezione da parte dello scheduler della CPU. Di default, la niceness di un comando è impostata a 0.
    \end{frameddefn}

    Il comando \ttt{nice} permette di \tbf{interagire con la niceness}:
    \begin{itemize}
        \item Se lanciato senza opzioni, permette di visualizzare la niceness di default per ogni comando
        \item Se lanciato con \ttt{nice [-n num] command}, viene avviato il comando \ttt{command} con valore di niceness impostato a \ttt{num} (0 se omesso)
    \end{itemize}

    In comandi \ttt{renice priority pid1,pid2,...}, invece, permette di modificare la niceness dei processi in esecuzione aventi PID interno alla lista data.

    \newpage

    \begin{frameddefn}{Process Control Block (PCB)}
        Ad ogni processo in esecuzione viene associata una struttura dati univoca detta \tbf{Process Control Block (PCB)}, conservata all'interno del kernel.
    \end{frameddefn}

    All'interno del PCB di un processo, vengono conservate le seguenti informazioni:

    \begin{itemize}
        \item \tbf{PID} del processo
        \item \tbf{Parent PID (PPID)}, ossia il PID del processo padre tramite cui è stato avviato il processo stesso
        \item \tbf{Real UID (RUID)}, ossia lo UID dell'utente che ha avviato il processo
        \item \tbf{Real GID (RGID)}, ossia il GID dell'utente che ha avviato il processo
        \item \tbf{Effective UID (EUID)}, ossia lo UID attualmente assunto dal processo in esecuzione, non necessariamente uguale al RUID. Tale UID viene utilizzato come vero UID del processo, dettando i permessi attualmente ad esso concessi
        \item \tbf{Effective GID (EGID)}, ossia il GID attualmente assunto dal processo in esecuzione, non necessariamente uguale al RGID. Tale GID viene utilizzato come vero GID del processo, dettando i permessi attualmente ad esso concessi
        \item \tbf{Saved UID (SUID)}, ossia il precedente EUID assunto dal processo prima di aver assunto l'EUID attuale
        \item \tbf{Saved GID (SGID)}, ossia il precedente EGID assunto dal processo prima di aver assunto l'EGID attuale
        \item \tbf{State}, ossia lo stato del processo (vedi sezioni successive)
        \item \tbf{Current Working Directory (CWD)}, ossia la \ttt{cwd} attualmente "aperta" dal processo, corrispondente di default alla \ttt{cwd} in cui è stato avviato il processo
        \item \tbf{Root Directory}, ossia la directory utilizzata come base per i path assoluti all'interno del processo (di default è \ttt{/})
        \item \tbf{Umask} dell'utente che ha avviato il processo
        \item \tbf{Niceness} del processo
    \end{itemize}

    \begin{framedobs}{SetUID e SetGID}
        L'impostazione dei bit speciali \tbf{SetUID} e \tbf{SetGID} ha l'effetto di cambiare immediatamente l'EUID e l'EGID di un processo al suo avvio
    \end{framedobs}

    \begin{framedobs}{}
        Sebbene molto situazionale, il SUID e il SGID possono essere utilizzati da un processo eseguito con EUID e/o EGID privilegiati (es: tramite SetUID e/o SetGID) per impostare momentaneamente l'EUID/EGID pari al RUID/RGID, per poi tornare all'EUID/EGID precedente tramite il SUID/SGID.
    \end{framedobs}
        
    \tbf{Esempio:}

    \begin{itemize}
        \item Supponiamo che il programma \ttt{myProgram} abbia il bit SetUID impostato e che il suo proprietario sia \ttt{root}.
        \item All'avvio del programma da parte dell'utente \ttt{user}, il RUID e il SUID del processo vengono automaticamente impostati a \ttt{user}, mentre l'EUID viene impostato a \ttt{root}.
        \item Supponiamo che, dopo varie operazioni da super utente, il programma debba creare un file per l'utente \ttt{user}.
        \item Se il programma creasse tale file senza svolgere prima operazioni preliminari, il proprietario del file sarebbe \ttt{root}, poiché l'EUID del processo è impostato a \ttt{root}.
        \item Per tanto, il programma pone l'EUID pari al RUID, ossia \ttt{user}, prima di creare il file. In tal modo, il SUID verrà automaticamente posto all'EUID precedente, ossia \ttt{root}
        \item Successivamente, il programma potrà porre l'EUID pari al SUID, tornado ad avere \ttt{root} come EUID
    \end{itemize}

    Come molti sistemi operativi, anche nei sistemi Linux-based i processi utilizzano i concetti di \tbf{suddivisione in aree} e di \tbf{memoria virtuale}, dunque la suddivisione della memoria in \tbf{pagine} (si consiglia vedere gli appunti relativi al Modulo 1 per entrambi i concetti).
    
    Per quanto riguarda le aree di memoria, esse si suddividono in:
    \begin{itemize}
        \item \tbf{Text Segment}, contenente le istruzioni in linguaggio macchina da eseguire. Viene \tbf{condiviso} da più istanze dello stesso processo
        \item \tbf{Data Segment}, contenente i dati statici (es: variabili globali, variabili locali statiche, ...)inizializzati all'avvio del processo  e alcune costanti di ambiente. Potrebbe essere \tbf{condiviso} tra più processi.
        \item \tbf{BSS (Block Started from Symbol)}, contenente i dati statici non inizializzati all'avvio del processo. Potrebbe essere \tbf{condiviso} tra più processi.
        \item \tbf{MMS (Memory Mapping Segment)}, contenente tutto ciò che riguarda librerie esterne dinamiche utilizzate dal processo, fungendo anche da estensione dell'heap in alcuni casi. Potrebbe essere \tbf{condiviso} tra più processi.
        \item \tbf{Stack}, contenente i dati dinamici gestiti automaticamente dalle chiamate a funzioni. \tbf{Mai condiviso} tra processi.
        \item \tbf{Heap}, contenente i dati dinamici gestiti dal programmatore stesso.
        \item \tbf{Kernel space}, riservata esclusivamente al kernel.
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.5]{images/memory.png}
    \end{center}

    Per ottenere \tbf{tutte le informazioni} inerenti ai processi attivi, in particolare le informazioni relative a tutti i processi presenti nella directory di sistema \ttt{proc/}, è possibile utilizzare il comando \ttt{ps}, dove:
    \begin{itemize}
        \item Senza opzioni aggiuntive vengono mostrati i processi dell'utente attuale lanciati nella shell corrente
        \item L'opzione \ttt{[-e]} permette di mostrare tutti i processi di tutti gli utenti lanciati in tutte le shell (ossia tutti i figli del processo 0)
        \item L'opzione \ttt{[-u user1,user2,...]} permette di mostrare tutti i processi degli utenti nella lista data
        \item L'opzione \ttt{[-p pid1,pid2,...]} permette di mostrare tutti i processi con PID interno alla lista data
        \item L'opzione \ttt{[-f]} mostra informazioni aggiuntive
        \item L'opzione \ttt{[-l]} mostra più informazioni aggiuntive rispetto all'opzione \ttt{[-f]}
        \item L'opzione \ttt{[-y]} permette di non mostrare le flag, sostituendo nell'output il campo \ttt{ADDR} con il campo \ttt{RSS}. Può essere utilizzato solo con l'opzione \ttt{[-l]}
        \item L'opzione \ttt{[-o field1,field2,...]} permette di scegliere i campi da mostrare nell'output
    \end{itemize}

    \newpage

    \begin{center}
        \includegraphics[scale=0.4]{images/ps.png}
    \end{center}
    Tra i vari \tbf{campi} mostrabili dal comando \ttt{ps}, troviamo:
    \begin{itemize}
        \item \ttt{PID} e \ttt{PPID}
        \item \ttt{C}, ossia la parte intera della percentuale in uso della CPU da parte del processo
        \item \ttt{STIME} (o \ttt{START}), ossia l'ora in cui è stato avviato il comando (oppure la data se avviato da più di un giorno)
        \item \ttt{TIME}, ossia il tempo di CPU utilizzato finora
        \item \ttt{CMD}, ossia il comando e gli argomenti utilizzati per avviare il processo
        \item \ttt{F}, ossia varie flag associate al processo, tra cui:
        \begin{itemize}
            \item \ttt{F = 1}, il processo è stato biforcato ma non ancora eseguito
            \item \ttt{F = 4}, il processo ha utilizzato privilegi da super utente
            \item \ttt{F = 5}, entrambi i precedenti
            \item \ttt{F = 0}, nessuno dei precedenti
        \end{itemize}
        \item \ttt{S}, ossia lo stato del processo, espresso con la sua lettera rappresentativa (vedi sezioni successive)
        \item \ttt{UID}, ossia lo UID con cui è stato avviato il processo (se il SetUID bit è impostato, potrebbe non coincidere con chi ha lanciato il comando sulla shell)
        \item \ttt{PRI}, ossia l'attuale priorità del processo (maggiore è il valore, minore è la priorità)
        \item \ttt{NI}, ossia la niceness del processo
        \item \ttt{ADDR}, ossia l'indirizzo di memoria del processo (mostrato solo per retro-compatibilità con versioni precedenti di \ttt{ps})
        \item \ttt{SZ}, ossia il numero totali di pagine occupate dal processo sia nella RAM sia nel disco
        \item \ttt{RSS}, ossia la quantità di memoria in KB occupata dal processo all'interno della RAM (dunque \underline{escludendo} la memoria all'interno delle pagine sul disco)
        \item \ttt{VSZ}, ossia la quantità di memoria in KB occupata dal processo, sia nella RAM sia sul disco
        \item \ttt{WCHAN}, ossia la funzione del kernel nella quale il processo si è fermato in attesa di un segnale (se in attesa)
    \end{itemize}

    Il comando \ttt{top [-b] [-n num] [-p pid1,pid2,...]} corrisponde ad una "versione interattiva" del comando \ttt{ps} (vedere il manuale per l'uso dettagliato), dove l'opzione \ttt{[-b]} disattiva i comandi interattivi ma aggiorna automaticamente l'output dopo pochi secondi, l'opzione \ttt{[-n num]} effettua solo \ttt{num} aggiornamenti e l'opzione \ttt{[-p]} risulta analoga a quella di \ttt{ps}.

    \begin{framedobs}{}
        Normalmente, per terminare il comando \ttt{top} è possibile premere sia il tasto \ttt{q} che i tasti \ttt{CTRL+c}. Utilizzando l'opzione \ttt{[-b]}, invece, il tasto \ttt{q} verrà disabilitato
    \end{framedobs}

    Infine, per \tbf{visualizzare le syscall} effettuate da un processo attivo, è possibile utilizzare il comando \ttt{strace [-p pid]}, mentre il comando \ttt{strace command} permette di lanciare un comando e visualizzare le syscall da esso effettuate.

    \quad

    \section{Stati ed esecuzione di un processo}

    \label{statuses}
    In ogni istante, ogni processo assume un determinato \tbf{stato}:
    \begin{itemize}
        \item \tbf{Running (R)}, indicante che il processo è in esecuzione su un processore
        \item \tbf{Runnable (R)}, indicante che il processo è pronto ad essere mandato in esecuzione su un processore da parte dello scheduler
        \item \tbf{Sleep (S)}, indicante che il processo è in attesa di un evento e non può essere scelto dallo scheduler
        \item \tbf{Zombie (Z)}, indicante che il processo è terminato e le sue 6 aree di memoria sono state disassociate, tuttavia il suo PCB è ancora presente nel kernel poiché il suo processo padre non ha ancora richiesto il suo \tit{exit status}, ossia non ha "chiuso" il figlio
        \item \tbf{Stopped (T)}, corrispondente ad un caso particolare di sleep, dove, a seguito della ricezione di un segnale STOP, viene atteso un segnale CONT
        \item \tbf{Traced (t)}, corrispondente ad un caso particolare di sleep, dove è in esecuzione il debugging del processo
        \item \tbf{Uninterruptible Sleep (D)}, corrispondente ad un caso particolare di sleep, il quale non può in alcun modo essere interrotto
    \end{itemize}

    \begin{frameddefn}{Job}
        Definiamo come \tbf{job} un qualsiasi "lavoro" svolto all'interno di una shell. In particolare, un job può essere composto anche da \tbf{più comandi} (es: tramite il pipelining) e dunque da più processi (uno per comando).
    \end{frameddefn}

    \tbf{Esempio:}

    \begin{itemize}
        \item Il comando \ttt{sleep 5 | sleep 5 | sleep 5} è un job composto da tre processi sleep eseguiti uno dopo l'altro
    \end{itemize}

    Ogni job può essere eseguito secondo \tbf{due modalità}:
    \begin{itemize}
        \item \tbf{Esecuzione in foreground} (trad: \tit{in primo piano}), dove:
        \begin{itemize}
            \item I sotto-comandi del job possono leggere l'input da tastiera e scrivere sul terminale
            \item Finché esso non termina, il prompt non viene restituito e non possono essere lanciati altri job all'interno della stessa shell
            \item Ogni job lanciato viene eseguito in foreground di default
        \end{itemize}
        \item \tbf{Esecuzione in background} (trad: \tit{in sottofondo}), dove:
        \begin{itemize}
            \item I sotto-comandi del job non possono leggere l'input da tastiera, ma possono scrivere sul terminale
            \item Il prompt viene immediatamente restituito al loro avvio
            \item Mentre il job viene eseguito in background, possono essere eseguiti altri job sulla shell
            \item Nella shell \ttt{bash}, un job può essere avviato in background aggiungendo il simbolo \ttt{\&} alla fine del comando stesso
        \end{itemize}
    \end{itemize}

    \quad
    
    \begin{center}
        \includegraphics[scale=0.9]{images/jobs_1.png}
    \end{center}

    \begin{framedobs}{}
        In ogni istante, all'interno di \tbf{una shell} può esserci \tbf{solo un job in foreground}, ma \tbf{più job in foreground} possono essere eseguiti su \tbf{più shell} contemporaneamente.
    \end{framedobs}

    \begin{framedobs}{Job number}
        Ogni job eseguito all'interno di una shell possiede un \tbf{job number}, partendo dal numero 1. Due job possono avere lo stesso job number se eseguiti all'interno di due shell diverse.
    \end{framedobs}

    Per visualizzare la lista dei job attualmente attivi, è possibile utilizzare il comando \ttt{jobs [-l] [-p]}, dove l'opzione \ttt{[-l]} permette di listare anche i PID dei processi coinvolti nel job, mentre l'opzione \ttt{[-p]} permette di listare solamente il PID del processo attualmente in esecuzione di ogni job attivo.

    \quad

    \begin{center}
        \includegraphics[scale=0.9]{images/jobs_2.png}
    \end{center}

    Per \tbf{interrompere temporaneamente} il processo in foreground, è possibile premere \ttt{CTRL+z}, mandando tale processo in stato di \tbf{Stopped (T)}, mentre per \tbf{terminarlo} direttamente è possibile premere \ttt{CTRL+c}.
    
    Un processo in stato di Stopped (T), può essere \tbf{rimandato in esecuzione} tramite due comandi:
    \begin{itemize}
        \item Il comando \ttt{fg \%N} permette di mandare in esecuzione in foreground il job \ttt{N}
        \item Il comando \ttt{bg \%N} permette di mandare in esecuzione in background il job \ttt{N}
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.9]{images/jobs_3.png}
    \end{center}
    
    Per \tbf{entrambi i comandi}, al posto del parametro \ttt{\%N} è possibile specificare anche:
    \begin{itemize}
        \item \ttt{\%prefix}, dove \ttt{prefix} è la parte iniziale del comando del job desiderato
        \item \ttt{\%+}, \ttt{\%\%} oppure nulla, per selezionare l'ultimo job eseguito (o rieseguito)
        \item \ttt{\%-}, per selezionare il penultimo job eseguito (o rieseguito)
    \end{itemize}

    \section{Segnali dei processi}

    \begin{frameddefn}{Segnale}
        Un \tbf{segnale} è un evento (o interruzione software) generato dal kernel o da un processo a seguito di specifiche condizioni ed inviato verso un altro processo. Quando un processo riceve un segnale, esso reagisce eseguendo l'\tbf{azione predefinita} per tale segnale o un'\tbf{azione personalizzata} definita all'interno del programma del processo stesso.
    \end{frameddefn}

    Nei sistemi Linux-based, ogni segnale è identificato da un \tbf{numero} o da un \tbf{nome} e rientra in una \tbf{categoria} in base alla sua azione predefinita:
    \begin{itemize}
        \item \tbf{Segnale di Terminazione}, ossia viene richiesta la terminazione del processo
        \item \tbf{Segnale Ignorato}, ossia non viene svolta alcuna operazione
        \item \tbf{Segnale di Core dump}, ossia viene richiesta la terminazione del processo e viene effettuato un \tbf{core dump} (viene registrato in un file lo stato attuale della memoria e della CPU)
        \item \tbf{Segnale di Stop}, ossia viene messo il processo in stato di Stopped (T)
        \item \tbf{Segnale di Continuazione}, ossia viene richiesta la continuazione di un processo in stato di Stopped (T)
    \end{itemize}

    Tra i vari segnali inviabili, troviamo:

    \begin{center}
        \begin{tabular}{lcll}
            \tbf{Nome} & \tbf{Numero} & \tbf{Categoria} & \tbf{Significato o Condizione scatenante}\\
            \hline
            SIGINT  & 2 & Terminazione  & Invio di un \ttt{CTRL+c} da tastiera\\
            SIGQUIT & 3 & Core dump     & Uscita\\
            SIGILL  & 4 & Core dump     & Istruzione illegale\\
            SIGABR  & 6 & Core dump     & Abort\\
            SIGFPE  & 8 & Core dump     & Eccezione di tipo aritmetico\\
            SIGKILL & 9 & Terminazione  & Terminazione forzata del processo\\
            SIGUSR1 & 10 & Terminazione & Definito dall'utente\\
            SIGSEGV & 11 & Core dump    & Segmentation Fault\\
            SIGUSR2 & 12 & Terminazione & Definito dall'utente\\
            SIGPIPE & 13 & Terminazione & Scrittura senza lettori su pipe o socket\\
            SIGALRM & 14 & Terminazione & Allarme temporizzato\\
            SIGTERM & 15 & Terminazione & Terminazione del processo\\
            SIGCHLD & 17 & Ignorato & Status del figlio cambiato\\
            SIGCONT & 18 & Continuazione & Ripresa dell'esecuzione\\
            SIGSTOP & 19 & Stop     & Sospende del processo\\
            SIGTSTP & 20 & Stop     & Invio di un \ttt{CTRL+z} da tastiera\\
            SIGTTIN & 21 & Stop     & Lettura da terminale in background\\
            SIGTTOU & 22 & Stop     & Scrittura su terminale in background
        \end{tabular}
    \end{center}

    \begin{framedobs}{}
        A differenza degli altri segnali, i segnali SIGKILL e SIGSTOP \tbf{non possono essere gestiti} all'interno del programma. Per tanto, la loro azione non può essere personalizzata.
    \end{framedobs}

    \begin{framedobs}{}
        Le shortcut da tastiera \ttt{CTRL+z} e \ttt{CTRL+c} utilizzabili all'interno delle shell \ttt{bash}, inviano rispettivamente un segnale di SIGTSTOP e di SIGINT al job in foreground.

        I comandi \ttt{fg} e \ttt{bg} inviano un segnale SIGCONT al job specificato (con la differenza che \ttt{fg} riporti anche tale job in primo piano).
    \end{framedobs}

    Per \tbf{inviare un segnale} ad un processo in esecuzione, è possibile utilizzare il comando \ttt{kill}, dove:
    \begin{itemize}
        \item Il comando \ttt{kill -l [signal]} lista il numero e il nome del segnale \ttt{signal} (listando tutti i segnali disponibili se omesso)
        \item I comandi \ttt{kill -signal pid} e \ttt{kill -s signal pid} permettono di specificare (come numero, nome o abbreviativo) il segnale da inviare al processo avente \ttt{pid} come PID 
        
        (es: i comandi \ttt{kill -9 pid}, \ttt{kill -s SIGKILL pid} e \ttt{kill -s KILL pid} sono equivalenti)
        \item All'interno di ogni comando richiedente l'argomento \ttt{pid}, è possibile inviare il segnale ad un job invece che ad un processo specificandone il numero con \ttt{\%N} al posto di \ttt{pid}
        
        (es: \ttt{kill -9 \%1} invia un segnale SIGKILL ad job 1 della shell)
    \end{itemize}

    \begin{framedobs}{}
        Un processo considererà un segnale ricevuto solo se l'UID di chi ha inviato tale segnale corrisponde al RUID del processo
    \end{framedobs}

    \chapter{Linguaggio C}

    \section{Introduzione al linguaggio}

    Come già discusso, il linguaggio di programmazione C venne sviluppato dagli AT\&T Bell Labs agli inizi degli anni '70. Esso fu utilizzato per sviluppare il kernel di Unix (successivamente anche il kernel Linux) ed altri sistemi operativi. Venne standardizzato dall'American National Standards Institute (ANSI) e successivamente anche dall'International Organization for Standardization (ISO).
    
    Ogni programma scritto tramite il linguaggio C possiede una \tbf{funzione principale obbligatoria} detta \ttt{main()}, la quale può anche essere semplicemente il punto da cui vengono invocate tutte le altre funzioni che compongono il programma o essere direttamente l'unica funzione del programma. Tutte le funzioni dello stesso programma, inclusa \ttt{main()}, possono risiedere in un unico file o essere distribuite su più file.
    
    Ogni funzione consiste di un'\tbf{intestazione (header)}, a sua volta composta dal nome della funzione, dal tipo di valore ritornato e da una lista di parametri in input, ed un \tbf{blocco di istruzioni}:

    \begin{verbatim}
    <return-type> function-name (parameter-list){
        instruction 1;
        instruction 2;
        ...
    }
    \end{verbatim}

    Ogni \tbf{statement} (ossia un'istruzione o parte di essa) è terminato da un carattere \ttt{;}. Solitamente, all'interno di ogni statement sono presenti delle \tbf{keyword}, ossia delle "parole riservate" ben definite direttamente all'interno del linguaggio stesso (es: \ttt{if}, \ttt{int}, ...) 

    Di fondamentale importanza è la keyword \ttt{return <value>}, la quale imposta il valore di ritorno della funzione al valore \ttt{<value>}, terminando immediatamente l'esecuzione della funzione stessa e tornando alla funzione chiamante.

    All'interno del codice è possibile inserire \tbf{commenti}, ossia linee di testo ignorate dal compilatore, tramite due modalità:
    \begin{itemize}
        \item I caratteri \ttt{//} rendono un commento tutto ciò che è successivo ad essi fino alla fine della riga
        \item I caratteri \ttt{/*} rendono un commento tutto ciò che è successivo ad essi fino ai successivi caratteri \ttt{*/}
    \end{itemize}

    Vediamo quindi un primo esempio di programma in linguaggio C in grado di stampare sul terminale la stringa \ttt{"Hello World!"}:

    \begin{verbatim}
    #include <stdio.h>

    int main() {
        printf(“Hello World!\n”);    //stampa sul terminale
        return 0;   // terminato con successo
    }
    \end{verbatim}
    \quad

    \section{Ambiente di sviluppo}

    Tra le caratteristiche principali del linguaggio C troviamo l'\tbf{indipendenza dall'hardware}, in grado di rendere le applicazioni compilabili ed eseguibili su ogni tipo di processore (con eventuali leggere modifiche al codice, se necessario).

    L'\tbf{ambiente di sviluppo} relativo al linguaggio C prevedere \tbf{4 fasi} necessarie alla creazione di un programma, ognuna svolta da un programma indipendente:
    \begin{enumerate}
        \item Il programmatore scrive il codice del programma tramite un \tbf{editor di testo} 
        \item Il \tbf{pre-processore} (o pre-compilatore) processa il codice, eseguendo varie direttive e preparando la compilazione
        \item Il \tbf{compilatore} compila il codice, producendo un \tbf{file oggetto}, ossia una parte incompleta del programma finale e non eseguibile
        \item Il \tbf{linker} collega tra loro i vari file oggetto, creando il \tbf{file eseguibile} finale
    \end{enumerate}

    \begin{center}
        \includegraphics[scale=0.225]{images/c_1.png}
    \end{center}
    
    Nel sistema operativo GNU/Linux, il \tbf{programma \ttt{gcc} (GNU Compiler Collection)} è in grado di svolgere tutte le fasi necessarie alla creazione di un file eseguibile.

    Per \tbf{precompilare un programma C}, ossia far eseguire al pre-processore tutte le sue direttive ed eliminare i commenti, è possibile utilizzare il comando \ttt{cpp program.c > precompiled.c}. Tramite il carattere \ttt{\#} vengono definite le \tbf{direttive del pre-processore}, come la direttiva \textbf{\ttt{\#include filename}}:

    \label{include}

    \begin{frameddefn}{Direttiva \ttt{\#include}}
        La direttiva \textbf{\ttt{\#include filename}} impone al pre-processore di inserire il contenuto del file specificato al posto della direttiva stessa.
        
        I file inclusi seguono (non necessariamente) la seguente struttura:
        \begin{itemize}
            \item Possiedono un'estensione \ttt{.h} (es: \ttt{filename.h}) e vengono detti \tbf{header file}
            \item Se circondati dai caratteri \ttt{< >}, viene specificato che il header file è un file standard del linguaggio C ed è situato nella directory \ttt{/usr/include} (es: \ttt{\#include <stdio.h>})
            \item Se circondati dai caratteri \ttt{" "}, viene specificato che il header file è dell'utente e che si trova nella directory corrente o in un path specificato (es: \ttt{\#include "file.h"}). Vedere il manuale del comando \ttt{gcc} per maggiori informazioni.
        \end{itemize}
    \end{frameddefn}

    Per \tbf{compilare un programma C}, è possibile utilizzare il comando \ttt{gcc program1.c program2.c ...}, dove uno dei solo dei file specificati contiene la funzione \ttt{main()} del programma.
    
    Il programma \ttt{gcc} include molte opzioni:

    \begin{itemize}
        \item L'opzione \ttt{[-Wall]} mostra tutti i messaggi di avvertimento (warning) presenti alla compilazione
        \item L'opzione \ttt{[-Wextra]} mostra ulteriori warning "non-standard"
        \item L'opzione \ttt{[-o filename]} permette di specificare il nome del file di output. Se non utilizzata, il nome utilizzato sarà \ttt{a.out}
        \item L'opzione \ttt{[-c]} effettua solo la compilazione, dando per assunto che il file in input sia stato pre-compilato (vedi in seguito)
        \item L'opzione \ttt{[-lm]} permette di includere librerie matematiche come \ttt{<math.h>}
    \end{itemize}

    Inoltre, a seconda dei file in input specificati, il comando \ttt{gcc} assume comportamenti diversi:
    \begin{itemize}
        \item Tramite il comando \ttt{gcc -c precompiled.c}, dove \ttt{precompiled.c} è stato precompilato, viene eseguita solo la \tbf{compilazione}:
        \begin{itemize}
            \item Viene controllato che la sintassi del codice sia corretta
            \item Per ogni chiamata di funzione, viene controllato che venga rispettato il rispettivo header
            \item Viene creato dell'effettivo codice macchina, ma solo per il contenuto delle funzioni
            \item Ogni chiamata a funzione possiede una destinazione simbolica
        \end{itemize}
        \item Tramite il comando \ttt{gcc -c file.c -o file.o}, dove \ttt{file.c} non è stato precompilato, viene eseguita sia la \tbf{precompilazione} sia la \tbf{compilazione}
        \item Tramite il comando \ttt{gcc file.o}, dove \ttt{file.o} è stato compilato, viene effettuato il \tbf{linking}:
        \begin{itemize}
            \item Vengono risolte le chiamate a funzione, aggiungendo anche il blocco di ognuna di esse alla loro intestazione
            \item L'implementazione di tali funzioni può essere data dal programmatore o fornita tramite librerie di sistema
            \item L'inclusione delle librerie può essere automatica o specificata dall'utente
        \end{itemize}
        \item Tramite il comando \ttt{gcc file.c}, dove file.c non è precompilato, vengono eseguite tutte le fasi
    \end{itemize}

    \quad

    \section{Variabili ed tipi di dato}

    Come nella maggior parte dei linguaggi di programmazione, il linguaggio C fornisce il supporto per l'uso di \textbf{variabili}, ossia delle locazioni in memoria in cui può essere memorizzato un valore che verrà utilizzato dal programma stesso.
    
    Ogni variabile deve essere \textbf{dichiarata}, ossia ne deve essere definita la struttura, prima di poter \textbf{assegnare} un valore ad essa, ossia modificarne il valore "contenuto" al suo interno.

    In particolare, definiamo il primo assegnamento effettuato su una variabile o costante come \textbf{inizializzazione}. Inoltre, è possibile inizializzare una variabile anche durante la sua dichiarazione:

    \begin{verbatim}
    void main() {
        int x;  //dichiaro una variabile
        x = 5;  //inizializzo la variabile
        
        const int y = 0;    //dichiaro ed inizializzo una costante
    }
    \end{verbatim}

    Ogni variabile o costante possiede un \textbf{identificatore}, ossia un nome utilizzato dal programmatore e dal compilatore per tale variabile.
    
    \newpage

    Gli identificatori delle variabili (o costanti) devono rispettare le seguenti regole:
    \begin{enumerate}
        \item Il primo carattere deve essere una lettera o un underscore (ossia \ttt{\_}) e può essere seguito solo da lettere, numeri o underscore
        \item Il nome è \textit{case sensitive}, ossia vi è distinzione tra lettere maiuscole e minuscole
        \item Un'identificatore non può coincidere con una keyword del linguaggio
        \item La lunghezza massima per un identificatore è pari a 31 caratteri
    \end{enumerate}

    \begin{center}
        \begin{tabular}{cc}
            \textbf{Esempi validi} & \textbf{Esempi non validi}\\
            \hline
            distance & x-ray\\
            distance32 & 2ndGrade\\
            milesPerHour & \$amount\\
            \_voltage & two\&four\\
            goodChoice & after five\\
            MIN\_RATE & return\\
        \end{tabular}
    \end{center}
    
    \begin{framedprop}{Dichiarazione di variabili e costanti}
        Per dichiarare una lista di variabili viene utilizzato il seguente statement:
        \[\ttt{optional\_modifier data\_type name\_list}\]

        dove:
        \begin{itemize}
            \item Il campo \ttt{name\_list} è una \textbf{lista di identificatori} (uno per ogni variabile che si sta dichiarando)
            \item Il campo \ttt{data\_type} specifica il \textbf{tipo di valore} della variabile, permettendo al compilatore di sapere quali sono le operazioni consentite e come esso debba esser rappresentato in memoria
            \item Il campo \ttt{optional\_modifier} definisce delle "modifiche" opzionali al tipo di valore assunto dalla variabile. In particolare, al suo interno può essere specificata una (o nessuna) keyword dei seguenti tre insiemi:
            \begin{itemize}
                \item I modificatori \ttt{signed} o \ttt{unsigned} indicano se nel tipo di valore debba essere considerato il segno o meno (es: per i numeri negativi). Le variabili \ttt{signed} hanno accesso ad un range di valori più alto. Se omesso, esso è impostato di default a \ttt{signed}.
                 
                \item I modificatori \ttt{short} o \ttt{long} indicano se si voglia una variabile di dimensione inferiore o superiore rispetto alla dimensione normale utilizzata dal tipo di valore. Se omesso, viene utilizzata la dimensione normale.
                
                \item I modificatori \ttt{const} indicano se la variabile sia una costante, ossia che una volta inizializzata essa non possa mai più modificata. Se omesso, la variabile non sarà una costante.
            \end{itemize}
        \end{itemize}
    \end{framedprop}

    \newpage

    In particolare, considerando anche i modificatori, il linguaggio C dispone dei seguenti \textbf{tipi base di variabile intera}: 

    \label{placeholder}
    
    \begin{center}
        \begin{tabular}{lccc}
            \textbf{Tipo} & \textbf{Num. Byte} & \textbf{Intervallo} & \textbf{Placeholder}\\
            \hline
            \texttt{char} & 1 byte & $[-2^7, 2^7-1]$ o $[0, 2^8-1]$ & \ttt{\%c} o \ttt{\%hhi}\\
            \hline
            \texttt{signed char} & 1 byte & $[-2^7, 2^7-1]$ & \ttt{\%c} o \ttt{\%hhi}\\
            \hline
            \texttt{unsigned char} & 1 byte & $[0, 2^8-1]$ & \ttt{\%c} o \ttt{\%hhi}\\
            \hline
            \multicolumn{1}{p{0.3 \textwidth}}{\ttt{short \newline short int \newline signed short \newline signed short int}} & 2 byte & $[-2^{15}, 2^{15}-1]$ & \ttt{\%hd} o \ttt{\%hi}\\
            \hline
            \multicolumn{1}{p{0.3 \textwidth}}{\ttt{unsigned short \newline unsigned short int}} & 2 byte & $[0, 2^{16}-1]$ & \ttt{\%hu}\\
            \hline
            \multicolumn{1}{p{0.3 \textwidth}}{\ttt{int \newline signed \newline signed int}} & 2 o 4 byte & $[-2^{15}, 2^{15}-1]$ o $[-2^{31}, 2^{31}-1]$ & \ttt{\%d} o \ttt{\%i}\\
            \hline
            \multicolumn{1}{p{0.3 \textwidth}}{\ttt{unsigned \newline unsigned int}} & 2 o 4 byte & $[0, 2^{16}-1]$ o $[0, 2^{32}-1]$ & \ttt{\%u}\\
            \hline
            \multicolumn{1}{p{0.3 \textwidth}}{\ttt{long \newline long int \newline signed long \newline signed long int}} & 4 byte & $[-2^{31}, 2^{31}-1]$ & \ttt{\%ld} o \ttt{\%li}\\
            \hline
            \multicolumn{1}{p{0.3 \textwidth}}{\ttt{unsigned long \newline unsigned long int}} & 4 byte & $[0, 2^{32}-1]$ & \ttt{\%lu}\\
            \hline
            \multicolumn{1}{p{0.3 \textwidth}}{\ttt{long long\newline long long int \newline signed long long \newline signed long long int}} & 8 byte & $[-2^{63}, 2^{63}-1]$ & \ttt{\%lld} o \ttt{\%lli}\\
            \hline
            \multicolumn{1}{p{0.3 \textwidth}}{\ttt{unsigned long long \newline unsigned long long int}} & 8 byte & $[0, 2^{64}-1]$ & \ttt{\%llu}\\
        \end{tabular}
    \end{center}

    \quad

    Per quanto riguarda i \textbf{tipi base di variabile reale} (ossia in \textbf{notazione floating-point} (Standard IEEE 754)), si dispone dei seguenti tipi:


    \begin{center}
        \begin{tabular}{lcccc}
            \textbf{Tipo} & \textbf{Num. Byte} & \textbf{Intervallo} & \textbf{Cifre decimali} & \textbf{Placeholder}\\
            \hline
            \texttt{float} & 4 byte & $[1.2 \cdot 10^{-38}, 3.4 \cdot 10^{38}]$ & 6 & \ttt{\%f} o \ttt{\%e}\\
            \hline
            \texttt{double} & 8 byte & $[2.3 \cdot 10^{-308}, 1.7 \cdot 10^{308}]$ & 15 & \ttt{\%lf} o \ttt{\%Le}\\
            \hline
            \texttt{double} & 10 byte & $[3.4 \cdot 10^{-4932}, 1.1 \cdot 10^{4932}]$ & 19 & \ttt{\%Lf} o \ttt{\%Le}
        \end{tabular}
    \end{center}

    \begin{framedobs}{}
        I \textbf{limiti massimi e minimi dell'intervallo}di ogni tipo possono facilmente essere ottenuti importando la libreria \ttt{<limits.h>} (es: la costante \ttt{INT\_MAX} corrisponde al limite massimo dell'intervallo del tipo \ttt{int})
    \end{framedobs}

    \begin{framedprop}{Operatore sizeof}
        Il \textbf{numero di byte} occupati da un tipo di dato (non solo quelli base) può essere ottenuto tramite l'operatore \ttt{sizeof(type)}, dove \ttt{type} è il tipo di dato interessato
    \end{framedprop}

    \begin{framedobs}{}
        Al tipo \ttt{char} può essere assegnato un \href{http://www.asciitable.com/}{\textbf{carattere ASCII}} circondandolo tra due caratteri \ttt{'} (es: \ttt{char x = 'A';}).
        
        Il carattere assegnato viene automaticamente convertito dal compilatore nel suo valore decimale (es: \ttt{char x = 'A'} equivale a \ttt{char x = 65;})
    \end{framedobs}

    Inoltre, abbiamo due tipi di dato relativi ai \textbf{valori booleani}:
    \begin{itemize}
        \item Il tipo \ttt{\_Bool}, utilizzato implicitamente dal compilatore. Può memorizzare solo il valore 0 e il valore 1. Ad esso può essere assegnato il risultato di un'\textbf{espressione logica} (se il risultato è 0, verrà assegnato 0, altrimenti verrà assegnato 1, indipendentemente dal valore)
        \item Il tipo \ttt{bool}, richiedente l'importazione della libreria \ttt{<stdbool.h>}. Può assumere solo i valori \ttt{true} e \ttt{false}. Se ad esso viene assegnato il valore 0, verrà interpretato come \ttt{false}, altrimenti come \ttt{true}, indipendentemente dal valore.
    \end{itemize}
    
    \textbf{Esempio:}

    \begin{verbatim}
    #include <stdbool.h>

    void main(){
        bool x;
        x = 0;      //viene assegnato false
        x = 1;      //viene assegnato true
        x = 4316;   //viene assegnato true
    }
    \end{verbatim}

    \begin{frameddefn}{Casting}
        Definiamo come \textbf{casting} la conversione di un valore di un tipo ad un altro tipo. Per effettuare il casting della variabile \ttt{var} al tipo \ttt{type}, è sufficiente utilizzare l'\textbf{operatore} \ttt{(type) var}.
    \end{frameddefn}

    \begin{framedobs}{}
        Il casting di un valore potrebbe generare \textbf{effetti indesiderati} (es: castando un valore float in un intero, verrà troncata la parte decimale del valore)
    \end{framedobs}

    \newpage

    \textbf{Esempio:}
    \begin{verbatim}
    void main(){
        float x = 7.3;
        int y = (int) x;    //7.3 viene convertito in 7
    }
    \end{verbatim}

    \section{Input e output da terminale}

    Tutte le funzionalità relative all'\textbf{input} e all'\textbf{output} vengono fornite dalla libreria di sistema \ttt{<stdio.h>}.

    In particolare, all'interno di tale libreria viene fornita la funzione \ttt{printf(format\_string, value1, value2, ...)}, la quale si occupa di \textbf{scrivere} la stringa \ttt{format\_string} data in input sullo \textbf{stdout}.
    
    La stringa \ttt{format\_string} data in input può contenere al suo interno dei \textbf{placeholder} (sezione \ref{placeholder}). Al posto dell'$n$-esimo placeholder verrà inserito il valore assunto dall'$n$-esimo valore dato in input alla funzione \ttt{printf()}.

    \textbf{Esempio:}
    \begin{verbatim}
    int main(){
        int x = 5;

        printf("Il valore di x è: %d", x);
        //viene stampato "Il valore di x è: 5"

        printf("Il valore di x+%d è: %d", 5, x+5);
        //viene stampato "Il valore di x+5 è: 10"
    }
    \end{verbatim}

    All'interno delle stringhe formattate è possibile specificare il \textbf{formato di un placeholder}, ossia la modalità con cui il valore ad esso associato debba essere interpretato:
    \[\ttt{\%[parameter][flags][width][.precision][length]type}\]

    \textbf{Esempio:}

    \begin{itemize}
        \item Il placeholder \ttt{\%.3f} indica che il valore associato debba essere interpretato come un \ttt{float} avente 3 cifre decimali. Per tanto, l'istruzione \ttt{printf(".3f", x)} stamperà le prime 3 cifre decimali della variabile \ttt{x}
    \end{itemize}

    \begin{framedobs}{}
        I placeholder \ttt{\%b}, \ttt{\%o} e \ttt{\%x} indicano che i valori ad essi associati sono da interpretate rispettivamente come un intero binario, un intero ottale e un intero esadecimale. 
    \end{framedobs}

    \newpage

    \begin{frameddefn}{Escape sequences}
        All'interno delle stringhe formattate è possibile controllare la \textbf{spaziatura orizzontale e verticale} utilizzando le \textbf{escape sequences}, ossia caratteri ASCII speciali in grado di spostare il cursore di scrittura:
        \begin{itemize}
            \item Il carattere \ttt{\textbackslash b} (\textbf{backspace}) sposta il cursore sul carattere precedente
            \item Il carattere \ttt{\textbackslash r} (\textbf{carriage return}) sposta il cursore all'inizio della riga
            \item Il carattere \ttt{\textbackslash f} (\textbf{form feed}) sposta il cursore alla riga successiva, mantenendo lo stesso allineamento orizzontale precedente
            \item Il carattere \ttt{\textbackslash n} (\textbf{line feed}) sposta il cursore all'inizio della riga successiva (ha lo stesso effetto di \ttt{\textbackslash f\textbackslash r} e \ttt{\textbackslash r\textbackslash f})
            \item Il carattere \ttt{\textbackslash t} (\textbf{horizontal tab}) sposta il cursore al tab orizzontale successivo
            \item Il carattere \ttt{\textbackslash v} (\textbf{vertical tab}) sposta il cursore al tab verticale successivo (equivalente a \ttt{\textbackslash f} in molti shell moderni)
        \end{itemize}
    \end{frameddefn}

    \textbf{Esempio:}

    \begin{itemize}
        \item L'istruzione
        \[\ttt{printf("aa\textbackslash bkaaa\textbackslash fbbbbb\textbackslash f\textbackslash rc\textbackslash tcccc\textbackslash r\textbackslash fddddd\textbackslash reeeee\textbackslash nfffff");}\]
        produce il seguente output:

        \begin{verbatim}
        akaaa
             bbbbb
        c   ccc
        eeeee
        fffff
        \end{verbatim}
    \end{itemize}

    Molto simile alla funzione \ttt{printf()} è la funzione di libreria \ttt{scanf(format\_string, address1, address2, ...)}. A differenza della precedente funzione, essa è in grado \textbf{leggere} dati dallo \textbf{stdin}.

    La stringa \ttt{format\_string} data in input può contenere al suo interno dei \textbf{placeholder} del tutto analoghi a quelli di \ttt{printf()}: l'$n$-esimo valore contenuto nell'input di stdin verrà interpretato con il formato indicato dall'$n$-esimo placeholder, inserendo il valore interpretato all'interno dell'$n$-esimo indirizzo di memoria fornito in input alla funzione \ttt{scanf()}.
    
    \begin{framedprop}{Operatore di riferimento}
        Il simbolo \ttt{\&} posto davanti all'identificatore di una variabile permette di ottenere il suo \textbf{indirizzo di memoria} (es: \ttt{\&var} restituisce l'indirizzo di \ttt{var}).

        Tale operatore viene detto \textbf{riferimento}.
    \end{framedprop}

    \textbf{Esempio:}

    \begin{itemize}
        \item Supponiamo che venga eseguita l'istruzione \ttt{scanf("\%d \%f", \&x, \&y)}
        \item Supponiamo inoltre che l'input dato su stdin sia "123 123.24"
        \item Il contenuto delle variabili \ttt{x} e \ttt{y} dopo la lettura sarà rispettivamente $123$ e $123.24$
    \end{itemize}

    \begin{framedobs}{}
        La funzione \ttt{printf()} restituisce in output il numero di caratteri stampati, mentre la funzione \ttt{scanf()} restituisce il numero di valori letti correttamente.
    \end{framedobs}

    Se viene passato in input ad stdin un valore di un \textbf{formato diverso da quello atteso} dalla funzione \ttt{scanf()}, la funzione smetterà di interpretare l'input e di assegnare i valori, bloccandosi nel mezzo. In alcune situazioni, ad esempio se viene passato un carattere in input quando il formato atteso era un float, l'input di stdin potrebbe \textbf{rimanere bloccato fino alla chiusura del programma}. Per tanto, si consiglia di sperimentare molto con la funzione \ttt{scanf()}.

    \quad

    \section{Operatori aritmetici, bit-wise e logici}

    Come molti altri linguaggi, il linguaggio C fornisce i seguenti operatori aritmetici:
    \begin{itemize}
        \item L'operatore \ttt{val1 + val2} restituisce la somma tra i valori \ttt{val1} e \ttt{val2}
        \item L'operatore \ttt{val1 - val2} restituisce la differenza tra i valori \ttt{val1} e \ttt{val2}
        \item L'operatore \ttt{val1 * val2} restituisce il prodotto tra i valori \ttt{val1} e \ttt{val2}
        \item L'operatore \ttt{val1 / val2} restituisce il quoziente tra i valori \ttt{val1} e \ttt{val2}.
        \item L'operatore \ttt{val1 \% val2} restituisce il resto del quoziente tra i valori \ttt{val1} e \ttt{val2}
    \end{itemize}

    \begin{framedobs}{}
        L'operatore \ttt{/} dipende dai \textbf{tipi di dato degli operandi}:
        \begin{itemize}
            \item Il risultato è dello \textbf{stesso tipo dell'operando più grande} in termini di tipi di dato (es: un float è più grande di un intero)
            \item Il tipo del risultato potrebbe subire delle \textbf{approssimazioni} (es: dividere un intero per un'altro intero approssima per difetto il risultato della divisione)
        \end{itemize}
    \end{framedobs}

    \newpage

    Oltre agli operatori aritmetici, viene fornito il supporto anche per \textbf{operatori bit-wise (bit-a-bit)}, ossia operatori binari applicati sui singoli bit che rappresentano un valore:
    \begin{itemize}
        \item L'operatore \ttt{val1 \& val2} restituisce il bit-wise AND tra i bit dei valori \ttt{val1} e \ttt{val2} (es: se in binario si ha \ttt{val1 = 10111} e \ttt{val2 = 00101}, allora \ttt{val1 \& val2} è uguale a \ttt{00101})
        \item L'operatore \ttt{val1 | val2} restituisce il bit-wise OR tra i bit dei valori \ttt{val1} e \ttt{val2} (es: se in binario si ha \ttt{val1 = 10111} e \ttt{val2 = 00101}, allora \ttt{val1 | val2} è uguale a \ttt{10111})
        \item L'operatore \ttt{val1 \textasciicircum \;val2} restituisce il bit-wise XOR tra i bit dei valori \ttt{val1} e \ttt{val2} (es: se in binario si ha \ttt{val1 = 10111} e \ttt{val2 = 00101}, allora \ttt{val1 \textasciicircum\; val2} è uguale a \ttt{10010})
        \item L'operatore \ttt{!val1} restituisce il bit-wise NOT tra i bit del valore \ttt{val1}  (es: se in binario si ha \ttt{val1 = 10111}, allora \ttt{!val1} è uguale a \ttt{01000})
        \item L'operatore \ttt{val1 <\.< val2} shifta a sinistra i bit del valore \ttt{val1} di \ttt{val2} posizioni (es: se in binario si ha \ttt{val1 = 10111} e in decimale \ttt{val2 = 2}, allora \ttt{val1 <\.< val2} è uguale a \ttt{11100})
        \item L'operatore \ttt{val1 >\.> val2} shifta a destra i bit del valore \ttt{val1} di \ttt{val2} posizioni (es: se in binario si ha \ttt{val1 = 10111} e in decimale \ttt{val2 = 2}, allora \ttt{val1 >\.> val2} è uguale a \ttt{00101}).
        
        Se il valore \ttt{val1} è \ttt{unsigned}, allora lo shift effettuato sarà di tipo logico, altrimenti sarà di tipo aritmetico.
    \end{itemize}

    Infine, il linguaggio C fornisce anche il supporto agli \textbf{operatori logici} ed \textbf{operatori di confronto}:
    \begin{itemize}
        \item L'operatore \ttt{exp1 \&\& exp2} valuta l'AND logico tra le espressioni \ttt{exp1} e \ttt{exp2}
        \item L'operatore \ttt{exp1 || exp2} valuta l'OR logico tra le espressioni \ttt{exp1} e \ttt{exp2}
        \item L'operatore \ttt{!exp1} valuta il NOT logico dell'espressione \ttt{exp1}
        \item L'operatore \ttt{val1 == val2} valuta se \ttt{val1} sia uguale a \ttt{val2}
        \item L'operatore \ttt{val1 != val2} valuta se \ttt{val1} sia diverso da \ttt{val2}
    \end{itemize}


    \begin{framedobs}{}
        Per quanto riguarda gli operatori logici, ricordiamo che se un valore è uguale a 0 esso viene interpretato come \ttt{false}, altrimenti viene interpretato come \ttt{true}
    \end{framedobs}

    \newpage

    La maggior parte degli operatori visti gode di possibili \textbf{abbreviazioni}:
    \begin{center}
        \begin{tabular}{c|c}
            \textbf{Operatore} & \textbf{Abbreviazione}\\
            \hline
            \ttt{var = var + 1} & \ttt{var++} o \ttt{++var}\\
            \ttt{var = var - 1} & \ttt{var----} o \ttt{----var}\\
            \ttt{var = var + val\_var} & \ttt{var += val\_var}\\
            \ttt{var = var - val\_var} & \ttt{var -= val\_var}\\
            \ttt{var = var * val\_var} & \ttt{var *= val\_var}\\
            \ttt{var = var / val\_var} & \ttt{var /= val\_var}\\
            \ttt{var = var \% val\_var} & \ttt{var \%= val\_var}\\
            \ttt{var = var \& val\_var} & \ttt{var *= val\_var}\\
            \ttt{var = var | val\_var} & \ttt{var *= val\_var}\\
            \ttt{var = var \textasciicircum val\_var} & \ttt{var \textasciicircum = val\_var}\\
            \ttt{var = var <\.< val\_var} & \ttt{var <\.<= val\_var}\\
            \ttt{var = var >\.> val\_var} & \ttt{var >\.>= val\_var}\\
        \end{tabular}
    \end{center}

    \begin{framedobs}{Operatori \ttt{++} e \ttt{----}}
        L'operatore \ttt{++} può essere utilizzato in due modalità:
        \begin{itemize}
            \item \textbf{Pre-incremento}: se l'operatore \ttt{++var} è inserito all'interno di un'espressione, l'incremento verrà effettuato prima della valutazione dell'espressione
            \item \textbf{Post-incremento}: se l'operatore \ttt{var++} è inserito all'interno di un'espressione, l'incremento verrà effettuato dopo la valutazione dell'espressione
        \end{itemize}

        Lo stesso vale per l'operatore \ttt{----}.
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    void main(){
        int x = 0;
        int y;

        y = 2 * (++x);
        /*
            verrà prima incrementato x, per poi valutare
            l'espressione, dunque x = 1 e y = 2
        */

        x = 0;
        y = 2 * (x++);
        /*
            verrà prima valutata l'espressione, per poi
            incrementare x, dunque x = 1 e y = 0
        */
    }\end{verbatim}

    \newpage

    \subsection{Precedenza degli operatori}
    Nel linguaggio C, gli operatori delle espressioni vengono valutati con la seguente precedenza (più basso è il numero, maggiore è la precedenza):

    \begin{center}
        \begin{tabular}{cll}
            \textbf{Precedenza} & \textbf{Operatore} & \textbf{Descrizione}\\
            \hline
            1 & \ttt{++ ----} & Post-incremento e Post-decremento\\
            & \ttt{.} & Accesso attributo di uno struct\\
            & \ttt{->} & Accesso attributo di uno struct tramite puntatore\\
            \hline
            2 & \ttt{++ ----} & Pre-incremento e Pre-decremento\\
             & \ttt{!} & NOT bit-wise e logico\\
             & \ttt{*} & De-riferimento\\
             & \ttt{\&} & Riferimento\\
             & \ttt{sizeof} & Operatore sizeof\\
            \hline
            3 & \ttt{* / \%} & Moltiplicazione, divisione e resto\\
            \hline
            4 & \ttt{+ -} & Addizione e sottrazione\\
            \hline
            5 & \ttt{<\.< >\.>} & Shift sinistro e destro\\
            \hline
            6& \ttt{< <=} & Minore e minore uguale\\
            & \ttt{> >=} & Maggiore e maggiore uguale\\
            \hline
            7 & \ttt{== !=} & Uguale e diverso\\
            \hline
            8 & \ttt{\&} & AND bit-wise\\
            \hline
            9 & \ttt{\textasciicircum} & XOR bit-wise\\
            \hline
            10 & \ttt{|} & OR bit-wise\\
            \hline
            11 & \ttt{\&\&} & AND logico\\
            \hline
            12 & \ttt{||} & OR logico\\
            \hline
            13 & \ttt{?:} & Operatore ternario\\
            \hline
            14 & \ttt{=} & Assegnamento\\
            & \ttt{+= -=} & Somma e differenza con assegnamento\\
            & \ttt{*= /= \%=} & Prodotto, quoziente e resto con assegnamento\\
            & \ttt{<\.<= >\.>=} & Shift sinistro e destro con assegnamento\\
            & \ttt{\&= \textasciicircum = |=} & AND, XOR e OR bit-wise con assegnamento\\
        \end{tabular}
    \end{center}

    \quad

    \textbf{Nota:} all'interno della precedente tabella sono stati inseriti anche operatori ancora visti fino a questo punto. Tali operatori verranno discussi nelle sezioni successive.

    \textbf{Esempio:}

    \begin{itemize}
        \item Se $x = 1$ e $y = 7$, l'espressione \ttt{(x \& y) == (x \&\& y)} viene valutata come \ttt{true}
        \item Se $x = 1$ e $y = 7$, l'espressione \ttt{x \& y | x == y} viene valutata come 1, poiché le sue operazioni vengono valutate come se l'espressione fosse \ttt{(x \& y) | (x == y)}
    \end{itemize}

    \newpage

    \section{Costrutti condizionali, iterativi e funzioni}

    \subsection{Blocchi di istruzioni}

    \begin{frameddefn}{Blocco}
        Definiamo come \textbf{blocco} una porzione di codice racchiusa da delle parentesi graffe (es: \ttt{\{ ... \}}).

        Le variabili definite all'interno di un blocco sono \textbf{locali} al blocco stesso, ossia:
        \begin{itemize}
            \item Un blocco può contenere dei \textbf{sotto-blocchi}
            \item Le variabili dichiarate in un blocco vengono \textbf{allocate sullo stack} e sono \textbf{accessibili solo all'interno del blocco stesso e dei suoi sotto-blocchi}
            \item Una volta che un blocco è terminato, tutte le variabili dichiarate in esso vengono automaticamente \textbf{de-allocate} dallo stack 
        \end{itemize}
    \end{frameddefn}

    \textbf{Esempi:}

    \begin{verbatim}
    void ex1(){
        {
            int i = 0;  //la variabile i è accessibile
            printf("i = %d\n", i);
        }
        
        //la variabile i non esiste più, generando un errore
        printf("i = %d\n", i);
    }

    void ex2(){
        int x = -1;

        //la variabile i è accessibile anche dai sotto-blocchi
        {
            printf("i = %d\n", i);  //viene stampato -1
            i++;
        }
        printf("i = %d\n", i);  //viene stampato 0
    }\end{verbatim}

    \begin{framedobs}{Oscuramento nei blocchi}
        Se all'interno di un sotto-blocco viene dichiarata una variabile con lo \textbf{stesso nome di una variabile dichiarata in un suo sovra-blocco}, tale variabile viene \textbf{oscurata}, ossia il nome farà riferimento alla nuova variabile del sotto-blocco, venendo poi "ricollegato" alla variabile del sovra-blocco una volta che il blocco è concluso
    \end{framedobs}

    \textbf{Esempio:}
    \begin{verbatim}
    void main(){   
        int x = -1;

        {
            //la variabile x del sovra-blocco viene oscurata
            int x = 0;  

            printf("i = %d\n", i);  //viene stampato 0
        }
        
        //il nome "x" fa di nuovo riferimento alla
        //variabile del sovra-blocco
        printf("i = %d\n", i);  //viene stampato -1
    }
    \end{verbatim}

    \subsection{Costrutti condizionali}
    
    Come ogni altro linguaggio di programmazione, il linguaggio C fornisce il \textbf{costrutto condizionale} \ttt{if(condition)}. Tale costrutto contiene al suo interno un \textbf{blocco di istruzioni}, il quale viene eseguito se e solo se la condizione interna all'if viene valutata come \ttt{true}.

    \textbf{Esempio:}

    \begin{verbatim}
    if(x <= y){
        //istruzioni eseguite se valutato true
    }
    \end{verbatim}

    Inoltre, viene fornito anche il costrutto \ttt{if/else}, il quale possiede un \textbf{aggiuntivo blocco di istruzioni} che viene eseguito se e solo se la condizione viene valutata come \ttt{false}.

    \textbf{Esempio:}

    \begin{verbatim}
    if(x <= y){
        //istruzioni eseguite se valutato true
    }
    else{
        //istruzioni eseguite se valutato false
    }
    \end{verbatim}

    \begin{framedobs}{}
        Se all'interno di un costrutto \ttt{if} o \ttt{if/else} non viene specificato un blocco if o un blocco else, la \textbf{prima istruzione successiva} verrà considerata come il blocco stesso. 
    \end{framedobs}

    \newpage

    \textbf{Esempi:}

    \begin{verbatim}
    //i seguenti costrutti sono tutti equivalenti tra loro

    //-----

    if(...){
        printf("true");
    }
    else{
        printf("false");
    }

    //-----

    if(...){
        printf("true");
    }
    else printf("false");

    //-----

    if(...) printf("true");
    else{
        printf("false");
    }

    //-----

    if(...) printf("true");
    else printf("false");

    //-----

    if(...)
        printf("true");
    else
        printf("false");
    
    //-----

    if(...) printf("true"); else printf("false");
    \end{verbatim}

    \begin{framedprop}{Operatore ternario}
        L'\textbf{operatore ternario} restituisce uno \textbf{tra due valori indicati} in base ad una \textbf{condizione}: se tale condizione viene valutata \ttt{true}, verrà restituito il primo, altrimenti il secondo
        \[\ttt{(condition) ? value\_if\_true : value\_if\_false}\]
    \end{framedprop}

    L'operatore ternario può essere utilizzato per effettuare \textbf{assegnamenti condizionati} in modo rapido.

    \textbf{Esempio:}

    \begin{verbatim}
    x = (a < b) ? 1000 : -20;

    //è equivalente a

    if(a < b){
        x = 1000;
    }
    else{
        x = -20;
    }
    \end{verbatim}

    \begin{framedobs}{}
        I costrutti condizionali possono essere \textbf{concatenati tra loro}
    \end{framedobs}

    \textbf{Esempio:}
    
    \begin{verbatim}
    if(...){
        //caso 1
    }
    else if(...){
        //caso 2
    }
    else if(...){
        //caso 3
    }
    else{
        //tutti gli altri casi
    }
    \end{verbatim}

    In alcune situazioni, tale serie di casistiche dell'esempio precedente può essere realizzata anche tramite il \textbf{costrutto \ttt{switch}}, il quale, data un'espressione in input, permette di dettare le operazioni da svolgere a seconda del valore restituito da tale espressione

    \begin{verbatim}
    switch(value){
        case 1:
            //eseguito se value = 1
            break;
        case 2:
            //eseguito se value = 2
            break;

        ...

        case n:
            //eseguito se value = n
            break;
        default:
            //eseguito in ogni altro caso
            break;
    }
    \end{verbatim}

    Di fondamentale importanza all'interno dei costrutti switch risulta essere la keyword \ttt{break}, la quale permette di uscire immediatamente dallo switch. 
    
    Senza l'uso del break, il costrutto switch prosegue l'esecuzione delle istruzioni fornite in ogni \textbf{caso sottostante}.

    \textbf{Esempio:}

    \begin{verbatim}
    switch(value){
        case 1:
            //eseguito se value = 1
        case 2:
            //eseguito se value = 2 o value = 1
            break;
        default:
            //eseguito in ogni altro caso
            break;
    }
    \end{verbatim}

    \begin{framedobs}{}
        Ogni blocco interno ad un costrutto condizionale corrisponde ad un vero e proprio blocco di istruzioni. Per tanto, per esso valgono le \textbf{stesse regole}.
    \end{framedobs}

    \newpage

    \subsection{Costrutti iterativi}

    Il linguaggio C fornisce tre tipi di \textbf{costrutti iterativi}:
    \begin{itemize}
        \item Il costrutto \ttt{while}, il quale esegue il blocco dato finché la condizione data è vera
        \begin{verbatim}
        while(condition){
            //block
        }
        \end{verbatim}
        \item Il costrutto \ttt{do-while}, il quale esegue almeno una volta il blocco dato, per poi rieseguirlo finché la condizione data è vera
        \begin{verbatim}
        do{
            //block
        }
        while(condition);
        \end{verbatim}
        \item Il costrutto \ttt{for}, il quale permette di effettuare un'assegnamento o inizializzazione, per poi eseguire il blocco dato finché la condizione data è vera, effettuando (dopo ogni iterazione) l'incremento dato
        \begin{verbatim}
        for(initialization; condition; increment){
            //block
        }
        \end{verbatim}
    \end{itemize}

    \begin{center}
        \begin{tabular}{ccc}
            \textbf{While} & \textbf{Do-While} & \textbf{For}\\
            \includegraphics[scale=0.35]{images/while.png}
            &
            \includegraphics[scale=0.45]{images/do_while.png}
            &
            \includegraphics[scale=0.35]{images/for.png}
        \end{tabular}
    \end{center}

    \newpage

    \begin{verbatim}
    //le seguenti funzioni sono equivalenti

    void ex1(){
        for(int i=0; i <= 10; i++){
            printf("ciao");
        }
    }

    void ex2(){
        int i;
        for(i=0; i <= 10; i++){
            printf("ciao");
        }
    }

    void ex2(){
        int i=0;
        while(i <= 10){
            printf("ciao");
            i++;
        }
    }
    \end{verbatim}

    Come per il costrutto \ttt{switch}, anche all'interno dei costrutti iterativi può essere utilizzata la keyword \ttt{break}, uscendo immediatamente dal costrutto stesso. In aggiunta, all'interno dei costrutti iterativi è possibile utilizzare anche la keyword \ttt{continue}, la quale permette di interrompere l'esecuzione del blocco e saltare automaticamente all'iterazione successiva (effettuando sempre il controllo sulla condizione).

    \textbf{Esempio:}
    \begin{verbatim}
    for(int i=0; i <= 10; i++){
        ...
        break
        //viene direttamente terminato il for
        ...
        //queste istruzioni dopo il break non vengono eseguite
    }

    for(int i=0; i <= 10; i++){
        ...
        continue
        //si passa all'iterazione successiva
        ...
        //queste istruzioni dopo il continue non vengono eseguite
    }
    \end{verbatim}

    \begin{framedobs}{}
        Ogni blocco interno ad un costrutto iterativo corrisponde ad un vero e proprio blocco di istruzioni. Per tanto, per esso valgono le \textbf{stesse regole}.

        Inoltre, l'assegnamento effettuato all'interno del campo \ttt{initialization} di un ciclo \ttt{for}, viene considerato come \textbf{interno al blocco}, potenzialmente oscurando le variabili omonime precedenti
    \end{framedobs}

    \quad

    \subsection{Funzioni}

    Durante la fase di introduzione al linguaggio, abbiamo già discusso brevemente le \textbf{funzioni}. Ogni funzione consiste in un'\textbf{intestazione (header)}, a sua volta composta dal nome della funzione, dal tipo di valore ritornato e da una lista di parametri in input, e da un \textbf{blocco di istruzioni}:

    \begin{verbatim}
    <return-type> function-name (parameter-list){
        //block
    }
    \end{verbatim}

    In particolare, notiamo che:
    \begin{itemize}
        \item Il blocco di istruzioni di una funzione viene eseguito solo quando tale funzione viene \textbf{invocata (o chiamata)}.
        \item La lista dei parametri può essere anche vuota
        \item Il tipo di ritorno può essere un qualsiasi tipo di dato (dunque non necessariamente quelli standard del C)
        \item Il blocco di una funzione segue le regole di ogni altro blocco di istruzioni
        \item All'interno di una funzione è possibile definire un'altra funzione (la quale sarà invocabile solo all'interno del blocco della funzione stesso)
    \end{itemize}

    \textbf{Esempio:}

    \begin{verbatim}
    int somma(int a, int b){
        int c = a+b;
        return c;
    }

    int main(){
        int a = 5;
        int b = 6;
        int c = func(a, b);   //viene ritornato il valore 11
    }
    \end{verbatim}

    \label{void}
    \begin{frameddefn}{Tipo \ttt{void}}
        Il tipo di dato \ttt{void} è un \textbf{tipo speciale} con caratteristiche diverse dagli altri tipi:
        \begin{itemize}
            \item \textbf{Non esiste} un valore di tipo \ttt{void}
            \item Il \textbf{tipo di ritorno di una funzione} può essere impostato a \ttt{void} in modo che tale funzione non ritorni alcun valore.
            \item Assegnare un "valore di tipo \ttt{void}" (es: il valore "ritornato" da una funzione di tipo \ttt{void}) ad una variabile genererà un errore
            \item \textbf{Non può} essere utilizzato come tipo per la \textbf{dichiarazione di variabili}
            \item Un valore \textbf{non può essere castato} in \ttt{void}
        \end{itemize}
    \end{frameddefn}

    \begin{framedobs}{}
        Come per le variabili, anche le funzioni possono essere prima \textbf{dichiarate} per poi essere \ttt{definite}. Per dichiarare una funzione, è sufficiente scriverne l'intestazione. Per definirla, invece, è necessario ri-scrivere la sua intestazione e il seguente blocco.
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    void func(int a, int b);     //dichiarazione della funzione

    void func(int a, int b){     //definizione della funzione
        //block
    }\end{verbatim}

    \begin{framedobs}{}
        Se una funzione viene invocata prima che essa sia \textbf{dichiarata}, verrà generato un errore di compilazione. Se invece una funzione è \textbf{dichiarata} e viene invocata prima che essa sia \textbf{definita}, verrà generato un errore in fase di linking.

        Per tanto, una funzione può essere invocata correttamente solo se essa è \textbf{dichiarata e definita}.
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    void func2(){...}
    void func3();

    void func(int a, int b){
        func2();    //nessun errore (dichiarata e definita)
        func3();    //errore di linking (dichiarata ma non definita)
        func4();    //errore di compilazione (né dichiarata né definita)
    }\end{verbatim}

    \addtocontents{toc}{\protect\newpage}

    \section{Puntatori}

    \begin{frameddefn}{Puntatore}
        Un \textbf{puntatore} è una variabile speciale in grado di \textbf{contenere un indirizzo di memoria}. La dichiarazione di un puntatore corrisponde a:
        \[\ttt{type* pointer\_name}\]

        dove il campo \ttt{type} di un puntatore indica che il valore contenuto dall'indirizzo puntato è da interpretare come una variabile di tipo \ttt{type}

        \textbf{Nota:} solitamente, per la dichiarazione viene utilizzata anche la sintassi alternativa \ttt{type *pointer\_name} (la scelta ricade sul programmatore)
    \end{frameddefn}

    \textbf{Esempio:}

    \begin{verbatim}
    void main(){
        int x;
        
        //supponiamo che la variabile x venga
        //salvata nell'indirizzo di memoria 0x1234

        int* pointer = &x;  //pointer = 0x1234

        //ricordiamo che &x è l'operatore di riferimento,
        //il quale  restituisce l'indirizzo di x
    }
    \end{verbatim}

    \begin{framedprop}{Operatore di deriferimento}
        Il simbolo \ttt{*} posto davanti all'identificatore di un puntatore permette di \textbf{accedere} il \textbf{valore contenuto all'interno dell'indirizzo di memoria puntato}.
        
        (es: se \ttt{int x = 4} e \ttt{int* p = \&x}, allora \ttt{*p} restituisce 4)

        Tale operatore viene detto \textbf{deriferimento}
    \end{framedprop}


    \begin{frameddefn}{Valore diretto o indiretto}
        Dato il puntatore \ttt{type* pointer}, definiamo come \textbf{valore diretto} l'indirizzo di memoria contenuto al suo interno, mentre definiamo come \textbf{valore indiretto} il valore ottenibile tramite il deriferimento del puntatore stesso.
    \end{frameddefn}

    \begin{framedobs}{}
        L'accesso ad un indirizzo di memoria tramite il deriferimento permette anche di \textbf{modificare} il contenuto di tale indirizzo di memoria
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    void main(){
        int n = 5;
        int* ptr = &n;

        *ptr = 10;
        /*
            viene modificato il valore contenuto
            nell'indirizzo di memoria puntato,
            implicando che ora si abbia n = 10
        */ 
    }
    \end{verbatim}

    \begin{framedprop}{Aritmetica dei puntatori}
        Poiché l'indirizzo di memoria contenuto all'interno di un puntatore non è altro che un \textbf{valore intero}, su di esso possono essere applicate operazioni aritmetiche.
        
        Dato il puntatore \ttt{type* ptr}, l'\textbf{unità additiva} utilizzata per le operazioni aritmetiche su di esso sarà \ttt{sizeof(type)}.
    \end{framedprop}

    \textbf{Esempi:}

    \begin{itemize}
        \item Dato il puntatore \ttt{int* ptr} contenente l'indirizzo di memoria $x$, l'espressione \ttt{ptr + 1} viene valutata come $x + \ttt{sizeof(int)} = x+4$, restituendo quindi l'indirizzo successivo di 4 byte all'indirizzo $x$
        \item Dato il puntatore \ttt{int* ptr} contenente l'indirizzo di memoria $x$, l'espressione \ttt{ptr + 6} viene valutata come $x + 6 \cdot \ttt{sizeof(int)} = x+6 \cdot 4 = x+24$
        \item Dato il puntatore \ttt{char* ptr} contenente l'indirizzo di memoria $x$, l'espressione \ttt{ptr + 1} viene valutata come $x + \ttt{sizeof(char)} = x+1$
    \end{itemize}

    \newpage

    \subsection{Puntatore \ttt{void*} e valore \ttt{NULL}}

    \begin{frameddefn}{Puntatore \ttt{void*}}
    Essendo il tipo \ttt{void} un \textbf{tipo speciale} è possibile definire anche un puntatore di tipo \ttt{void*}, godendo delle seguenti caratteristiche:
    \begin{itemize}
        \item Ad un puntatore \ttt{void*} può essere assegnato l'indirizzo di memoria di una variabile di \textbf{qualsiasi tipo} (\textbf{puntatore polimorfico})
        \item Un puntatore \ttt{void*} non può \textbf{mai essere dereferenziato}, necessitando prima il casting in un altro tipo
    \end{itemize}
    \end{frameddefn}

    \textbf{Esempio:}

    \begin{verbatim}
    void main(){
        int x = 10;
        char y = 'A';
        char* z = &y;
        
        void* ptr;

        ptr = &x;
        x = *(int*) ptr + 10;   //viene prima castato e poi dereferenziato
    
        //NOTA: usando più parentesi risulta più comoda la lettura
        ptr = &y;
        y = *((char*) ptr) + 1;
        
        ptr = &z;
        printf("z = %c", **((char**) ptr));     //stampa "z = B"
    }
    \end{verbatim}

    \begin{frameddefn}{Macro e Direttiva \ttt{\#define}}
        Definiamo come \textbf{macro} l'abbreviazione in una parola di un'espressione.

        Il linguaggio C permette la creazione di macro tramite la \textbf{direttiva \ttt{\#define}} del pre-processore:
        \[\ttt{\#define shortcut full\_expression}\]
        
        Durante la fase di pre-processo, ogni singolo uso della parola \ttt{shortcut} viene \textbf{automaticamente rimpiazzato} con \ttt{full\_expression}.
    \end{frameddefn}

    \newpage
    
    \textbf{Esempio:}

    \begin{verbatim}
    #define u16 unsigned short int

    void main(){
        u16 x;  //u16 viene rimpiazzato con unsigned short int
    }
    \end{verbatim}

    \begin{framedprop}{Puntatore \texttt{NULL}}
    Il \textbf{puntatore \ttt{NULL}} è una macro per l'espressione \ttt{(void*) 0}.
    
    Trattandosi di un \textbf{puntatore \ttt{void*} all'indirizzo 0}, esso risulta assegnabile ad ogni tipo di puntatore. L'uso del puntatore \ttt{NULL} permette una comprensione agevolata del codice, in quanto tale puntatore venga interpretato come un "segnaposto" indicante che non sia effettivamente rilevante l'indirizzo assunto in quel preciso istante o che semplicemente non si sappia l'indirizzo.
    \end{framedprop}

    \textbf{Esempio:}

    \begin{verbatim}
    void func(char* str){
        if(str == NULL){
            ...
        }
        else{
            ...
        }
    }

    void main(){
        func(NULL);     //otteniamo un effetto
        func("ciao");   //otteniamo un altro effetto
    }
    \end{verbatim}

    \begin{framedobs}{}
        Nonostante il puntatore \ttt{NULL} possa essere castato, dereferenziandolo si andrà incontro ad un \textbf{segmentation fault}, ossia un errore di esecuzione dovuto all'accesso ad una zona di memoria non autorizzata al processo.

        Difatti, l'indirizzo \ttt{0x0} a cui fa riferimento \ttt{NULL} è riservato al kernel
    \end{framedobs}

    \newpage

    \subsection{Puntatori a funzioni}

    Il linguaggio C permette anche l'uso di \textbf{puntatori a funzioni}, i quali permettono di rendere il codice più generico e flessibile (es: passare una funzione come argomento di un'altra funzione)

    Per dichiarare un puntatore a funzione viene usata la seguente sintassi:
    \[\ttt{returned\_type (*pointer\_name)(arg1\_type, arg2\_type, ...)}\]

    \textbf{Esempi:}

    \begin{verbatim}
    
    int add(int a, int b){
        return a+b;
    }
    int multiply(int a, int b){
        return a*b;
    }

    int func(int (*f)(int, int)){
        return (*f)(10, 11);    //invoca f(10, 11)
    }
    
    void main(){
        //dichiarazione puntatore ad una
        //funzione che prende in input due interi
        int (*funptr)(int,int);

        ...

        if(var == 1){
            funptr = add;
        }
        else{
            funptr = &multiply;
            //utilizzare il riferimento non ha alcun effetto
            //in questo caso, ma potrebbe agevolare la lettura
        }

        (*funptr)(5, 11);   //invoca add(5, 11) o multiply(5, 11)
        func(funcptr);      //passa add o multiply come parametro
    }
    \end{verbatim}

    \newpage

    \section{Array, Stringhe e Struct}
    
    \subsection{Array}

    Un \textbf{array} è un tipo di dato strutturato composto da una \textbf{schiera di variabili dello stesso tipo}, le quali occupano una regione contigua di memoria. La \textbf{dimensione} di un array, ossia il numero totale di elementi al suo interno, è \textbf{statica}, ossia inalterabile.

    \begin{framedprop}{Dichiarazione di array}
        Per dichiarare un array, viene utilizzata la seguente sintassi:
        \[\ttt{modifiers data\_type array\_name[number\_of\_elements]}\]
        dove i campi \ttt{modifiers} e \ttt{data\_type} specificano il tipo di ogni elemento
    \end{framedprop}

    Gli elementi di un array sono \textbf{indicizzati} da un numero intero compreso tra $0$ e $n-1$, dove $n$ è il numero di elementi dell'array.

    \textbf{Esempi:}

    \begin{verbatim}
    void main(){
        unsigned int arr[3];    //un array di tre unsigned int
        char str[10];           //un array di 10 caratteri
        
        arr[0] = 0;     //inizializzo il primo elemento dell'array
        arr[1] = 0;     //inizializzo il secondo elemento dell'array
        arr[2] = 0;     //inizializzo il terzo elemento dell'array
    }
    \end{verbatim}    

    Inoltre, è possibile \textbf{"auto-inizializzare"} i valori di un array in fase di dichiarazione:
    \[\ttt{type arr[n] = $\underbrace{\ttt{\{val0, val1, ..., val(n-1)\}}}_{\text{n valori}}$}\]
    
    \begin{framedobs}{}
        Quando un array viene dichiarato, gli \textbf{elementi non inizializzati} al suo interno conterranno dei \textbf{"valori casuali"}, corrispondenti agli ultimi valori presenti nei byte di memoria precedentemente utilizzati da altri processi ed ora occupati dall'array stesso.
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    void main(){
        unsigned int arr[3];
        printf("%d", arr[0]);   //viene stampato un "valore casuale"
    }\end{verbatim}

    \begin{framedobs}{}
        È necessario prestare \textbf{molta attenzione} all'uso degli indici per accedere agli elementi di un array:
        \begin{itemize}
            \item Se si tenta di \textbf{accedere} ad un elemento fuori dal range dei valori dell'array (\textbf{Stack Smashing}), verrà generato un \underline{errore} di esecuzione
            \item Se si tenta di \textbf{printare} un elemento fuori dal range dei valori dell'array, tale operazione verrà \underline{concessa}
        \end{itemize}
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    void main(){
        int x;
        int arr[3];

        printf("%d", arr[100]);     //nessun errore
        arr[4] = 5;                 //errore
        x = arr[10];                //errore
    }\end{verbatim}

    \begin{framedobs}{}
        Dichiarando un array \ttt{type arr[n]}, viene creata la variabile \ttt{arr}, corrispondente ad un \textbf{puntatore al primo elemento} dell'array.

        Difatti, la sintassi \ttt{arr[m]} per accedere all'$(m+1)$-esimo elemento dell'array corrisponde ad una \textbf{contrazione sintattica} dell'operazione \ttt{*(arr + m)}
    \end{framedobs}

    \textbf{Esempi:}

    \begin{verbatim}
    void main(){
        int arr[3];

        arr[0] = 0;     //viene modificato il primo elemento dell'array
        *(arr + 0) = 0; //viene modificato il primo elemento dell'array

        printf("%d", arr);
        //viene printato l'indirizzo del primo elemento dell'array

        printf("%d", arr[2]);
        //viene printato il terzo elemento dell'array

        printf("%d", *(arr + 2));
        //viene printato il terzo elemento dell'array
    }\end{verbatim}

    \begin{framedobs}{}
        Per utilizzare un array come argomento di una funzione, è strettamente necessario passare tale array per \textbf{riferimento}.
        
        Ricordiamo inoltre che la variabile tramite cui è possibile accedere agli elementi dell'array è essa stessa un puntatore. Per tanto, \underline{non è necessario} utilizzare l'operatore di riferimento su di esso.
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    void func(int* arr){...}

    void main(){
        int arr[3];

        func(&arr);
        /*
            verrebbe passato l'indirizzo di memoria in cui
            è salvato il puntatore arr, ma non l'indirizzo
            del primo elemento dell'array (doppio riferimento)
        */

        //l'utilizzo corretto dunque è
        func(arr);
    }
    \end{verbatim}

    \begin{framedobs}{}
        Utilizzando l'operatore \ttt{sizeof} sulla variabile puntatore di un array, verrà restituita la somma delle dimensioni di tutti gli elementi.

        (es: dato l'array \ttt{type arr[n]}, l'operatore \ttt{sizeof(arr)} restituirà \ttt{n * sizeof(type)})
    \end{framedobs}

    \begin{framedobs}{Array multimensionali}
        È possibile definire anche un \textbf{array multidimensionale}, ossia i cui elementi sono indicizzabili tramite $n$ valori (dove $n$ è il numero di dimensioni).

        Un array multidimensionale non è altro che un array contenente altri array, i quali a loro volta contengono altri array e così via fino ad esaurire il numero di dimensioni.
    \end{framedobs}

    \newpage
    
    \textbf{Esempi:}

    \begin{verbatim}
    void main(){
        int a[10];              //un vettore di 10 elementi
        int a[10][10];          //una matrice 10 x 10
        int a[10][10][10];      //un cubo 10 x 10 x 10

        a[0][0] = 0;    //inizializzo primo elemento della matrice
        a[0][0][0] = 0; //inizializzo primo elemento del cubo
    }
    \end{verbatim}

    \subsection{Stringhe}

    All'interno del linguaggio C, le \textbf{stringhe} vengono rappresentate come un particolare \textbf{array di caratteri}, dove:
    \begin{itemize}
        \item Ogni elemento dell'array è un carattere della stringa
        \item L'ultimo elemento dell'array è un \textbf{null byte} (ossia il carattere \ttt{\textbackslash 0}), detto anche carattere di fine stringa
    \end{itemize}

    Ad esempio, la stringa \ttt{"Hello World!"} viene rappresentata come:
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
            \hline
            H & e & l & l & o & & W & o & r & l & d & ! & \ttt{\textbackslash 0}\\
            \hline
        \end{tabular}
    \end{center}

    e il suo \textbf{placeholder} all'interno delle stringhe formattate corrisponde a \ttt{\%s}.
    

    Per \textbf{assegnare} una stringa ad un array, dunque, è sufficiente trattare tale stringa come se fosse un normale valore:

    \begin{verbatim}
    void main(){
        char str[20] = "Hello World!";
        printf("%s", str);
    }
    \end{verbatim}

    \begin{framedobs}{}
        Quando si vuole assegnare una stringa ad un array di caratteri, è necessario tenere a mente che tale stringa contenga anche \textbf{carattere di fine stringa}, implicando che, se la stringa è lunga $n$ caratteri, l'array debba avere una \textbf{dimensione} pari ad almeno $n+1$.

        \textbf{\textit{Attenzione:}} nel caso in cui l'array abbia una dimensione troppo piccola, non verrà generato un errore, ma verrà segnalato solamente un warning in fase di compilazione
    \end{framedobs}

    \newpage

    \textbf{Esempio:}

    \begin{verbatim}
    void main(){
        char str[5] = "ciao";   //ok

        char str2[4] = "ciao";
        //l'array è troppo piccolo, dunque il carattere
        //'\0' viene tagliato durante l'assegnamento

        char str3[3] = "ciao";
        //l'array è troppo piccolo, dunque i caratteri
        //'o' e '\0' vengono tagliati durante l'assegnamento
    }
    \end{verbatim}

    Il linguaggio prevede, inoltre, multiple modalità per \textbf{inizializzare} una stringa:

    \begin{verbatim}
    void main(){
        char str[10] = "Ciao";
        //i primi 5 caratteri vengono occupati dalla stringa,
        //mentre i restanti 5 assumono un "valore casuale"

        char str2[10] = {'C', 'i', 'a', 'o', '\0'};
        //equivalente all'istruzione precedente

        char str3[] = "Ciao";
        //l'array assume automaticamente la dimensione della stringa,
        //dunque non vi sono spazi in eccesso
    }
    \end{verbatim}
    La libreria \ttt{<string.h>} fornisce le seguenti funzioni per lavorare con le stringhe:
    \begin{itemize}
        \item La funzione \ttt{size\_t strlen(const char* str)} permette di ottenere la lunghezza di una stringa (escludendo il null byte dal conteggio). Il tipo \ttt{size\_t} ritornato è una macro per il tipo \ttt{int}.
        \item La funzione \ttt{char* strcpy(char* dest, const char* src)} copia all'interno del buffer \ttt{dest} il contenuto del buffer \ttt{src}. Il puntatore ritornato è \ttt{dest}. Per evitare errori, è necessario che il buffer \ttt{dest} abbia una dimensione maggiore o uguale a quella di \ttt{src}.
        \item La funzione \ttt{char* strcat(char* dest, const char* src)} appende il contenuto del buffer \ttt{src} alla fine del buffer \ttt{dest} (usando il null byte di \ttt{dest} come punto di concatenazione). Il puntatore ritornato è \ttt{dest}. Per evitare errori, è necessario che il buffer \ttt{dest} abbia una dimensione "rimanente" maggiore o uguale a quella di \ttt{src}.
        \item La funzione \ttt{int strcmp (const char* str1, const char* str2 )} permette di comparare due stringhe, ritornando la differenza tra i primi due caratteri (uno di \ttt{str1} e uno di \ttt{str2}) diversi
        \begin{itemize}
            \item Ritorna un valore $<0$ se il primo carattere diverso con valore minore (ricordiamo che i caratteri ASCII sono comunque un intero) è quello di \ttt{str1}
            \item Ritorna $0$ se non esistono due caratteri diversi (dunque le stringhe sono uguali)
            \item Ritorna un valore $>0$ se il primo carattere diverso con valore minore è quello di \ttt{str2}
        \end{itemize}
        \item La funzione \ttt{char* strncpy(char* dest, const char *src, size\_t n)} risulta analoga alla funzione \ttt{strcpy()}, con la differenza che vengano copiati massimo \ttt{n} caratteri
        \item La funzione \ttt{char* strncat(char* dest, const char *src, size\_t n)} risulta analoga alla funzione \ttt{strcat()}, con la differenza che vengano appesi massimo \ttt{n} caratteri
        \item La funzione \ttt{char* strncmp(char* dest, const char *src, size\_t n)} risulta analoga alla funzione \ttt{strcmp()}, con la differenza che vengano comparati massimo \ttt{n} caratteri
    \end{itemize}

    \begin{framedobs}{}
        Comparare due stringhe \ttt{str1} e \ttt{str2} tramite l'operatore \ttt{str1 == str2} risulta \textbf{errato}, poiché il tal modo stanno venendo comparati i puntatori di tali stringhe
    \end{framedobs}

    All'interno della libreria \ttt{<stdio.h>} vengono inoltre fornite le seguenti funzioni più flessibili (e più sicure) per scrivere o leggere stringhe:
    \begin{itemize}
        \item La funzione \ttt{int putchar(int char)} scrive il carattere dato su stdout
        \item La funzione \ttt{int puts(const char* str)} scrive la stringa data su stdout
        \item La funzione \ttt{int fputs(const char* str, FILE* stream)} scrive la stringa data su file \ttt{stream} (vedere sezioni successive)
        \item La funzione \ttt{char* gets(char* str)} legge una stringa da stdin e la scrive nel buffer \ttt{str}, ritornando \ttt{str} stesso come puntatore. Per motivi di sicurezza, tale funzione è stata \textbf{deprecata} e non è disponibile nelle versioni moderne di C
        \item La funzione \ttt{char* fgets(char* str, int n, FILE* stream)} legge $n$ caratteri dal file \ttt{stream} e scrive nel buffer \ttt{str}, ritornando \ttt{str} stesso come puntatore
        \item La funzione \ttt{int getchar()} legge un carattere da stdin e ritorna il valore decimale di tale carattere
    \end{itemize}

    \begin{framedobs}{}
        Il \textbf{carattere di fine stringa} risulta \underline{fondamentale}, poiché non si è in grado di poter sapere quando la stringa sia terminata, portando ad un \textbf{undefined behaviour} (trad: \textit{comportamento sconosciuto})
    \end{framedobs}

    Ad esempio di ciò, possiamo analizzare il comportamento della funzione \ttt{strlen()}:
    \begin{itemize}
        \item Partendo dal primo elemento della stringa, la funzione scorre la lista contando il numero di caratteri letti e fermandosi solo quando viene letto un carattere \ttt{\textbackslash 0}
        \item Per tanto, se il carattere \ttt{\textbackslash 0} è assente, la funzione potrebbe continuare potenzialmente all'infinito 
    \end{itemize}

    \quad

    \subsection{Struct}

    \begin{frameddefn}{Struct}
        Uno \textbf{struct (structure)} è un tipo di dato \textbf{definito dall'utente} e \textbf{composto da più campi di diversi tipi di dato}.

        Uno struct può essere visto come un contenitore di una collezione di variabili di vari tipi, utilizzabile pienamente come un tipo di dato.
    \end{frameddefn}

    Per definire uno struct, possono essere utilizzate \textbf{tre modalità}:
    \begin{itemize}
        \item \textbf{Variabile struct}, utilizzabile per definire tutte le variabili che assumeranno la struttura definita
        
    \begin{verbatim}
    void main(){
        struct {
            type1 attr1;
            type2 attr2;
            ...
        } var1, var2, ...;
    }
    \end{verbatim}

        \item \textbf{Tagged struct}, utilizzabile per conservare la struttura definita e utilizzarla tra più file
        
    \begin{verbatim}
    struct struct_name{
        type1 attr1;
        type2 attr2;
        ...
    };

    void main(){
        struct struct_name var1, var2, ...;
    }
    \end{verbatim}
        \newpage

        \item \textbf{Type-defined struct} tramite l'operatore \ttt{typedef} utilizzabile per definire direttamente un nuovo tipo di dato (può essere utilizzato anche con altri tipi, non necessariamente uno struct)
        
    \begin{verbatim}
    typedef struct struct_name{
        type1 attr1;
        type2 attr2;
        ...
    } type_name;
    
    //NOTA: solitamente viene aggiunto "_t"
    //alla fine del nome per indicare che si
    //tratti di un tipo definito dall'utente

    void main(){
        type_name var1, var2, ...;
    }
    \end{verbatim}
    \end{itemize}

    Come per gli array, è possibile effettuare un \textbf{"auto-inizializzazione"} dei campi di uno struct:
    \[\ttt{struct\_type var = $\underbrace{\ttt{\{val0, val1, ..., val(n-1)\}}}_{\text{n valori}}$}\]

    \begin{framedprop}{Operatore punto}
        L'\textbf{operatore punto}
        \[\ttt{struct\_var.attr\_name}\]
        permette di \textbf{accedere} all'attributo \ttt{attr\_name} dello struct \ttt{struct\_var}.
    \end{framedprop}

    \textbf{Esempio:}

    \begin{verbatim}
    typedef struct point2D{
        float x;
        float y;
    } point2D_t;

    void main(){
        point2D_t point;
        point.x = 43.16;
        point.y = 13.12;
    }
    \end{verbatim}

    \begin{framedprop}{Operatore freccia}
        L'\textbf{operatore freccia}, ossia
        \[\ttt{struct\_p->attr\_name}\]
        permette di \textbf{dereferenziare} il puntatore \ttt{struct\_p} per poi \textbf{accedere} all'attributo \ttt{attr\_name} dello struct da esso puntato.
        
        Difatti, l'operatore \ttt{struct\_p->attr\_name} e lo statement \ttt{(*struct\_p).attr\_name} sono equivalenti tra loro.
    \end{framedprop}

    \textbf{Esempio:}
    \begin{verbatim}
    typedef struct point2D{
        float x;
        float y;
    } point2D_t;

    void main(){
        point2D_t point;
        point2D_t* point_ptr = &point;

        point_ptr->x = 43.16;
        point_ptr->y = 13.12;
    }
    \end{verbatim}

    \begin{framedobs}{}
        Utilizzando l'operatore \ttt{sizeof} su un type-defined struct, verrà restituita la somma delle dimensioni di tutti i campi del tipo struct definito.
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    typedef struct point2D{
        float x;
        float y;
    } point2D_t;

    void main(){
        printf("%d", sizeof(point2D_t));    //viene printato 32+32 = 64
    }
    \end{verbatim}
    
    \newpage

    \section{Utilizzo della memoria dinamica}

    Fino ad ora, abbiamo visto come i blocchi di istruzioni allochino e deallochino automaticamente la memoria sullo \textbf{stack} durante la compilazione.

    Per quanto riguarda la \textbf{memoria dinamica}, ossia la porzione di memoria riservata all'heap, l'allocazione e la deallocazione è \underline{a carico del programmatore}. In particolare, è \textbf{fondamentale} che, qual'ora si sia allocata della memoria nell'heap, essa venga \textbf{liberata} (ossia deallocata), poiché altrimenti essa rimarrà "occupata" (\textbf{memory leakage}) fino a che il processo non terminerà e tutte le sue pagine verranno deallocate.
    
    La presenza di memory leakage influisce molto sulle prestazioni di un processo e anche dell'intero sistema operativo. Per tanto, è necessario mantenere al mimino possibile (potenzialmente zero) la quantità di memoria "sprecata".
    
    La libreria \ttt{<stdlib.h>} fornisce le seguenti funzioni per l'\textbf{allocazione e deallocazione di memoria nell'heap}:
    \begin{itemize}
        \item La funzione \ttt{void* malloc(size\_t size)} alloca una porzione di memoria pari a \ttt{size} byte, restituendo un puntatore \ttt{void*} all'inizio di tale porzione.
        
        Come per l'allocazione sullo stack, i byte allocati conterranno i valori precedenti. Se l'allocazione fallisce, viene ritornato \ttt{NULL}.

    \begin{verbatim}
    void main(){
        //vengono allocati 4 byte
        int* x = (int*) malloc(sizeof(int));

        //viene stampato un "valore casuale",
        //poiché la memoria non è inizializzata
        printf("%d", *x);

        //vengono allocati 8 byte
        char* str = (char*) malloc(sizeof(char) * 8);
        str[0] = 'C';
        str[1] = 'i';
        str[2] = 'a';
        str[3] = 'o';
        str[4] = '\0';

        //vengono allocati 16 byte (dunque 4 interi)
        int* arr = (int*) malloc(16);   
    }
    \end{verbatim}

        \item La funzione \ttt{void* calloc(size\_t num, size\_t size)} alloca \ttt{num} porzioni contigue di memoria, ciascuna pari a \ttt{size} byte, restituendo un puntatore \ttt{void*} all'inizio della prima porzione.
        
        Dopo l'allocazione, ogni byte della porzione di memoria viene \textbf{inizializzato con valore 0}. Se l'allocazione fallisce, viene ritornato \ttt{NULL}

    \begin{verbatim}
    void main(){
        //viene allocato un intero (dunque 4 byte)
        int* x = (int*) calloc(1, sizeof(int));

        //viene stampato 0, poiché la memoria è inizializzata
        printf("%d", *x);

        //vengono allocati 8 byte inizializzati a 0
        char* str = (char*) calloc(8, sizeof(char));
        str[0] = 'C';
        str[1] = 'i';
        str[2] = 'a';
        str[3] = 'o';
        //settare str[4] a '\0' non serve in quanto già settato
    }
    \end{verbatim}

        \item La funzione \ttt{void* realloc(void* ptr, size\_t size)} modifica la porzione di memoria precedentemente ed accessibile dal puntatore \ttt{ptr}:
        \begin{itemize}
            \item Se il puntatore dato in input è \ttt{NULL}, la funzione avrà lo stesso comportamento di \ttt{malloc(size)}
            \item Se possibile, la precedente porzione di memoria viene \textbf{direttamente estesa} fino a raggiungere la dimensione \ttt{size} e il puntatore ritornato \textbf{coincide} con quello dato in input
            \item Se non è possibile estendere la porzione precedente, viene allocata una \textbf{nuova porzione di memoria} di dimensione \ttt{size}, \textbf{copiando} della porzione precedente e \textbf{deallocando} quest'ultima. Il puntatore ritornato sarà quello all'inizio della nuova area di memoria
        \end{itemize}

        Come per l'allocazione sullo stack, i byte allocati conterranno i valori precedenti (esclusi i byte su cui è stato copiato il contenuto). Se l'allocazione fallisce, viene ritornato \ttt{NULL}.

    \begin{verbatim}
    void main(){
        int* x = (int*) malloc(sizeof(int));
        ...

        //il contenuto di x viene riallocato
        int* y = realloc(x, sizeof(int) * 3);

        int* z = realloc(NULL, 8); //equivale a malloc(8)
    }
    \end{verbatim}

    \newpage
        
        \item La funzione \ttt{free(void* ptr)} libera la porzione di memoria puntata da \ttt{ptr}.
        
        Se il puntatore dato in input non è stato ottenuto tramite una chiamata alle funzioni \ttt{malloc}, \ttt{calloc} e \ttt{realloc}, la funzione andrà in \textbf{undefined behaviour}, solitamente generando un segmentation fault.

        Se viene invocata la funzione \ttt{free()} su una porzione di memoria già deallocata (es: utilizzando due volte \ttt{free()} sullo stesso puntatore), la funzione andrà in \textbf{undefined behaviour}, solitamente generando un segmentation fault (\textbf{double free})
    \end{itemize}


    \begin{verbatim}
    void main(){
        int* x = (int*) malloc(sizeof(int));
        ...

        free(x);    //deallocata

        free(x);    //undefined behaviour (double free)

        int y[10];
        free(y)     //undefined behaviour
    }
    \end{verbatim}

    Nel caso in cui si volesse \textbf{allocare memoria sullo stack} invece che l'heap, ma senza dover dichiarare necessariamente una variabile, la libreria \ttt{<alloca.h>} fornisce la funzione \ttt{void* alloca(size\_t size)}, avente lo stesso funzionamento di \ttt{malloc()} (ma con allocazione sullo stack).

    \begin{framedobs}{}
        Essendo l'allocazione da parte di \ttt{alloca()} effettuata sullo stack, non è necessario eseguire \ttt{free()} in quanto tale memoria viene automaticamente deallocata alla chiusura del blocco
    \end{framedobs}

    Nonostante non siano strettamente legate alle stringhe, la libreria \ttt{<string.h>} fornisce le seguenti due funzioni utili per l'assegnamento rapido in porzioni di memoria:
    \begin{itemize}
        \item La funzione \ttt{void* memset(void* dest, int value, size\_t num)} assegna l'intero \ttt{value} a \ttt{num} byte contingui partendo dalla porzione puntata da \ttt{dest}
        \item La funzione \ttt{void* memcpy(void* dest, const void* src, size\_t num)} copia \ttt{num} byte contingui dall'inizio della porzione puntata da \ttt{src} all'inizio della porzione puntata da \ttt{dest}
    \end{itemize}

    \begin{verbatim}
        void main(){
            char* str = (char*) malloc(sizeof(char) * 8);

            //assegnazione di una stringa costante su memoria dinamica
            memcpy(str, "ciao", 5); 
        }\end{verbatim}

    \newpage

    \section{Utilizzo dei file}

    Ogni \textbf{file} su cui è possibile operare appartiene ad una delle seguenti categorie:
    \begin{itemize}
        \item \textbf{File di testo}, ossia contenente puro testo
        \item \textbf{File binari}, ossia file eseguibili, compilati, oggetto, ...
        \item \textbf{Buffer}, ossia dei file speciali corrispondenti ad aree di memorizzazione temporanee che mantengono i dati da trasferire dalla memoria principale al disco o viceversa
    \end{itemize}

    Ogni \textbf{riga} di un file di testo è terminata dal carattere \ttt{\textbackslash n}, mentre l'intero file è terminato dal valore speciale \textbf{End-of-File}, definito come \ttt{EOF} in C. Ogni file aperto, inoltre, possiede un \textbf{cursore}, ossia un puntatore al suo contenuto che tiene traccia della posizione attuale di lettura e/o scrittura.
    
    Per poter \textbf{utilizzare i file} all'interno del linguaggio C, la libreria \ttt{<stdio.h>} permette di eseguire (in ordine) le seguenti operazioni:
    \begin{enumerate}
        \item Dichiarare un \textbf{file pointer}, ossia \ttt{FILE*}
        \item Aprire il file desiderato tramite la funzione \ttt{FILE* fopen(const char* filename, const char* mode)}. Tale funzione apre il file con in modalità \ttt{mode}, crea uno struct \ttt{FILE} e restituisce un puntatore \ttt{FILE*}. Viene ritornato \ttt{NULL} se l'apertura del file fallisce.
        \item Utilizzare le funzioni di scrittura e/o lettura (vedi più avanti)
        \item Chiudere il file tramite la funzione \ttt{int fclose(FILE* stream)}, la quale ritorna 0 se la chiusura è avvenuta con successo, altrimenti ritorna \ttt{EOF}
        \item Liberare il puntatore \ttt{FILE*} tramite \ttt{free()}
    \end{enumerate}

    Quando un processo effettua una lettura o scrittura su un file aperto e associato ad un \ttt{FILE*}, il contenuto utilizzato da tali operazioni inserito momentaneamente all'interno di un \textbf{buffer} presente all'interno dello struct \ttt{FILE}.
    
    Ad ogni operazione di scrittura invocata, il contenuto da scrivere viene inserito all'interno del buffer, effettuando la vera operazione di scrittura solo quando il buffer viene riempito o il file viene chiuso \textbf{bufferized writing}.  Analogamente, l'operazione di lettura ha lo stesso funzionamento, ma in ordine inverso (\textbf{bufferized reading})


    In particolare, lo struct \ttt{FILE} contiene campi relativi a:
    \begin{itemize}
        \item Il \textbf{file descriptor} associato al file
        \item Il \textbf{puntatore al buffer} per lo stream dati
        \item La dimensione del buffer
        \item Un contatore per il numero di caratteri attualmente nel buffer
        \item Una flag di errore
    \end{itemize}

    \newpage

    Tra le varie funzioni di scrittura e/o lettura fornite da \ttt{<stdio.h>} troviamo:
    \begin{itemize}
        \item La funzione \ttt{int fprintf(FILE* stream, const char* format, ...)}, del tutto analoga alla funzione \ttt{printf()} ma la scrittura avviene sul file
        \item La funzione \ttt{int fscanf(FILE* stream, const char* format, ...)}, del tutto analoga alla funzione \ttt{scanf()} ma la lettura avviene dal file
        \item La funzione \ttt{size\_t fread(void* ptr, size\_t size, size\_t count, FILE* \\stream)} legge \ttt{count} elementi contigui dal file dato, ognuno di dimensione \ttt{size}, copiando il contenuto letto nel buffer \ttt{ptr}
        \item La funzione \ttt{size\_t fwrite(void* ptr, size\_t size, size\_t count, FILE* \\stream)} scrive \ttt{count} elementi contigui dal buffer \ttt{ptr}, ognuno di dimensione \ttt{size}, copiando il contenuto letto nel file dato.
        \item La funzione \ttt{char* fgets(char* str, int size, FILE* stream)} legge massimo \ttt{size} caratteri dal file (fermandosi prima se viene letto \ttt{\textbackslash n}) e copiando il contenuto letto nella stringa \ttt{str}
        \item La funzione \ttt{char* fputs(char* str, FILE* stream)} scrive la stringa \ttt{str} sul file
        \item La funzione \ttt{int feof(FILE* stream)} restituisce un valore diverso da 0 se è stato raggiunto \ttt{EOF}
        \item La funzione \ttt{int fseek(FILE* stream, long int offset, int whence)} imposta il cursore alla posizione \ttt{whence} incrementata di \ttt{offset} byte. I valori impostabili per il campo \ttt{whence} sono:
        \begin{itemize}
            \item \ttt{SEEK\_SET}, ossia l'inizio del file
            \item \ttt{SEEK\_CUR}, ossia la posizione attuale del cursore
            \item \ttt{SEEK\_END}, ossia la fine del file
        \end{itemize}
        \item La funzione \ttt{long int ftell(FILE* stream)} restituisce la posizione attuale del cursore del file se essa è valida, -1 altrimenti
        \item La funzione \ttt{void rewind(FILE* stream)} riporta il cursore del file all'inizio, dunque ha lo stesso effetto di \ttt{fseek(stream, 0, SEEK\_SET)}
    \end{itemize}

    \textbf{Esempio:}

    \begin{verbatim}
    void main(){
        FILE* file = fopen("test.txt", "w");        //apertura
        fprintf(file, "Hello World! :)");              //scrittura

        rewind(file);   //riporta il cursore all'inizio
        fprintf(file, "Ciao Mondo!");
        //viene sovrascritto parte del contenuto già scritto

        fclose(file);   //chiusura
        free(file);
    }\end{verbatim}

    \begin{framedobs}{}
        All'interno della libreria \ttt{<stdio.h>} vengono forniti \textbf{tre file pointer} \ttt{stdin}, \ttt{stdout} e \ttt{stderr} relativi ai \textbf{tre canali standard} di ogni processo. 
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    #include <stdio.h>

    void main(){
        int x;
        fscanf(stdin, "%d", &x);    //è equivalente a scanf("%d", &x);

        fprintf(stdout, "Ciao");    //è equivalente a printf("Ciao");

        fprintf(stderr, "Questo è un messaggio di errore");
    }
    \end{verbatim}

    \subsection{Modalità di apertura di un file}

    Abbiamo visto come la funzione \ttt{fopen()} possieda un parametro \ttt{mode} tramite cui è possibile definire la modalità di apertura del file. Tale modalità di apertura definisce le \textbf{operazioni eseguibili sul file}, fungendo come una sorta di "restrizione":
    \begin{itemize}
        \item Aprendo il file con la modalità \texttt{"r"}, sarà possibile effettuare solo operazioni di \textbf{lettura}. La posizione iniziale del cursore del file corrisponderà all'\textbf{inizio del file}.
        \item Aprendo il file con la modalità \texttt{"w"}, sarà possibile effettuare solo operazioni di \textbf{scrittura}. La posizione iniziale del cursore del file corrisponderà all'\textbf{inizio del file}. Il contenuto precedente del file verrà \textbf{troncato}. Inoltre, se il file dato non esiste, esso verrà \textbf{creato}.
        \item Aprendo il file con la modalità \texttt{"a"}, sarà possibile effettuare solo operazioni di \textbf{scrittura}. La posizione iniziale del cursore del file corrisponderà alla \textbf{fine del file}. Inoltre, se il file dato non esiste, esso verrà \textbf{creato}.
        \item Aprendo il file con la modalità \texttt{"r+"}, sarà possibile effettuare sia operazioni di \textbf{lettura} che di \textbf{scrittura}. La posizione iniziale del cursore del file corrisponderà all'\textbf{inizio del file}. Inoltre, se il file dato non esiste, esso verrà \textbf{creato}.
        \item Aprendo il file con la modalità \texttt{"w+"}, sarà possibile effettuare sia operazioni di \textbf{lettura} che di \textbf{scrittura}. La posizione iniziale del cursore del file corrisponderà all'\textbf{inizio del file}. Il contenuto precedente del file verrà \textbf{troncato}. Inoltre, se il file dato non esiste, esso verrà \textbf{creato}.
        \item Aprendo il file con la modalità \texttt{"a+"}, sarà possibile effettuare sia operazioni di lettura che di scrittura. La posizione iniziale del cursore del file corrisponderà alla \textbf{fine del file}. Inoltre, se il file dato non esiste, esso verrà \textbf{creato}.
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.6]{images/file_modes.png}
    \end{center}

    \begin{framedobs}{}
        Per poter effettuare le operazioni dettate dalla modalità di apertura, è comunque necessario possedere i corretti \textbf{privilegi di sistema} per il file richiesto.

        (es: un file aperto con \ttt{"w"} richiede comunque che l'utente abbia il permesso \ttt{w} per il file dato)
    \end{framedobs}

    \begin{framedobs}{}
        Un file possiede \textbf{un solo cursore}. Per tanto, se un file viene aperto in lettura e scrittura, tali operazioni condivideranno il cursore.
    \end{framedobs}

    \quad

    \section{Variabili esterne e statiche}

    Come già discusso, nel linguaggio C una variabile è \textbf{accessibile} solo all'interno del blocco in cui è dichiarata e nei suoi sotto-blocchi. La porzione di codice in cui una variabile è accessibile viene detto \textbf{scoping (o visibilità)} della variabile.

    Una funzione avente uno scoping pari all'\textbf{intero file sorgente} è detta \textbf{variabile globale}, mentre qualsiasi altra variabile è detta \textbf{locale}.

    Per creare una variabile globale, è sufficiente dichiarare tale variabile \textbf{prima e al di fuori di ogni funzione}. Difatti, possiamo considerare anche il file sorgente stesso come un \textbf{"enorme blocco radice"} all'interno di cui vengono definiti tutti gli altri blocchi.

    \newpage

    \textbf{Esempio:}

    \begin{verbatim}
    int var;
    
    //tale variabile è accessibile ovunque
    //al di sotto di tale istruzione (scoping globale)

    void func(){
        var = 1;
    }

    int var2;
    //tale variabile è accessibile ovunque
    //al di sotto di tale istruzione, dunque non è
    //accessibile tramite func(), ma tramite main() sì

    void main(){
        var = 0;
        var2 = 1;
    }\end{verbatim}

    \begin{framedprop}{Modificatore \ttt{extern}}
        Il \textbf{modificatore \ttt{extern}} permette di "dichiarare" (o meglio richiamare) una variabile non visibile all'interno di un blocco (\textbf{external linkage}).

        In particolare, tramite il modificatore extern è possibile utilizzare variabili \textbf{dichiarate dopo un blocco} o anche \textbf{in un altro file}
    \end{framedprop}

    \textbf{Esempio:}

    \begin{verbatim}
    //Supponiamo che la variabile
    //  int var2 = 10;
    //sia dichiarata in un altro file importato

    void func1() {
        extern int var;
        //richiamo di variabile esterna
        //(var non è ancora stata dichiarata)

        var++;
        printf("var = %d\n", var);  //viene printato 1
        
        void nestfunc1() {
            var++;
            printf("var = %d\n", var);
        }
        nestfunc1();    //viene printato 2
        nestfunc1();    //viene printato 3
    }

    int var = 0;  //dichiarazione di var

    void main(void) {
        printf("var = %d\n", var);      //viene printato 0
        func1();
        printf("var = %d\n", var);      //viene printato 3

        extern int var2;
        printf("var2 = %d\n", var2);    //viene printato 10
    }
    \end{verbatim}

    \begin{framedprop}{Modificatore \ttt{static} su variabili}
        Il \textbf{modificatore \ttt{static}} permette di dichiarare variabili il cui valore viene \textbf{mantenuto} tra una chiamata e l'altra di una funzione, costituendo una sorta di \textit{memoria privata} della funzione (\textbf{internal linkage}).

        Inoltre, le variabili statiche vengono \textbf{automticamente inizializzate a 0}.
    \end{framedprop}

    \textbf{Esempio:}

    \begin{verbatim}
    void func(){
        static int var;     //auto-inizializzata a 0
        var++;
        printf("%d", var);
    }

    void main(){
        func();     //viene printato 1
        func();     //viene printato 2
    }
    \end{verbatim}
    
    \begin{framedobs}{}
        \textbf{Non è possibile} utilizzare il modificatore \ttt{static} anche assieme al modificatore \ttt{extern}, poiché si otterrebbe un linkage sia esterno che interno.
    \end{framedobs}

    \begin{framedprop}{Modificatore \ttt{static} su funzioni}
        Il \textbf{modificatore \ttt{static}} permette di dichiarare funzioni che possono essere accedute solo ed esclusivamente all'interno del file sorgente in cui sono dichiarate (\textbf{internal linkage}).
    \end{framedprop}

    \begin{verbatim}
    ----- File: file1.c
    static void func(){...}

    ---- File: file2.c
    #include "file1.c"

    void main(){
        func();
        //viene generato errore di compilazione,
        //poiché la funzione non è accedibile
    }
    \end{verbatim}

    \begin{framedobs}{}
        L'uso del modificatore \ttt{static} su funzioni permette di creare funzioni all'interno di un file che importa un altro file contenente una funzione con lo stesso nome
    \end{framedobs}

    \textbf{Esempio:}
    \begin{verbatim}
    ----- File: file1.c
    static void func(){
        printf("Vengo da file1.c")
    }

    ---- File: file2.c
    #include "file1.c"

    void func(){
        printf("Vengo da file2.c")
    }
    
    void main(){
        func();     //viene printato "Vengo da file2.c"
    }
    \end{verbatim}

    \quad

    \section{Uso avanzato del linguaggio}

    \subsection{Inserire parametri all'avvio}

    Nei capitoli precedenti, abbiamo visto come durante l'avvio di un programma sia possibile inserire dei \textbf{parametri} (opzionali e non). All'interno del linguaggio C, tali parametri sono ottenibili \textbf{direttamente tramite la funzione main}.

    Difatti, essa è dotata di \textbf{due parametri opzionali}:
    \begin{itemize}
        \item L'intero \ttt{int argc}, il quale permette di sapere la quantità di parametri che sono stati passati alla funzione
        \item L'array \ttt{char* argv[]}, contenente i parametri passati (i quali vengono passati come stringhe). Il primo elemento di tale vettore è il nome del programma eseguito e tale elemento è sempre presente.
    \end{itemize}

    \textbf{Esempio:}

    \begin{itemize}
        \item Supponiamo di avviare il nostro programma tramite il comando \ttt{program 5 9 ciao}
        \item L'intero \ttt{argc} sarà pari a 4
        \item L'array \ttt{argv} sarà pari a \ttt{\{"5", "9", "ciao"\}}
        \item Per ottenere tali valori, ci basterà aggiungere gli argomenti opzionali:
    \begin{verbatim}
    void main(int argc, char* argv[]){
        printf("argc = %d", argc);
        printf("Il nome del programma è: %s", argv[0]);
        printf("Il primo argomento è: %s", argv[1]);
    }
    \end{verbatim}
    \end{itemize}

    Poiché i parametri vengono passati come stringhe, se necessario si dovrà \textbf{convertire in intero} le stringhe contenenti numeri. La libreria \ttt{<stdlib.h>} fornisce la funzione \ttt{int atoi(char* str)}, la quale converte la stringa \ttt{str} nell'intero rappresentato da essa (es: \ttt{atoi("542")} restituisce \ttt{542}).
    
    Tuttavia, è necessario notare che la funzione \ttt{atoi()} non effettui alcun controllo sull'input dato. Difatti, essa interpreta ogni carattere come valore intero, sottraendo ad esso il valore intero del carattere \ttt{'0'}.

    \begin{itemize}
        \item Il valore intero del carattere \ttt{'5'} corrisponde a 53
        \item Per ottenere l'intero rappresentato dal carattere, al suo valore intero viene sottratto il valore intero del carattere \ttt{'0'}, ossia 48, dunque $53-48 = 5$
        \item Per tanto, essendo il valore intero del carattere \ttt{'A'} pari a 65, passando tale carattere alla funzione \ttt{atoi} il risultato ottenuto sarebbe $65-48 = 17$
    \end{itemize}
    
    Per tanto, si consiglia di effettuare i necessari controlli sulla stringa data in input al fine di evitare problematiche.

    \subsection{Makefile}

    Per \textbf{automatizzare la compilazione} di file sorgenti, viene utilizzato il meccanismo del \textbf{Makefile (o Make)}, il quale definisce un \textbf{linguaggio proprio} per descrivere relazioni tra file sorgenti, file oggetto ed eseguibili all'interno di un file.

    Oltre alla maggiore comodità rispetto alla compilazione manuale, tale meccanismo permette di ri-compilare un file sorgente solo quando esso è stato modificato, riducendo notevolmente i tempi di compilazione per programmi molto grandi.

    Per compilare un programma tramite il meccanismo makefile viene utilizzato il comando \ttt{make}. Se chiamato senza opzioni aggiuntive, tale comando cerca all'interno della directory corrente un file chiamato \ttt{GNUmakefile}, \ttt{makefile} o \ttt{Makefile}, per poi avviare l'esecuzione utilizzando le relazioni dettate da tale file. Tramite l'opzione \ttt{[-y filename]}, invece, è possibile specificare un file avente un nome diverso dai tre precedenti.

    Le \textbf{regole} dettate all'interno di un file make possiedono la seguente struttura:
    \begin{verbatim}
    Target: Prerequisites
        Recipe
        Recipe
        ...
        Recipe
    \end{verbatim}

    dove:
    \begin{itemize}
        \item \ttt{Target} è tipicamente un file. Possono esserci più \ttt{Target} all'interno dello stesso makefile
        \item \ttt{Prerequisites} è una lista di file
        \item \ttt{Recipe} è un comando da eseguire
        \item Il carattere \ttt{<TAB>} è obbligatorio prima di ogni \ttt{Recipe} (indentazione forzata)
        \item Ogni \ttt{Recipe} associato ad un \ttt{Target} viene eseguito quando:
        \begin{itemize}
            \item All'interno della directory in cui \ttt{make} viene invocato non esiste un file di nome \ttt{Target}  e tutti i file in \ttt{Prerequisites} esistono
            \item Il file \ttt{Target} esiste ma uno o più file in \ttt{Prerequisites} sono stati aggiornati dopo la creazione del file \ttt{Target}
        \end{itemize}
        \item È possibile \textbf{specificare il \ttt{Target}} da eseguire dandolo come argomento al comando \ttt{make} (es: \ttt{make my\_target}). Se non viene specificato alcun target, verrà eseguito \textbf{solo il primo \ttt{Target}}
        \item Il carattere \ttt{\textbackslash} alla fine di una riga permette di continuare il contenuto di tale riga anche nella riga successiva
    \end{itemize}

    \textbf{Esempio:}

    \begin{verbatim}
    merge_sorted_lists: merge_sorted_lists.c
        gcc -Wall -Wextra -O3 merge_sorted_lists.c -o merge_sorted_lists\end{verbatim}

    \begin{framedprop}{Phony target}
        Un \ttt{Target} senza prerequisiti è detto \textbf{azione} o \textbf{phony target (target fasullo)}.
        
        Ogni phony target va \underline{esplicitamente dichiarato} tramite la direttiva \ttt{.PHONY target1, target2, ...}.
        
        In caso contrario, se venisse creato un file con lo stesso nome di un phony target, tale target non verrebbe mai eseguito. Difatti, un target senza prerequisiti e per cui esiste un file con quel nome viene sempre considerato come aggiornato 
    \end{framedprop}

    \textbf{Esempio:}

    \begin{itemize}
        \item Consideriamo il seguente makefile
    \begin{verbatim}
    .PHONY: clean

    merge_sorted_lists: merge_sorted_lists.c
        gcc -Wall -Wextra -O3 merge_sorted_lists.c \
                              -o merge_sorted_lists
    
    sort_file_int: sort_file_int.c
        gcc -Wall -Wextra -O3 sort_file_int.c \
                              -o sort_file_int
    
    clean:
        rm -f *.o merge_sorted_lists
    \end{verbatim}

        \item Per eseguire il target \ttt{merge\_sorted\_list}, possiamo eseguire il comando \ttt{make \\merge\_sorted\_list} o anche solo il comando \ttt{make}, poiché si tratta del primo target 
        \item Per eseguire i target \ttt{sort\_file\_int} e \ttt{clean}, possiamo eseguire rispettivamente i comandi \ttt{make sort\_file\_int} e \ttt{make clean}
    \end{itemize}

    \begin{framedobs}{}
        Nel caso in cui si voglia \textbf{eseguire automaticamente tutti i target}, solitamente viene creato target chiamato \ttt{all} i cui prerequisiti sono tutti i target.

        Ponendo tale target come primo della lista, inoltre, sarà possibile eseguire tutti i target utilizzando semplicemente il comando \ttt{make}
    \end{framedobs}

    \textbf{Esempio:}
    \begin{verbatim}
    .PHONY: clean

    all: merge_sorted_lists sort_file_int

    merge_sorted_lists: merge_sorted_lists.c
        gcc -Wall -Wextra -O3 merge_sorted_lists.c \
                                -o merge_sorted_lists
    
    sort_file_int: sort_file_int.c
        gcc -Wall -Wextra -O3 sort_file_int.c \
                                -o sort_file_int
    
    clean:
        rm -f *.o merge_sorted_lists
    \end{verbatim}

    Il linguaggio Make permette inoltre la definizione di \textbf{variabili}. È possibile accedere in lettura al contenuto di una variabile tramite la direttiva \ttt{\$(VAR)}. Per quanto riguarda l'assegnamento, invece, esso può essere effettuato in numerevoli modi:
    \begin{itemize}
        \item La direttiva \ttt{VAR := val} prevede l'espansione completa della variabile \ttt{VAR} nel momento in cui si accede al suo contenuto in lettura
        \item La direttiva \ttt{VAR = val} prevede solo l'espansione testuale della variabile \ttt{VAR} nel momento in cui si accede al suo contenuto in lettura
        \item La direttiva \ttt{VAR ?= val} assegna alla variabile \ttt{VAR} il valore \ttt{val} solo se \ttt{VAR} è vuota
        \item La direttiva \ttt{VAR += val} concatena \ttt{val} al contenuto di \ttt{VAR}
    \end{itemize}

    \textbf{Esempio:}

    \begin{verbatim}
    CC := gcc
    CFLAGS := -Wall -Wextra -O3
    
    .PHONY: clean

    all: merge_sorted_lists sort_file_int

    merge_sorted_lists: merge_sorted_lists.c
        $(CC) $(CFLAGS) merge_sorted_lists.c \
                                -o merge_sorted_lists
    
    sort_file_int: sort_file_int.c
        $(CC) $(CFLAGS) sort_file_int.c \
                                -o sort_file_int
    
    clean:
        rm -f *.o merge_sorted_lists
    \end{verbatim}

    \begin{framedprop}{Variabili automatiche}
        Ogni \ttt{Target} possiede delle \textbf{variabili automatiche} utilizzabili solo all'interno dei suoi \ttt{Recipe}:
        \begin{itemize}
            \item La variabile \ttt{\$\textasciicircum} contiene la lista dei file in \ttt{Prerequisites} del \ttt{Target}
            \item La variabile \ttt{\$<} contiene il primo file in \ttt{Prerequisites} del \ttt{Target}
            \item La variabile \ttt{\$@} contiene il nome del \ttt{Target}
        \end{itemize}
    \end{framedprop}

    \textbf{Esempio:}
    \begin{verbatim}
    CC := gcc
    CFLAGS := -Wall -Wextra -O3
    PROGS := merge_sorted_list sort_file_int
    
    all: $(PROGS)
    
    merge_sorted_lists: merge_sorted_lists.c
    $(CC) $(CFLAGS) $^ -o $@
    
    sort_file_int: sort_file_int.c
    $(CC) $(CFLAGS) $^ -o $@
    
    .PHONY: clean
    clean:
        rm -f *.o merge_sorted_lists
    \end{verbatim}

    \begin{framedobs}{Catene di dipendenze}
        Se all'interno dei \ttt{Prerequisites} del \ttt{Target} che si vuole eseguire è presente un file per cui a sua volta è definito un altro \ttt{Target} e tale file non esiste, verrà eseguito \textbf{prima il secondo \ttt{Target},} per poi eseguire il \ttt{Target} richiesto.

        In tal modo, è possibile definire \textbf{catene di dipendenze} tra i target (es: sfruttando la precompilazione)
    \end{framedobs}

    \textbf{Esempio:}
    \begin{verbatim}
    CC := gcc
    CFLAGS := -Wall -Wextra -O3

    program: file.o
        $(CC) $(CFLAGS) $^ -o $@

    file.o: file.c
        $(CC) $(CFLAGS) $< -o $@\end{verbatim}

    Inoltre, il linguaggio make prevede alcune \textbf{regole e variabili implicite}, ossia un insieme di regole e variabili che ricoprono casi comuni per la generazione di un eseguibile a partire da un sorgente C. Tali regole implicite permettono di scrivere regole senza doverne scrivere i recipe:
    
    \begin{itemize}
        \item La regola \ttt{program: file1.c file2.h, file3.c, ...} crea automaticamente l'eseguibile \ttt{program} utilizzando i file contenuti nei prerequisiti
        \item Se un target dipende solo da un prerequisito con il suo stesso nome (a meno dell'estensione), tale prerequisito è omissibile
        
        (es: la regola\ttt{program:} cerca un file \ttt{program.x} da utilizzare come prerequisito, dove \ttt{.x} è un'estensione qualsiasi)
        \item Se definite dall'utente, le regole implicite utilizzano le seguenti variabili implicite:
        \begin{itemize}
            \item La variabile \ttt{CC} contiene il compilatore da utilizzare
            \item La variabile \ttt{CFLAGS} contiene le flag da utilizzare per la compilazione
            \item La variabile \ttt{LDFLAGS} contiene le flag da utilizzare per il linking (ossia l'opzione \ttt{[-L]} di \ttt{gcc})
            \item La variabile \ttt{LDLIBS} contiene le librerie da includere in fase di linking (ossia l'opzione \ttt{[-l]} di \ttt{gcc})
        \end{itemize}
    \end{itemize}

    \textbf{Esempio:}

    \begin{verbatim}
    CC := gcc
    CFLAGS := -Wall -Wextra -O3
    PROGS := merge_sorted_lists sort_file_int main

    .PHONY: clean

    all: $(PROGS)

    main: main.c list.h list.c

    clean:
        rm -f *.o $(PROGS)
    \end{verbatim}

    \newpage

    \subsection{Corretto uso degli header file}

    Abbiamo già accennato come la direttiva \textbf{\ttt{\#include filename}} venga utilizzata per includere liberie standard o file definiti dall'utente (sezione \ref{include}).

    In particolare, abbiamo trattato di come tale direttiva imponga al pre-processore sostanzialmente di \textbf{copiare e incollare} il contenuto del file incluso all'interno del file includente. 

    \textbf{Esempio:}

    \begin{verbatim}
    ----- File: file1.c
    void func(){...}

    void main(){...}

    ----- File: file2.c
    
    #include "file1.c"
    /*
        al posto della direttiva precedente viene incollato
            "void func(){...}
    
            void main(){...}"
    */
    
    ...
    \end{verbatim}

    Per via di tale funzionamento \textit{naive}, possono verificarsi situazioni spiacevoli:
    \begin{itemize}
        \item Supponiamo che i due file \ttt{file1.c} e \ttt{file2.c} importino entrambi il file \ttt{file3.c}
        \item Supponiamo inoltre che il file \ttt{file4.c} importi sia il file \ttt{file1.c} e \ttt{file2.c}
        \item In tal caso, all'interno del file \ttt{file4.c} vi sarebbero due copie del contenuto del file \ttt{file3.c}
    \end{itemize}

    Sebbene tale utilizzo non generi alcuna problematica a livello di compilazione, quest'ultima risulterebbe essere \textbf{estremamente più lunga}, poiché verrebbero pre-compilate, compilate e linkate più volte le stesse cose. Di conseguenza, è necessario un'utilizzo corretto delle direttive disponibili, affinché non si vada ad impattare la performance.

    \begin{frameddefn}{Header file}
        All'interno di un \textbf{header file} (estensione \ttt{.h}) vengono inserite tutte le istruzioni "senza logica" (es: include, definizione di macro, dichiarazione di nuovi tipi, funzioni, ...)

        Ogni header file è \textbf{associato} (dal programmatore) \textbf{ad un file sorgente \ttt{.c}} all'interno del quale viene definita la vera logica legata alle istruzioni dell'header file (es: viene definita una funzione precedentemente dichiarata nell'header file).
    \end{frameddefn}

    \begin{itemize}
        \item Consideriamo il seguente file
    \begin{verbatim}
    ----- File: file1.c
    #include <...>
    #include <...>

    #define ...

    void func1(){...}
    void func2(){...}
    \end{verbatim}

    \item Accorpando le sue istruzioni "senza logica" in un header file, otteniamo che
    \begin{verbatim}
    ----- File: file1.h
    #include <...>
    #include <...>

    #define ...

    void func1();
    void func2();

    ----- File: file1.c
    #include "file1.h"

    void func1(){...}
    void func2(){...}
    \end{verbatim}

    \item In tal modo, il file sorgente \ttt{file1.c} avrà comunque accesso alle istruzioni "senza logica", poiché il contenuto del file \ttt{file1.h} viene copiato al suo interno, "ripristinando" il file originale 

    \end{itemize}

    \begin{framedobs}{}
        Ricordiamo che l'associazione della definizione di una funzione precedentemente dichiarata avviene nella \textbf{fase di linking}, dunque l'ultima fase.
        
        Per tanto, includendo un header file all'interno di un file sorgente (ossia il \ttt{.c}), è necessario compilare solo e comunque il file \ttt{.c}.

        In tal modo, tutti i file che vogliono utilizzare le funzioni definite nel \ttt{.c} possono importare direttamente l'header file, ottenendo così una corretta compilazione (poiché ogni cosa è definita nell'header) ed un corretto linking (poiché la logica viene associata solo in fase finale).
    \end{framedobs}

    \newpage

    \textbf{Esempio:}
    \begin{itemize}
        \item Consideriamo i file dell'esempio precedente
    \begin{verbatim}
    ----- File: file1.h
    #include <...>
    #include <...>

    #define ...

    void func1();
    void func2();


    ----- File: file1.c
    #include "file1.h"

    void func1(){...}
    void func2(){...}
    \end{verbatim}
        \item Supponiamo inoltre che esistano i seguenti file
        
    \begin{verbatim}
    ----- File: file2.c
    #include "file1.h"
    ...

    ----- File: file3.c
    #include "file1.h"
    ...
    \end{verbatim}

        \item In fase di pre-compilazione, in entrambi tali file verrebbe copiato il contenuto dell'header file \ttt{file1.h}
        \item In tal modo, entrambi i file verrebbero compilati con successo, poiché tutte le funzioni utilizzate sono dichiarate
        \item Infine, in fase di linking ad ognuna di tali funzioni dichiarate verrebbe associata la logica definita all'intero del file \ttt{file1.c}
        \item \textbf{NOTA:} nell'esempio precedente, per semplicità di dimostrazione è stato omesso l'uso dei file \ttt{file2.h} e \ttt{file3.h}. In una situazione ottimale, ovviamente, andrebbero creati anche tali file, associandoli ai loro file sorgenti tramite l'inclusione (ossia in modo analogo ai file \ttt{file1.c} e \ttt{file1.h})
    \end{itemize}

    \begin{framedprop}{Direttive \ttt{\#ifndefn} e \ttt{\#endif}}
        Le \textbf{direttive \ttt{\#ifndefn VAR} e \ttt{\#endif}} impongono al pre-compilatore di interpretare una porzione di codice (es: durante un \ttt{\#include}) \textbf{solo se \ttt{VAR} non è definita}.
    \end{framedprop}

    \textbf{Esempio:}
    \begin{verbatim}
    #ifdefn VAR
    ...
    #endif
    \end{verbatim}

    \begin{framedobs}{}
        Le direttive \ttt{\#ifndefn VAR} e \ttt{\#endif} possono essere utilizzate per far si che un header file venga copiato solo ed esclusivamente una volta all'interno del codice (\textbf{include guards}), riducendo notevolmente i tempi di compilazione.
    \end{framedobs}

    \textbf{Esempio:}
    \begin{itemize}
        \item Consideriamo i seguenti file:
        
    \begin{verbatim}
    ----- File: file1.h
    #ifndefn FILE1_H
    #define FILE1_H

    #include "file1.h"
    ...

    #endif

    ----- File: file2.h
    #include "file1.h"

    ----- File: file3.h
    #include "file2.h"
    #include "file1.h"
    \end{verbatim}

        \item La porzione di codice all'interno di \ttt{file1.h} circondata dagli include guards viene eseguita una sola volta, poiché durante la sua prima esecuzione viene impostata la variabile \ttt{FILE\_H}, rendendo la condizione di \ttt{\#ifndefn} falsa tutte le successive volte 
        \item Di conseguenza, tramite l'uso degli include guards, il contenuto del file \ttt{file1.h} viene copiato all'interno del file \ttt{file3.h} solo una volta, "ignorando" il secondo import
    \end{itemize}

    \quad

    \subsection{Debugging con \ttt{gdb}}

    Nello sviluppo di codice è spesso utile eseguire e fermare un programma per effetture operazioni di \textbf{debugging}. In particolare, essendo un linguaggio più verso il basso livello, tale funzionalità risulta particolarmente utile per il linguaggio C.

    Per effettuare debugging di programmi scritti in C, abbiamo i seguenti strumenti:
    \begin{itemize}
        \item L'opzione \ttt{[-g]} del comando \ttt{gcc} permette di inserire dei \textbf{simboli di debug} all'interno del codice (es: il codice sorgente del programma stesso, ...). L'uso di tale opzione permette di visualizzare più comodamente il contenuto delle varie variabili, chiamate di funzione, ecc. Tali simboli di debug possono essere \textbf{rimossi} dal programma utilizzanto il comando \ttt{strip}.
        \item Il programma \ttt{gdb} (GNU Project Debugger) permette di effettuare operazioni di debugging (funziona anche per altri linguaggi) 
    \end{itemize}

    \begin{framedobs}{}
        Senza l'opzione \ttt{[-g]} per il comando \ttt{gcc}, l'uso del programma \ttt{gdb} risulta molto più complesso in quanto dovremmo essere noi a tener traccia di quale registro della CPU o quale indirizzo di memoria contenga quale variabile.

        Utilizzando assieme i due strumenti, dunque, possiamo comodamente effettuare operazioni di debugging. Difatti, 
    \end{framedobs}

    In particolare, evidenziamo i seguenti comandi eseguibili all'interno di \ttt{gdb}:
    \begin{itemize}
        \item \ttt{file program} permette di selezionare l'eseguibile \ttt{program}
        \item \ttt{run} permette di avviare l'esecuzione dell'eseguibile selezionato
        \item \ttt{list start,end} permette di visualizzare il codice del programma partendo dalla riga \ttt{start} fino alla riga \ttt{end} (solo se \ttt{[-g]} viene usato)
        \item \ttt{diplay var} permette di visualizzare il contenuto della variabile \ttt{var} (solo se \ttt{[-g]} viene usato)
        \item \ttt{break line} permette di inserire un \textbf{breakpoint} sulla linea di codice \ttt{line}, implicando che l'esecuzione del programma verrà interrotta prima di eseguire la linea \ttt{line} (solo se \ttt{[-g]} viene usato)
        \item \ttt{step} permette di eseguire l'istruzione successiva (solo durante una pausa di esecuzione)
        \item \ttt{jump line} permette riprendere l'esecuzione del programma dalla linea \ttt{line}, saltando tutte le istruzioni nel mezzo (solo durante una pausa di esecuzione)
    \end{itemize}

    \newpage

    \textbf{Esempio:}
    \begin{verbatim}
    [exyss@exyss ~]$ cat test.c
    #include <stdio.h>
    
    int main(){
        int a=0;
        a++;
        a = a + 1;
        a = a + 2;
        a += 3;
        a += 4;
        a = a + 5;
        printf("Il valore di a e': %d\n", a);
        return a+1;
    }

    [exyss@exyss ~]$ gcc -g test.c -o test

    [exyss@exyss ~]$ gdb

    GNU gdb (GDB) 13.1
    [...]
    [...]
    For help, type "help".
    Type "apropos word" to search for commands related to "word".

    (gdb) file test
    Reading symbols from test...

    (gdb) list 1,20
    1    #include <stdio.h>
    2    
    3    int main(){
    4        int a=0;
    5        a++;
    6        a = a + 1;
    7        a = a + 2;
    8        a += 3;
    9        a += 4;
    10        a = a + 5;
    11        printf("Il valore di a e': %d\n", a);
    12        return a+1;
    13    }

    (gdb) display a
    No symbol "a" in current context.
    (gdb) break 8
    Breakpoint 1 at 0x1154: file test.c, line 8.
    
    (gdb) run
    Breakpoint 1, main () at test.c:8
    8        a += 3;

    (gdb) display a
    1: a = 4

    (gdb) step
    9        a += 4;
    1: a = 7

    (gdb) jump 11
    Continuing at 0x555555555160.
    Il valore di a e': 7
    [Inferior 1 (process 5258) exited with code 010]

    (gdb) exit
    \end{verbatim}

    \chapter{Programmazione di sistema}

    Con il termine \textbf{programmazione di sistema} intendiamo la scrittura di codice relativo all'uso di \tbf{risorse del sistema operativo} (es: CPU, RAM, Dispositivi I/O, ...). In particolare, ricordiamo che all'interno di un sistema operativo il componente che si occupa della gestione, dell'accesso e dell'utilizzo delle risorse disponibili sia il \textbf{kernel}. 
    
    Il sistema operativo mette a disposizione una serie di \textbf{syscalls (system calls)}, ossia un limitato numero di "punti di accesso" al kernel, in modo da permettere ad un programma di interfacciare con esso. Le syscall possono essere utilizzate \textbf{direttamente} o tramite \textbf{funzioni di generali}, ossia le funzioni delle librerie standard che utilizzano in modo ottimale tali syscall (es: la funzione \ttt{malloc()} usa la syscall \ttt{sbrk()}).

    Inoltre, ricordiamo che le informazioni relative alle syscall si trovino all'interno della sezione 2 del \ttt{man}, mentre le funzioni di libreria generali si trovino nella sezione 3.

    \quad

    \begin{center}
        \includegraphics[scale=0.35]{images/kernel.png}
    \end{center}

    \newpage

    \section{System calls}

    Nel linguaggio C, la definizione delle syscall è \textbf{indipendente} dalla tecnica utilizzata dallo specifico sistema operativo stesso per invocare le syscall stesse. Difatti, \textbf{per ogni syscall del sistema operativo esiste una funzione C avente lo stesso nome}, permettendo ad un processo utente di utilizzare tali syscall come se fossero normali funzioni:
    \begin{itemize}
        \item Il processo utente invoca tali funzioni, passando come argomento i dati richiesti
        \item Le funzioni invocano il corrispettivo servizio del kernel utilizzando la tecnica richiesta (es: mettendo gli argomenti dati in registri specifici e poi generando un interrupt)
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.325]{images/syscall.png}
    \end{center}

    Di conseguenza, abbiamo che:
    \begin{itemize}
        \item Nel linguaggio C, sia le syscall che le funzioni generali sono funzioni
        \item Entrambe forniscono servizi generali ad un programma
        \item Una funzione generale può essere rimpiazzata da un'altra funzione, ma una syscall no
        
        (es: possiamo implementare la nostra versione della funzione \ttt{malloc()}, ma dovremo sempre necessariamente utilizzare la syscall \ttt{sbrk()} al suo interno)

        \item Le syscall introducono una separazione dei compiti
        
        (es: la syscall \ttt{sbrk} alloca porzioni di memoria in kernel mode, le quali vengono gestite in user mode dal resto delle istruzioni presenti all'interno della funzione \ttt{malloc()})
        \item Le funzioni di libreria semplificano l'uso delle syscall. Difatti, quest'ultime espongono un'interfaccia minimale, mentre le funzioni di libreria forniscono funzionalità più elaborate 
    \end{itemize}

    \newpage

    L'esecuzione di una syscall può \textbf{interrompersi} e non andare a buon fine per diversi motivi (es: mancanza di privilegi, di risorse o argomenti invalidi). Per tale motivo, è \underline{fondamentale} controllare i valori di ritorno delle syscall e segnalare all'utente l'eventuale verificarsi di errori.

    Per ottenere ciò, le librerie standard forniscono i seguenti strumenti per gestire gli errori delle syscall:
    \begin{itemize}
        \item La libreria \ttt{<errno.h>} fornisce la \textbf{variabile \ttt{errno}} all'interno della quale viene conservato il \textbf{codice di errore dell'ultima syscall andata in errore} (dunque, se una syscall va a buon fine, non verrà modificato il valore di \ttt{errno})
        \item La libreria \ttt{<string.h>} fornisce la funzione \ttt{char* strerror(int errnum)}, la quale restituisce in output un \textbf{messaggio di errore} ottenuto "traducendo" il codice di errore di una syscall dato in input.
        \item La libreria \ttt{<stdio.h>} fornisce la funzione \ttt{void perror(const char* prefix)}, la quale \textbf{scrive su stderr} la stringa \ttt{"prefix:errno\_str\textbackslash n"}, dove \ttt{errno\_str} è il messaggio restituito da \ttt{strerror(errno)}
        
        Dunque, si ha che \ttt{perror("main")} è equivalente a \ttt{fprintf(stderr, "main:\%s\textbackslash n", stderror(errno))}
    \end{itemize}

    In alcuni casi, può anche essere utile \textbf{monitorare} tramite il comando \ttt{strace} le syscall invocate da un processo (vedere il manuale per le opzioni). 

    \quad

    \section{Gestione della memoria}

    Le varie funzioni \ttt{malloc}, \ttt{calloc}, \ttt{realloc}, ecc utilizzano delle syscall della liberia \ttt{<unistd.h>} per effettuare le operazioni di gestione della memoria:
    \begin{itemize}
        \item La syscall \ttt{int brk(void* addr)} permette di definire la fine del data segment di un processo
        \item La syscall \ttt{void* sbrk(intptr\_t increment)} permette di incrementare il data space (ossia l'intero spazio dati occupato) di un processo
    \end{itemize}

    L'uso da parte dell'utente di tali syscall risulta \textbf{pericoloso} (soprattutto \ttt{brk}). Per tanto, è consigliato di utilizzarle solo dopo averne studiato molto attentamente il funzionamento sul manuale.

    Per quanto riguarda la gestione dei file in memoria, invece, la libreria \ttt{<sys/mman.h>} fornisce la syscall \ttt{void* mmap(void* addr, size\_t len, int prot, int flags, int fd, off\_t off)}, la quale permette di \textbf{mappare un file ad un'area di memoria}, dove:
    \begin{itemize}
        \item \ttt{addr} è l'indirizzo iniziale dell'area di memoria in cui effettuare la mappatura. Se \ttt{addr = NULL}, il kernel sceglierà da solo.
        \item \ttt{len} è il numero di byte da trasferire
        \item \ttt{prot} è il livello di protezione. Può essere impostato a:
        \begin{itemize}
            \item \ttt{PROT\_READ}: permette la lettura della regione di memoria
            \item \ttt{PROT\_WRITE}: permette la scrittura della regione di memoria
            \item \ttt{PROT\_EXEC}: permette l'esecuzione della regione di memoria
            \item \ttt{PROT\_NONE}: impedisce l'accesso alla regione di memoria
        \end{itemize}
        \item \ttt{flag} specifica se le operazioni effettuate valgano anche per altri processi che stanno mappando la stessa regione. Può essere impostato a:
        \begin{itemize}
            \item \ttt{MAP\_SHARED}: la regione è condivisa, implicando che le modifiche siano condivise tra tutti i processi
            \item \ttt{MAP\_PRIVATE}: viene creata una copia privata del mapped file, implicando che le modifiche abbiano effetto solo a livello locale
        \end{itemize}
        \item \ttt{fd} è il file descriptor del file (il quale deve essere prima aperto)
        \item \ttt{off} è l'offset del file
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.5]{images/mmap.png}
    \end{center}
    
    Tale syscall viene utilizzata prevalentemente per gestire operazioni di \textbf{memory-mapped I/O}, permettendo alle operazioni di lettura/scrittura sul buffer creato di risultare come se siano state effettuate sul disco, senza che quest'ultimo venga realmente acceduto.

    \newpage

    La libreria \ttt{<sys/mman.h>}, inoltre, fornisce le ulteriori seguenti due syscall relative al memory-mapped I/O:
    \begin{itemize}
        \item La syscall \ttt{int msync(void* addr, size\_t len, int flags)} permette di scrivere sul disco le modifiche effettuate ad un file memory-mapped (solo se mappato usando \ttt{MAP\_SHARED})
        \item La syscall \ttt{int munmap(void* addr, size\_t len)} permette di de-mappare una regione di memoria.
    \end{itemize}

    \begin{framedobs}{}
        Quando un processo termina, le sue regioni mappate vengono \textbf{automaticamente de-mappate}, ma il contenuto delle regioni \textbf{non viene scritto sul disco}.

        Per tanto, è sempre buona prassi scrivere manualmente con \ttt{msync()} per poi de-mappare con \ttt{munmap()}
    \end{framedobs}

    \quad

    \section{File descriptors}
    
    Precedentemente, abbiamo discusso di come un file sia un'\textbf{astrazione} che descrive ogni cosa all'interno dell'ambiente Linux (fatta eccezione dei processi) ed abbiamo accenato come ogni file aperto possieda un \textbf{file descriptor}, ossia un intero univoco facente riferimento ad esso.

    In particolare, i file descriptor corrispondono ad un \textbf{intero} e sono \textbf{relativi ad un processo}. Gli interi associati ai file descriptor sono \textbf{univoci per un processo} e vengono generati in modo \textbf{sequenziale}, partendo dall'intero 0 ed assegnando l'intero più basso disponibile. Quando un file descriptor viene \textbf{chiuso}, il suo intero potrà essere riutilizzato.
    
    \begin{framedobs}{}
        È possibile \textbf{aprire più volte lo stesso file} (anche su più processi), ottendo file descriptor diversi facenti riferimento allo stesso file.
    \end{framedobs}
    
    Di default, ogni processo possiede i seguenti tre file descriptor associati ai canali standard:
    \begin{itemize}
        \item Il file descriptor \ttt{0} facente riferimento a \ttt{stdin}
        \item Il file descriptor \ttt{1} facente riferimento a \ttt{stdout}
        \item Il file descriptor \ttt{2} facente riferimento a \ttt{stderr}
    \end{itemize}
    
    \begin{center}
        \includegraphics[scale=0.525]{images/file_descriptors.png}
    \end{center}

    Ad ogni file descriptor sono associate due categorie di flag:
    \begin{itemize}
        \item \textbf{File status flags}, le quali contengono informazioni relative allo stato del file e sono condivise tra tutti i file descriptor clonati da un altro file descriptor (torneremo su questo)
        
        \item \textbf{File descriptor flags}, le quali sono indipendenti dal contenuto e dallo stato del file, descrivendo le proprietà e il comportamento delle operazioni effettuate sul file stesso. 
        
        Ogni file descriptor facente riferimento allo stesso file possiede le proprie file descriptor flags ed alcuni di quest'ultimi possono essere definiti solo per alcuni tipi di file speciali.
    \end{itemize}

    Le \textbf{flag} vengono rappresentate mediante \textbf{maschere di bit}, dove se un determinato bit associato ad un flag è impostato ad 1, tale flag verrà considerato come impostato (in modo analogo alle maschere dei privilegi e alla umask).
    
    Per ogni maschera di una flag impostabile esiste una \textbf{macro} (es: \ttt{O\_RDONLY}). Tali flag possono essere combinate tra loro mettendo in \textbf{bit-wise OR} le loro maschere.

    (es: date le macro \ttt{MACRO1 = 01000000} e \ttt{MACRO2 = 00001000}, si ha che \ttt{MACRO1 | MACRO2 = 01001000} e dunque che entrambe le flag siano impostate)

    Le \textbf{file status flag} si dividono a loro volta in tre categorie:
    \begin{itemize}
        \item \textbf{Flag di modalità di accesso}, le quali definiscono la modalità con cui accedere al file, ossia in lettura, in scrittura o in entrambe. Una volta aperto il file, esse non possono essere modificate.
        \item \textbf{Flag di modalità di apertura}, le quali definiscono le azioni eseguite durante l'apertura del file e non vengono conservate.
        \item \textbf{Flag delle modalità operative}, le quali definiscono il comportamento delle operazioni di lettura e scrittura. Possono essere modificate anche mentre il file è aperto.
    \end{itemize}


    \begin{frameddefn}{Duplicazione di un file descriptor}
        Definiamo come \textbf{duplicazione} di un file descriptor l'operazione tramite, all'interno del processo chiamante, viene creato un nuovo file descriptor facente riferimento allo stesso file del file descriptor dato
    \end{frameddefn}
    
    La libreria \ttt{<unistd.h>} fonisce:
    \begin{itemize}
        \item La syscall \ttt{int dup(int oldfd)}, la quale è in grado di duplicare il file descriptor \ttt{oldfd}. Il numero associato al nuovo file descriptor sarà il numero più basso associabile all'interno del processo chiamante. Viene ritornato il nuovo file descriptor.
        \item La syscall \ttt{int dup2(int oldfd, int newfd)}, la quale è in grado di duplicare il file descriptor \ttt{oldfd}.Il numero associato al nuovo file descriptor sarà \ttt{newfd}. Viene ritornato il nuovo file descriptor (ossia \ttt{newfd}).
        
        Inoltre, si ha che:
        \begin{itemize}
            \item Se esiste già un file descriptor avente numero \ttt{newfd}, esso verrà chiuso
            \item Se \ttt{oldfd} non è un file descriptor valido, la chiamata fallirà e \ttt{newfd} non verrà chiuso in alcun caso
            \item Se \ttt{oldfd = newfd}, la chiamata non avrà effetto e verrà ritornato \ttt{newfd}
        \end{itemize}
    \end{itemize}


    \begin{framedobs}{}
        La syscall \ttt{dup2()} può essere utilizzata per effettuare le \textbf{ridirezioni dei canali}
    \end{framedobs}

    \textbf{Esempio:}

    \begin{itemize}
        \item La syscall \ttt{dup2(2, 1)} fa si che il file descriptor 1 faccia riferimento ad stderr, chiudendo stdout. Di conseguenza, tutte le operazioni di scrittura effettuate sul file descriptor 1, verranno effettuate su stderr
        \item In particolare, ricordiamo che il file pointer \ttt{stdout} presente di default nella libreria \ttt{<stdio.h>} contenga al suo interno il file descriptor 1. Per tanto, statement come \ttt{printf(...)} e \ttt{fprintf(stdout, ...)} verranno ridirezionati su stderr
    \end{itemize}

    \newpage

    \section{Gestione dei file}

    \subsection{Operazioni sui file}

    Per \textbf{aprire un file}, la libreria \ttt{<fcntl.h>} (importata anche da \ttt{<stdio.h>}) fornisce le due syscall
    \[\ttt{int open(const char* pathname, int flags)}\]
    \[\ttt{int open(const char* pathname, int flags, mode\_t mode)}\]
    dove:
    \begin{itemize}
        \item \ttt{pathname} corrisponde al \textbf{nome del file} da aprire
        \item \ttt{flags} definisce le \textbf{flag in bit-wise OR} da impostare
        \item \ttt{mode} definisce i \textbf{privilegi in bit-wise OR }da impostare per il file nel caso in cui venga creato
        \item L'intero restituito è il \textbf{file descriptor} aperto 
    \end{itemize}

    \quad

    Le flag impostabili all'interno del parametro \ttt{flags} corrispondono a:
    \begin{itemize}
        \item \ttt{O\_RDONLY}: il file viene aperto in lettura
        \item \ttt{O\_WRONLY}: il file viene aperto in scrittura
        \item \ttt{O\_RDWR}: il file viene aperto in lettura e scrittura
        \item \ttt{O\_CREAT}: se non esiste, il file viene creato. Richiede la presenza del parametro \ttt{mode} (dunque l'uso della seconda syscall)
        \item \ttt{O\_EXCL}: se utilizzato assieme a \ttt{O\_CREAT}, genera un errore se il file esiste già.
        \item \ttt{O\_APPEND}: se la modalità di accesso consente la scrittura, il contenuto scritto viene appeso alla fine del contenuto precedente (se esistente)
        \item \ttt{O\_TRUNC}: se la modalità di accesso consente la scrittura e il file è un file regolare, il contenuto precedente del file viene troncato
    \end{itemize}

    A questo punto, risulta ovvia l'analogia tra le modalità di apertura di \ttt{open()} e le modalità di apertura di \ttt{fopen()}. Difatti, la funzione di libreria \ttt{fopen()} usufruisce al suo interno della syscall \ttt{open()}.

    \begin{center}
        \begin{tabular}{c|l}
            \textbf{\ttt{fopen()} mode} & \textbf{\ttt{open()} flags}\\
            \hline
            \ttt{r} & \ttt{O\_RDONLY}\\
            \ttt{w} & \ttt{O\_WRONLY | O\_CREAT | O\_TRUNC}\\
            \ttt{a} & \ttt{O\_WRONLY | O\_CREAT | O\_APPEND}\\
            \ttt{r+} & \ttt{O\_RDWR}\\
            \ttt{w+} & \ttt{O\_RDWR | O\_CREAT | O\_TRUNC}\\
            \ttt{a+} & \ttt{O\_RDWR | O\_CREAT | O\_APPEND}\\
        \end{tabular}
    \end{center}

    \newpage
    
    Per quanto riguarda il parametro \ttt{mode}, invece, il suo tipo di dato è \ttt{mode\_t} (una macro per \ttt{int}), utilizzato per indicare che il valore assunto sia un \textbf{bit-wise OR} delle seguenti maschere:
    \begin{itemize}
        \item \ttt{S\_IRWXU}: vengono impostati i permessi di lettura, scrittura ed esecuzione per il proprietario del file
        \item \ttt{S\_IRUSR}: viene impostato il permesso di lettura per il proprietario del file
        \item \ttt{S\_IWUSR}: viene impostato il permesso di scrittura per il proprietario del file
        \item \ttt{S\_IXUSR}: viene impostato il permesso di esecuzione per il proprietario del file
        
        \item \ttt{S\_IRWXG}: vengono impostati i permessi di lettura, scrittura ed esecuzione per il gruppo di appartenenza del file
        \item \ttt{S\_IRGRP}: viene impostato il permesso di lettura per il gruppo di appartenenza del file
        \item \ttt{S\_IWGRP}: viene impostato il permesso di scrittura per il gruppo di appartenenza del file        
        \item \ttt{S\_IXGRP}: viene impostato il permesso di esecuzione per il gruppo di appartenenza del file
        
        \item \ttt{S\_IRWXO}: vengono impostati i permessi di lettura, scrittura ed esecuzione per gli altri utenti del file
        \item \ttt{S\_IROTH}: viene impostato il permesso di lettura per gli altri utenti del file
        \item \ttt{S\_IWOTH}: viene impostato il permesso di scrittura per gli altri utenti del file        
        \item \ttt{S\_IXOTH}: viene impostato il permesso di esecuzione per gli altri utenti del file
        
        \item \ttt{S\_ISUID}: viene impostato il bit di SetUID per il file
        \item \ttt{S\_ISGID}: viene impostato il bit di SetGID per il file
        \item \ttt{S\_ISVTX}: viene impostato lo sticky bit per il file
    \end{itemize}

    \begin{framedobs}{}
        I privilegi definiti dal parametro \ttt{mode} verranno applicati \textbf{solo se il file viene creato} (dunque solo se la flag \ttt{O\_CREAT} è impostata).
    \end{framedobs}

    La libreria \ttt{<unistd.h>}, invece, fornisce le syscall relative alle \textbf{operazioni su file}:
    \begin{itemize}
        \item La syscall \ttt{ssize\_t read(int fd, void* buf,
        size\_t count)} legge \ttt{count} byte dal file avente file descriptor \ttt{fd}, copiando il contenuto nel buffer \ttt{buf}. Viene ritornato il numero di byte letti dal file (-1 se errore).
        \item La syscall \ttt{ssize\_t write(int fd, const void* buf, size\_t count)} legge \\\ttt{count} byte dal buffer \ttt{buf}, copiando il contenuto nel file avente file descriptor \ttt{fd}. Viene ritornato il numero di byte scritti sul file (-1 se errore).
        \item La syscall \ttt{int close(int fd)} chiude il file descriptor \ttt{fd}. Viene ritornato 0 se la chiusura va a buon fine (-1 se errore)
        \item La syscall \ttt{int lseek(int fd, off\_t offset, int whence)} imposta il cursore alla posizione \ttt{whence} incrementata di \ttt{offset} byte. I valori impostabili per il campo \ttt{whence} sono:
        \begin{itemize}
            \item \ttt{SEEK\_SET}, ossia l'inizio del file
            \item \ttt{SEEK\_CUR}, ossia la posizione attuale del cursore
            \item \ttt{SEEK\_END}, ossia la fine del file
        \end{itemize}
    \end{itemize}


    \begin{framedobs}{}
        Le syscall \ttt{read()}, \ttt{write()} e \ttt{lseek()} risultano analoghe alle funzioni \ttt{fread()}, \\\ttt{fwrite()} e \ttt{fseek()} utilizzabili su un file pointer.
        
        Tuttavia, a differenza di esse, la lettura e la scrittura \textbf{non sono bufferizzate}, mentre, in caso di successo, \ttt{lseek()} ritorna la \textbf{nuova posizione del cursore}, a differenza di \ttt{fseek()} che ritorna 0 (entrambe ritornano -1 se la nuova posizione è invalida).
    \end{framedobs}

    \begin{framedobs}{}
        Se per un determinato file vi sono \textbf{più file descriptor aperti}, il file verrà chiuso solamente quando tutti i file descriptor saranno chiusi.
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    #include <unistd.h>
    #include <fcntl.h>

    void main(){
        //Modalità apertura: "w"
        int flags = O_WRONLY | O_CREAT | O_TRUNC;

        //Privilegi: rw-r--r--
        int mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;

        int fd = open("hello.txt", flags, mode);    //apertura
        
        char str[14] = "Hello World!\n";    //scrittura
        
        write(fd, str, 13);     //chiusura

        close(fd);
    }
    \end{verbatim}

    \subsection{Manipolazione delle proprietà dei file}

    Per \textbf{manipolare} le informazioni, le proprietà  e i privilegi dei file, vengono fornite numerevoli syscall, sparse per le varie librerie standard.

    La libreria \ttt{<sys/stat.h>}, ad esempio, fornisce:
    \begin{itemize}
        \item Uno struct \ttt{stat}, avente i seguenti campi:
        
\begin{verbatim}
struct stat {
    dev_t      st_dev;      // ID of device containing file 
    ino_t      st_ino;      // Inode number 
    mode_t     st_mode;     // File type and mode 
    nlink_t    st_nlink;    // Number of hard links 
    uid_t      st_uid;      // User ID of owner 
    gid_t      st_gid;      // Group ID of owner 
    dev_t      st_rdev;     // Device ID (if special file) 
    off_t      st_size;     // Total size, in bytes 
    blksize_t  st_blksize;  // Block size for filesystem I/O 
    blkcnt_t   st_blocks;   // Number of 512 B blocks allocated 

    struct timespec  st_atim;  // Time of last access 
    struct timespec  st_mtim;  // Time of last modification 
    struct timespec  st_ctim;  // Time of last status change 
};
\end{verbatim}
        \item La syscall \ttt{int stat(const char* path, struct stat* buf)}, la quale inserisce le informazioni relative al file dato all'interno del buffer \ttt{buf} 
        \item La syscall \ttt{int fstat(int fd, struct stat* buf)}, analoga a \ttt{stat()} ma utilizzante un file descriptor
        \item Le macro \ttt{S\_ISREG(m)}, \ttt{S\_ISDIR(m)}, \texttt{S\_ISCHR(m)}, \ttt{S\_ISBLK(m)}, \ttt{S\_ISFIFO(m)}, \\\ttt{S\_ISLNK(m)}, \ttt{S\_ISSOCK(m)} per verificare il tipo del file in base agli attributi dello struct \ttt{m} di tipo \ttt{stat}
        \item La syscall \ttt{int chmod(const char* path, mode\_t mode)}, la quale sostituisce i privilegi del file dato con la maschera \ttt{mode}
        \item La syscall \ttt{int fchmod(int fd, mode\_t mode)}, analoga a \ttt{chmod()} ma utilizzante un file descriptor
    \end{itemize}

    \begin{framedobs}{}
        Ricordiamo che il tipo \ttt{mode\_t} utilizzato come campo dallo struct \ttt{stat} e come parametro dalle syscall \ttt{chmod()}, \ttt{fchmod()}, \ttt{mkdir()} sono di tipo \ttt{mode\_t}, sia lo stesso del parametro \ttt{mode} della syscall \ttt{open()}.
        
        Per tanto, esso corrisponde ad una \textbf{maschera in bit-wise OR} delle macro relative ai privilegi (\ttt{S\_IRWXU}, \ttt{S\_IRUSR}, ...)
    \end{framedobs}

    \newpage

    La libreria \ttt{<unistd.h>}, invece, fornisce:
    \begin{itemize}
        \item La syscall \ttt{int chown(const char* path, uid\_t owner, gid\_t group)}, la quale modifica il proprietario e il gruppo di appartenenza del file.
        
        Se l'UID dato in input è \ttt{-1}, il proprietario rimane inalterato. Analogamente, lo stesso avviene per il GID dato.

        \item La syscall \ttt{int fchown(int fd, uid\_t owner, gid\_t group)}, analoga a \ttt{fchown()} ma utilizzante un file descriptor
        
        \item La syscall \ttt{int unlink(const char* path)}, la quale rimuove un link (hard o soft) dal file system. Se tale link è l'ultimo hardlink relativo ad un file, viene eliminato anche il file
        \item La syscall \ttt{int ink(const char* target, const char* linkpath)}, la quale crea un hardlink di nome \ttt{linkpath} verso il file puntato da \ttt{target}
        
        \item La syscall \ttt{int symlink(const char* target, const char* linkpath)}, la quale crea un softlink di nome \ttt{linkpath} verso il file (o link) puntato da \ttt{target}
    \end{itemize}

    Infine, la libreria \ttt{<stdio.h>} fornisce:
    \begin{itemize}
        \item La syscall \ttt{int rename(const char* oldpath, const char* newpath)}, la quale rinomina (o sposta) il file \ttt{oldpath} nel file \ttt{newpath}
    \end{itemize}

    \quad

    \subsection{Operazioni sulle directory}
    Per quanto riguarda le \textbf{directory} (che ricordiamo essere solo dei file speciali), vengono fornite anche le seguenti syscall e funzioni di libreria:
    \begin{itemize}
        \item La syscall \ttt{int mkdir(const char* path, mode\_t mode)}, la quale crea la directory \ttt{path} con la maschera di permessi \ttt{mode} (fornita da \ttt{<sys/stat.h>})
        \item La syscall \ttt{int chdir(const char* path)}, la quale imposta la \ttt{working directory} del processo su \ttt{path} (fornita da \ttt{<unistd.h>})
        \item La syscall \ttt{int chroot(const char* path)}, la quale imposta la \ttt{root directory} del processo su \ttt{path} (fornita da \ttt{<unistd.h>})
        \item La funzione \ttt{DIR* opendir(const char* path)}, la quale apre la directory \ttt{path} e restituisce un puntatore ad uno struct di tipo \ttt{DIR}, un tipo esclusivo restituito \textbf{solo da questa funzione} (fornita da \ttt{<sys/types.h>} e \ttt{<dirent.h>} - entrambe le librerie sono necessarie)
        \item La funzione \ttt{DIR* fdopendir(int fd)}, analoga a \ttt{opendir()} ma utilizzante un file descriptor, dunque richiedente prima l'uso di \ttt{open()} (fornita da \ttt{<sys/types.h>} e \ttt{<dirent.h>} - entrambe le librerie sono necessarie)
        \item La funzione \ttt{int closedir(DIR* dirp)}, la quale chiude la directory puntata da \ttt{dirp}  (fornita da \ttt{<sys/types.h>} e \ttt{<dirent.h>} - entrambe le librerie sono necessarie)
        \item La funzione \ttt{int rmdir(const char* path)}, la quale rimuove la directory \ttt{path} (fornita da \ttt{<unistd.h>})
        \item La funzione \ttt{struct dirent* readdir(DIR* dirp)}, la quale legge le informazioni del prossimo elemento disponibile all'interno della directory puntata da \ttt{dirp}, restituendo un oggetto di tipo \ttt{dirent} contenente tali informazioni o \ttt{NULL} se non vi sono elementi rimanenti (fornita da \ttt{<dirent.h>}).
        
\begin{verbatim}
struct dirent {
    ino_t          d_ino;       // Inode number 
    off_t          d_off;       // Not an offset; check the man
    unsigned short d_reclen;    // Length of this record 
    unsigned char  d_type;      // Type of file; not supported
                                    by all filesystem types 
    char           d_name[256]; // Null-terminated filename
};\end{verbatim}

    \end{itemize}

    \quad

    \section{Sincronizzazione tra processi}

    \begin{frameddefn}{Lock}
        Un \textbf{lock} è un meccanismo che permette la \textbf{sincronizzazione tra processi}, impedendo ad essi di  accedere simultaneamente alla stessa risorsa (\textbf{mutua esclusione})
    \end{frameddefn}

    Una syscall di fondamentale importanza nell'ambito dell'uso dei lock è la syscall
    \[\ttt{int fcntl(int fd, int cmd, ... /* arg */)}\]
    fornita dalla libreria \ttt{<fcntl.h>}. Tale syscall è in grado di:
    \begin{itemize}
        \item Duplicare il file descriptor \ttt{fd}
        \item Manipolare le flag del file descriptor \ttt{fd}
        \item Manipolare le flag di status del file riferito dal file descriptor \ttt{fd}
        \item Gestire i lock su \ttt{fd}
    \end{itemize}

    A tali operazioni sono associati un \textbf{insieme di comandi}, ai quali è associata una macro passabile come valore al parametro \ttt{cmd}. Il parametro \ttt{arg} è \textbf{opzionale} e definisce l'eventuale parametro da dare in input al comando definito tramite \ttt{cmd}.

    In particolare, gli argomenti dei comandi relativi alla \textbf{gestione dei lock} sono di tipo \ttt{flock}, uno struct definito come:

    \begin{verbatim}
    struct flock {
        ...
        short l_type;   // Type of lock:
                        // F_RDLCK, F_WRLCK, F_UNLCK

        short l_whence; // How to interpret l_start:
                        // SEEK_SET, SEEK_CUR, SEEK_END
                        
        off_t l_start;  // Starting offset for lock
        off_t l_len;    // Number of bytes to lock
        pid_t l_pid;    // PID of process blocking our lock
                        // (set by F_GETLK and F_OFD_GETLK) 
        ...
    };
    \end{verbatim}

    dove:
    \begin{itemize}
        \item L'attributo \ttt{l\_type} determina il tipo di operazione sul lock richiesta
        \item L'attributo \ttt{l\_whence} determina il punto di inizio del lock e può essere impostato a:
        \begin{itemize}
            \item \texttt{SEEK\_SET}, ossia l'inizio del file
            \item \texttt{SEEK\_CUR}, ossia la posizione attuale del cursore
            \item \texttt{SEEK\_END}, ossia la fine del file
        \end{itemize}
        \item L'attributo \ttt{l\_start} determina l'offset di byte da \ttt{l\_whence} per cui applicare il lock (dunque il vero punto di partenza è \ttt{l\_whence + l\_start})
        \item L'attributo \ttt{l\_len} determina quanti byte a partire da \ttt{l\_whence + l\_start} vengano bloccati. Se \ttt{l\_len = 0}, viene bloccato l'intero file.
    \end{itemize}

    Per comodità, listeremo i vari comandi e i suoi parametri utilizzando la notazione \ttt{cmd(type)}, dove \ttt{type} è il tipo dell'argomento da dare. Tuttavia, ricordiamo che l'uso corretto dei comandi sia \ttt{fcntl(fd, cmd)} (o \ttt{fcntl(fd, cmd, arg)} se viene utilizzato anche tale parametro):

    \begin{itemize}
        \item Il comando \ttt{F\_GETFL()} restituisce la modalità di accesso del file e le sue flag di status
        
        (es: \ttt{val = fcntl(fd, F\_GETFL)})

        \item Il comando \ttt{F\_SETFL(int)} imposta le file status flag. L'argomento dato può essere \ttt{O\_APPEND}, \ttt{O\_ASYNC}, \ttt{O\_DIRECT}, \ttt{O\_NOATIME} o \ttt{O\_NONBLOCK}
        
        (es: \ttt{fcntl(fd, F\_SETFL, O\_APPEND)})

        \item Il comando \ttt{F\_SETLK(flock)} acquisisce o rilascia un lock sul file:
        \begin{itemize}
            \item Se l'attributo \ttt{l\_type} dell'argomento dato è impostato a \ttt{F\_RDLCK}, verrà acquisito un lock per la lettura sul file
            \item Se l'attributo \ttt{l\_type} dell'argomento dato è impostato a \ttt{F\_WRLCK}, verrà acquisito un lock per la scrittura sul file
            \item Se l'attributo \ttt{l\_type} dell'argomento dato è impostato a \ttt{F\_UNLCK}, verrà rilasciato un lock per la lettura sul file (se il lock è esistente)
            \item Viene restituito -1 se un altro processo possiede il lock richiesto
        \end{itemize}

        \item Il comando \ttt{F\_SETLKW(flock)} risulta analogo a \ttt{F\_SETLK(flock)}, con la differenza che il lock richiesto sia \textbf{bloccante}, ossia viene atteso che il lock sul file per venga rilasciato (se presente per il tipo di lock richiesto) 
        \item Il comando \ttt{F\_GETLKW(flock)} testa l'esistenza del lock dato come argomento. Se il lock può essere acquisito, l'attributo \ttt{l\_type} viene impostato su \ttt{F\_UNLCK}.
    \end{itemize}

    \textbf{Esempio:}

    \begin{verbatim}
    void main(){
        struct flock lock;
        memset(&lock, 0, sizeof(lock));
        lock.l_type = F_WRLCK;

        int fd = open ("file", O_WRONLY);
        fcntl (fd, F_SETLKW, &lock);    //creazione lock in scrittura
    }
    \end{verbatim}

    \begin{framedobs}{Lock advisory e mandatory}
        I lock impostati tramite \ttt{fcntl()} sono \textbf{advisory}, ossia richiedono la cooperazione tra processi:
        \begin{itemize}
            \item Ogni processo deve prima effettuare una chiamata \ttt{F\_GETLK}, per poi utilizzare \ttt{F\_SETLK/LKW} solo se il lock è acquisibile
            \item Cercare di leggere o scrivere su un file sul quale un processo detiene un lock \textbf{non ha l'effetto di impedire l'operazione}
        \end{itemize}
        Per impostare un lock di tipo \textbf{mandatory}, ossia in grado di impedire le operazioni, è necessario che il file system supporti quel tipo di lock.
    \end{framedobs}

    Un'altra syscall fondamentale per la \textbf{sincronizzazione tra processi} è la syscall

    \begin{center}
        \ttt{int select(int nfds, fd\_set* readfds, fd\_set* writefds, \\fd\_set* exceptfds, struct timeval* timeout)}
    \end{center}
    fornita dalla libreria \ttt{<sys/select.h>}, dove:
    
    \begin{itemize}
        \item \ttt{nfds} è il numero del file descriptor con il valore più alto aumentato di 1 tra quelli da monitorare
        
        (es: se \ttt{5} è il file descriptor più alto, allora \ttt{nfds = 6})

        \item \ttt{readfds} è l'insieme dei file descriptor per cui si richiede la lettura
        \item \ttt{writefds} è l'insieme dei file descriptor per cui si richiede la scrittura
        \item \ttt{exceptfds} è l'insieme dei file descriptor da controllare per il verificarsi di eccezioni
        \item \ttt{timeout} è il timeout da attendere prima di interrompere la chiamata
    \end{itemize}
    
    Tale syscall permette di \textbf{monitorare uno o più file descriptor}, rimanendo in attesa che almeno uno di essi sia disponibile per effettuare l'operazione richiesta.

    In particolare, la funzione ritorna il \textbf{numero di file descriptor disponibili} per l'operazione richiesta. (viene ritornato 0 in caso di timeout e -1 in caso di errore). Al termine dell'esecuzione, la funzione \textbf{rimuove dagli insiemi} in input tutti i file descriptor non disponibili per l'operazione richiesta.

    A seconda del valore impostato per il parametro \ttt{timeout}, la chiamata assume comportamenti diversi:
    \begin{itemize}
        \item \textbf{Infinito}: la chiamata è bloccante, ossia termina solo quando è disponibile almeno un file descriptor o quando si genera un errore
        \item \textbf{Intervallo definito}: la chiamata ritorna se è disponibile almeno un file descriptor, se scade il timeout e se si genera un errore
        \item \textbf{Zero}: la chiamata non è bloccante e ritorna dopo aver controllato tutti i file descriptor. Solitamente, viene utilizzata per il \textit{polling}.
    \end{itemize}

    Per \textbf{gestire gli insiemi dei file descriptor}, la libreria fornisce le seguenti macro:
    \begin{itemize}
        \item La macro \ttt{void FD\_ZERO(fd\_set* set)} svuota l'insieme dato
        \item La macro \ttt{void FD\_SET(int fd, fd\_set* set)} aggiunge \ttt{fd} all'insieme dato
        \item La macro \ttt{void FD\_CLR(int fd, fd\_set* set)} rimuove \ttt{fd} dall'insieme dato
        \item La macro \ttt{int FD\_ISSET(int fd, fd\_set* set)} verifica se \ttt{fd} sia nell'insieme dato
    \end{itemize}
    
    \quad

    \section{Ambiente di un processo}

    \begin{frameddefn}{Ambiente di un processo}
        L'\textbf{ambiente} di un processo è un insieme variabili accessibili dal processo, dove ogni variabile è definita come una stringa \ttt{KEY=value} (es: \ttt{SHELL:/bin/bash}).
    \end{frameddefn}

    Nel linguaggio C, l'ambiente di un processo è accessibile tramite il parametro opzionale \ttt{char* envp[]} della funzione main. Tale array è terminato dall'elemento \ttt{NULL}.

    \textbf{Esempio:}
    
    \begin{verbatim}
    void main(int argc, char* argv[], char* envp[]){
        int i = 0;
        while(envp[i] != NULL){     //stampa tutte le variabili
            printf("%s\n", envp[i++]);
        }
    }\end{verbatim}

    Tuttavia, l'uso di tale parametro non risulta compatibile con tutti i sistemi. Per tanto, è consigliato l'uso della variabile esterna \ttt{extern char** environ}.

    \textbf{Esempio:}
    
    \begin{verbatim}
    void main(int argc, char* argv[], char* envp[]){
        extern char** environ;

        int i = 0;
        while(environ[i] != NULL){     //stampa tutte le variabili
            printf("%s\n", environ[i++]);
        }
    }
    \end{verbatim}

    Per gestire le variabili di ambiente, la libreria \ttt{<stdlib.h>} fornisce le funzioni:
    \begin{itemize}
        \item \ttt{char* getenv(const char* name)}, la quale ritorna il valore della variabile \ttt{name} (se esiste) 
        \item \ttt{char* setenv(const char* name, const char* value, int overwrite)}, la quale imposta la variabile \ttt{name=value}. Se la variabile \ttt{name} esiste già, essa viene aggiornata solo se \ttt{overwrite $\neq$ 0}
        \item \ttt{int putenv(char* string)}, la quale imposta (o aggiorna) la variabile definita da \ttt{string}
        \item \ttt{int unsetenv(const char* name)}, la quale rimuove la variabile \ttt{name} 
        \item \ttt{int clearenv(void)}, la quale rimuove tutte le variabili
    \end{itemize}

    All'interno della \textbf{shell \ttt{bash}}, le variabili d'ambiente impostate possono essere visualizzate con il comando \ttt{printev} o tramite \ttt{echo \$VAR}. Tutte le variabili di \ttt{bash} vengono ereditate dai comandi eseguiti da \ttt{bash} stesso.

    Inoltre, la shell \ttt{bash} permette di \textbf{eseguire} un comando con delle variabili d'ambiente aggiuntive ponendo tali variabili \textbf{prima del comando}:
    \[\ttt{VAR1=value1 VAR2=value2 ... cmd [options]}\]
    
    \newpage

    \section{Creazione di un processo}

    La \textbf{creazione di un processo}, sostanzialmente, consiste nella \textbf{duplicazione} di un processo chiamante (ossia il \textbf{padre}), dove viene generata una copia identica (ossia il \textbf{figlio}) di quest'ultimo.
    
    In questo modo, vanno a crearsi una serie di relazioni padre-figlio, dando vita ad un vero e proprio \textbf{albero geneaologico dei processi}. Alla radice di tale albero vi è il processo \ttt{init}, avente PID 1. Difatti, tramite esso vengono creati tutti i processi di base del sistema operativo, i quali a loro volta creeranno vari processi.

    Tramite il comando \ttt{pstree pid} è possibile visualizzare l'albero dei discendenti del processo avente PID \ttt{pid}
    
    \begin{center}
        \includegraphics[scale=0.75]{images/pstree.png}
    \end{center}

    \begin{frameddefn}{Exit status}
        Definiamo come \textbf{exit status} di un processo il valore ritornato dopo la sua chiusura al suo processo padre.
        
        Nel linguaggio C, l'exit status di un processo corrisponde al \textbf{valore ritornato dalla funzione \ttt{main()}}
    \end{frameddefn}

    \newpage

    \textbf{Esempio:}

    \begin{verbatim}
    int main(){
        ...
        return 0;   //0 è l'exit status
    }
    \end{verbatim}

    \begin{framedobs}{}
        Solitamente, se un processo è stato \textbf{eseguito con successo}, viene restituito il valore 0 come \textbf{exit status}.

        Se invece si è \textbf{verificato un problema}, viene restituito un valore maggiore di 0, dove tale valore potrebbe assumere un significato specifico scelto dal programmatore
        
        (es: 1 = errore generico, 2 = errore di tipo 1, 3 = errore di tipo 2, ...)
    \end{framedobs}

    Ogni processo della gerarchia fa \textbf{riferimento al proprio padre}:
    \begin{itemize}
        \item Quando un figlio termina o muore, il suo \textbf{exit status} viene ritornato al genitore
        \item Quando un figlio viene creato, esso eredita il codice e parte dello stato del genitore
        \begin{center}
            \begin{tabular}{l|l}
                \textbf{Attributi ereditati} & \textbf{Attributi non ereditati} \\
                \hline
                RUID, RGID, EUID, EGID & PID, PPID\\
                Working e Root directory & Timer\\
                Ambiente del processo & Record e Memory lock\\
                File descriptors & Contatori delle risorse\\
                Terminale di controllo & Coda dei segnali\\
                Memoria condivisa & Aree di memoria\\
                Codice del programma &
            \end{tabular}
        \end{center}
    \end{itemize}

    \begin{frameddefn}{Processo orfano}
        Un processo viene detto \textbf{orfano} se il suo processo padre è terminato prima di esso.

        Tutti i processi orfani vengono "adottati" da \ttt{init}, il quale, solitamente, procede col il terminarli direttamente
    \end{frameddefn}
    
    Durante la sua vita, un processo attraversa obbligatoriamente le seguenti tre fasi:
    \begin{enumerate}
        \item \textbf{Running}: vengono eseguite le due istruzioni, per poi terminare ed inviare il proprio exit status al padre
        \item \textbf{Zombie}: rimane in stato Zombie (Z) (sezione \ref{statuses}) fino a quando il genitore non riceve il suo exit status (difatti, il PCB di un processo zombie viene conservato nel kernel per tale scopo)
        \item \textbf{Terminato}: il genitore ha ricevuto l'exit status e il PCB viene eliminato 
    \end{enumerate}

    Per \textbf{duplicare un processo}, la libreria \ttt{<unistd.h>} fornisce la syscall \ttt{pid\_t fork()}. Ogni volta tale syscall viene chiamata, essa viene \textbf{eseguita una volta}, ma \textbf{ritorna due volte}:
    \begin{itemize}
        \item Al processo chiamante (ossia il padre) viene ritornato il PID del processo figlio creato
        \item Al processo figlio viene ritornato il PID 0
    \end{itemize}

    In caso di errore, invece, al processo chiamante viene ritornato -1 e il figlio non viene creato.

    \textbf{Esempio:}

    \begin{verbatim}
    #include <unistd.h>

    int main(){
        ...
        pid\_t pid = fork();

        /*
            Nel padre, la variabile pid conterrà il PID del figlio
            Nel figlio, la variabile pid conterrà il PID 0
        */

        if(pid > 0){    //viene eseguito dal padre
            ...
        }
        else if(pid == 0){  //viene eseguito dal figlio
            ...
        }
        else{   //viene eseguito in caso di errore
            ...
        }
    }
    \end{verbatim}

    Poiché la syscall \textbf{fork()} crea \textbf{due processi con lo stesso codice}, nel caso in cui si voglia farsì che il processo figlio vada ad eseguire del \textbf{codice diverso dal padre}, è necessario \textbf{"rimpiazzare" il processo figlio}.

    La libreria \ttt{<unistd.h>} fornisce la syscall
    \[\ttt{int execve(const char* path, const char* argv[], const char* envp[]);}\]
    dove:
    \begin{itemize}
        \item \ttt{path} è il path assoluto dell'eseguibile da eseguire
        \item \ttt{argv[]} contiene gli argomenti in input del comando da eseguire. Il primo elemento dell'array deve essere il nome dell'eseguibile da eseguire (ossia la parte finale di \ttt{path}) e l'ultimo elemento deve essere \ttt{NULL}
        \item \ttt{envp[]} contiene l'ambiente di processo della nuova immagine
        \item Viene sostituita parte dell'immagine del processo con quella dell'eseguibile \ttt{path}. In particolare, vengono sostituite le zone di memoria \ttt{text} (all'interno della quale viene inserito il codice del programma da eseguire), \ttt{bss} e \ttt{stack} e i seguenti attributi:
        
        \begin{center}
            \begin{tabular}{l|l}
                \textbf{Attributi mantenuti} & \textbf{Attributi non mantenuti} \\
                \hline
                PID, PPID, RUID, RGID & EUID, EGID\\
                Session ID & Timer\\
                Terminale di controllo & Memory mappings\\
                Working e Root directory & Memoria condivisa\\
                File lock & Memory lock\\
                File descriptor\\
                Umask\\
                Maschera dei segnali\\
                Segnali in attesa
            \end{tabular}
        \end{center}
    \end{itemize}

    \textbf{Esempio:}

    \begin{verbatim}
    #include <unistd.h>

    int main(){
        pid\_t pid = fork();

        if(pid == 0){
            char* argv[] = {"ls", "-la", NULL};
            execve("/usr/bin/ls", argv, NULL);
        }
    }
    \end{verbatim}

    Oltre alla syscall \ttt{execve()}, la libreria \ttt{<unistd.h>} fornisce le seguenti funzioni di libreria, le quali eseguono al loro interno la \ttt{execve()} stessa:
    \begin{itemize}
        \item \ttt{int execl(const char* path, const char* arg, ...)}
        \item \ttt{int execlp(const char* path, const char* arg, ..., const char* envp[])}
        \item \ttt{int execle(const char* path, const char* arg, ..., const char* envp[])}
        \item \ttt{int execv(const char* path, const char* argv[])}
        \item \ttt{int execvp(const char* path, const char* argv[])}
        \item \ttt{int execvpe(const char* path, const char* argv[], const char* envp[])}
    \end{itemize}

    dove:
    \begin{itemize}
        \item Le funzioni con \ttt{l} nel loro suffisso permettono di specificare gli argomenti come una "lista" di stringhe opzionali date in input (\ttt{execl()}, \ttt{execlp()} e \ttt{execle()}).
        Il primo elemento della "lista" deve essere il nome dell'eseguibile da eseguire (ossia la parte finale di \ttt{path}) e l'ultimo elemento deve essere \ttt{NULL}
        \item Le funzioni con \ttt{p} nel loro suffisso interpretano \ttt{path} come un path relativo invece che assoluto (\ttt{execlp()}, \ttt{execvp()} e \ttt{execvpe()})
        \item Le funzioni con \ttt{e} nel loro suffisso permettono di specificare l'ambiente di processo della nuova immagine (\ttt{execle()} e \ttt{execvpe()})
    \end{itemize}

    \begin{framedobs}{}
        Utilizzare una qualsiasi delle funzioni della famiglia \ttt{exec*()} (inclusa anche la syscall), \textbf{rimpiazza completamente il text segment del processo}.

        Per tanto, tutte le istruzioni successive alla chiamata \underline{non verranno eseguite}.
    \end{framedobs}
    \quad

    \section{Terminazione di un processo}

    Per \textbf{gestire la chiusura} di un processo, ossia eseguire delle azioni aggiuntive oltre alla restituzione dell'exit status al padre, è possibile utilizzare:
    \begin{itemize}
        \item La syscall \ttt{\_exit(int status)}, fornita da \ttt{<unistd.h>}, esegue in successione le seguenti operazioni:
        \begin{enumerate}
            \item Chiude tutti i file descriptor del processo chiamante
            \item Termina immediatamente il processo chiamante
            \item I figli non ancora terminati del processo chiamante vengono ereditati da \ttt{init}
            \item Invia il segnale \ttt{SIGCHLD} al processo padre
            \item Ritorna  \ttt{status \& 0x00FF} come exit status
        \end{enumerate}
        \item La funzione \ttt{void exit(int status)}, fornita da \ttt{<stdlib.h>}, esegue in successione le seguenti operazioni:
        \begin{enumerate}
            \item Invoca tutti gli \textbf{handler} registrati tramite le seguenti funzioni (fornite sempre da \ttt{<stdlib.h>}):
            
            \begin{itemize}
                \item \ttt{int atexit(void (*func)(void))}
                \item \ttt{int on\_exit(void (*func)(int, void*), void* arg)}
            \end{itemize}
            \item Svuota gli stream standard I/O attivi e li chiude (\textbf{clean-up})
            \item Chiama la syscall \ttt{\_exit(status)} o \ttt{\_Exit(status)} (\ttt{\_Exit()} è una syscall esattamente equivalente ad \ttt{\_exit()}, con l'unica differenza di essere fornita dalla libreria \ttt{<stdlib.h>})
        \end{enumerate}
    \end{itemize}

    \begin{itemize}
        \item La funzione \ttt{void abort()}, la quale invia un segnale \ttt{SIGABRT} al processo padre, per poi terminare immediatamente il processo chiamante
    \end{itemize}
        
    \begin{framedobs}{}
        Per maggiore portabilità, libreria \ttt{<stdlib.h>} fornisce due macro \ttt{EXIT\_SUCCESS} e \ttt{EXIT\_FAILURE} come valori consigliati per il parametro \ttt{status} della funzione \ttt{exit()}, ma anche dei valori personalizzati possono essere utilizzati.
    \end{framedobs}

    \begin{framedobs}{}
        Il segnale \ttt{SIGABRT} può essere intercettato e gestito, ma la funzione \ttt{abort()} \textbf{terminerà comunque il processo}
    \end{framedobs}

    \begin{center}
        \includegraphics[scale=0.5]{images/exit.png}
    \end{center}

    Ogni processo padre può \textbf{attendere cambiamenti di stato} di un suo processo figlio. Un cambiamento di stato avviene quando:
    \begin{itemize}
        \item Il processo figlio è terminato
        \item Il processo figlio è stato arrestato da un segnale
        \item Il processo figlio è stato ripristinato da un segnale
    \end{itemize}

    Se nel momento in cui un processo padre rimane in attesa del processo figlio quest'ultimo è \textbf{terminato}, il sistema \textbf{rilascia le risorse associate al figlio} e le sue informazioni (incluso l'exit status) vengono restituite al processo padre. In tal modo, il figlio uscirà dallo stato Zombie (Z) e il suo PCB verrà eliminato.

    Inoltre, se lo stato del figlio è già precedentemente cambiato, la chiamata ritornerà immediatamente. Altrimenti, il processo padre rimarrà \textbf{sospeso} finché il figlil non cambierà stato o finché la chiamata non verrà interrotta.

    Le librerie \ttt{<sys/types.h>} e \ttt{<sys/wait.h>} forniscono le seguenti due syscall per effettuare l'attesa di un figlio:
    \begin{itemize}
        \item La syscall \ttt{pid\_t wait(int* status)} sospende l'esecuzione del processo chiamante fino a quando uno dei suoi figli termina.
        
        Se la chiamata va a buon fine, viene restituito il PID del figlio terminato, altrimenti viene restituito -1

        \item La syscall \ttt{pid\_t waitpid(pid\_t pid, int* status, int options)} sospende l'esecuzione del processo chiamante fino a quando il figlio specificato da \ttt{pid} termina:
        \begin{itemize}
            \item Se \ttt{pid < -1}, viene atteso un qualunque processo figlio il cui GID sia $\abs{pid}$ (ossia il valore assoluto di \ttt{pid})
            \item Se \ttt{pid = -1}, viene atteso un qualsiasi processo figlio (come per \ttt{wait()})
            \item Se \ttt{pid = 0}, viene atteso un qualunque processo figlio il cui GID sia uguale al GID del processo chiamante
            \item Se \ttt{pid > 0}, viene atteso il figlio con PID uguale a \ttt{pid}
        \end{itemize}

        Il parametro \ttt{options} specifica il comportamento della chiamata ed è il risultato di un bit-wise OR delle seguenti macro:
        \begin{itemize}
            \item \ttt{WNHOHANG}: la chiamata ritorna subito se il figlio richiesto non ha eseguito \ttt{exit()}
            \item \ttt{WUNTRACED}: la chiamata ritorna anche se il figlio richiesto è stato arrestato
            \item \ttt{WCONTINUED}: la chiamata ritorna anche se il figlio richiesto è stato arrestato
        \end{itemize}

        Se \ttt{options = 0}, il processo chiamante rimane in attesa (comportamento di default).

        Inoltre, se la chiamata va a buon fine, viene restituito il PID del figlio terminato, altrimenti viene restituito -1
    \end{itemize}

    Entrambe le due syscall, inoltre, memorizzano in \ttt{status}, a meno che \ttt{status = NULL}, il valore dello \textbf{stato del processo figlio} (\underline{non il suo exit status}).
    
    Dando il valore di \ttt{status} in input alle seguenti macro, è possibile ottenere le informazioni inerenti al processo figlio:
    \begin{itemize}
        \item \ttt{WIFEXITED(status)}: restituisce \ttt{true} se il figlio è terminato senza problemi
        \item \ttt{WEXITSTATUS(status)}: restituisce l'exit status del figlio
        \item \ttt{WIFSIGNALED(status)}: restituisce \ttt{true} se il figlio è terminato a seguito della ricezione di un segnale
        \item \ttt{WTERMSIG(status)}: restituisce il numero del segnale che ha terminato il figlio
        \item \ttt{WCOREDUMP(status)}: restituisce \ttt{true} se la terminazione del figlio ha generato un core dump
        \item \ttt{WIFSTOPPED(status)}: restituisce \ttt{true} se il figlio è entrato in stato Stopped (T) a seguito della ricezione di un segnale
        \item \ttt{WSTOPSIG(status)}: restituisce il numero del segnale che ha messo il figlio in stato Stopped (T)
        \item \ttt{WIFCONTINUED(status)}: restituisce \ttt{true} se il processo ha ripreso l'esecuzione a seguito della ricezione di un segnale SIGCONT
    \end{itemize}


    Di seguito, viene riportato un esempio di \textbf{corretto uso} delle varie syscall relative alla creazione e terminazione di un figlio.

    \begin{verbatim}
    void main(){
        pid_t pid = fork();

        if(pid > 0){    // processo padre
            int status;
            int result = waitpid(pid, &status, 0);  //bloccante

            if(result == -1){
                perror("waitpid() call failed");
            }
            else if (!WIFEXITED(status)){
                perror("Child exit failed");
            }
            else{
                int exit_status = WEXITSTATUS(status);
                printf("Child terminated with status %d", exit_status);
            }
        }
        else if(pid == 0){  // processo figlio
            ...

            if(...){
                exit(EXIT_SUCCESS);
            }
            else{
                exit(EXIT_FAILED);
            }
        }
        else{
            perror("fork() failed");
        }
    }
    \end{verbatim}

    \quad

    \section{Gestione ID dei processi}

    Le librerie \ttt{<sys/types.h>} e \ttt{<unistd.h>} forniscono delle syscall in grado di ottenere e modificare gli ID del processo chiamante:
    \begin{itemize}
        \item La syscall \ttt{pid\_t getpid()} ritorna il PID del processo chiamante
        \item La syscall \ttt{pid\_t getppid()} ritorna il PPID del processo chiamante
        \item La syscall \ttt{uid\_t getuid()} ritorna il RUID del processo chiamante
        \item La syscall \ttt{uid\_t geteuid()} ritorna l'EUID del processo chiamante
        
        \item La syscall \ttt{int setuid(uid\_t uid)} imposta a \ttt{uid} l'EUID del processo chiamante.
        
        Se il processo possiede sufficienti privilegi, anche il RUID e il SUID verranno impostati a \ttt{uid}
        \item La syscall \ttt{int seteuid(uid\_t uid)} imposta a \ttt{uid} l'EUID del processo chiamante
        
        \item La syscall \ttt{int setgid(gid\_t gid)} imposta a \ttt{gid} l'EGID del processo chiamante.
        
        Se il processo possiede sufficienti privilegi, anche il RGID e il SGID verranno impostati a \ttt{gid}
        \item La syscall \ttt{int setegid(gid\_t gid)} imposta a \ttt{gid} l'EGID del processo chiamante
    \end{itemize}

    \quad

    \section{Gestione dei segnali}

    Come già discusso, i \textbf{segnali} sono \textbf{eventi asincroni}, ossia occorrono ad un tempo non predeterminato, che possono essere inviati e ricevuti da un processo. 

    Ogni processo può \textbf{gestire un segnale} associando ad essa una delle seguenti tre azioni:
    \begin{itemize}
        \item \textbf{Eseguire} l'azione di default associata al segnale
        \item \textbf{Ignorare} il segnale e proseguire l'esecuzione (a meno che il segnale non sia SIGKILL o SIGSTOP)
        \item \textbf{Catturare} il segnale e richiedere al kernel che venga eseguita una funzione definita dal programmatore stesso (a meno che il segnale non sia SIGKILL o SIGSTOP)
    \end{itemize}

    \begin{frameddefn}{Maschera dei segnali}
        Definiamo come \textbf{maschera dei segnali di un processo} l'insieme dei \textbf{segnali bloccati} all'interno del processo stesso.

        I segnali bloccati \underline{non vengono scartati}, ma vengono invece categorizzati come \textbf{pending signal (segnale in arrivo)} e vengono consegnati al processo quando essi vengono sbloccati.
    \end{frameddefn}

    \begin{framedobs}{}
        I segnali SIGKILL e SIGSTOP non possono essere inseriti all'interno della maschera dei segnali di un processo
    \end{framedobs}
    
    \begin{framedobs}{}
        Ad eccezione del segnale SIGCHILD, le istanze multiple dello stesso segnale non vegnono considerate dalla maschera dei segnali.

        Per tanto, se un segnale è bloccato e il processo riceve più volte un segnale, verrà considerato \textbf{solo un pending signal per tale segnale}.
    \end{framedobs}

    La libreria \ttt{<signal.h>} fornisce la funzione
    \[\ttt{int sigprocmask(int how, const sigset\_t* set, sigset\_t* oldset)}\]
    in grado di ottenere/impostare la \textbf{maschera dei segnali bloccati}:

    \begin{itemize}
        \item Il parametro \ttt{set} è l'insieme dei segnali per cui applicare/rimuovere la maschera
        \item Il parametro \ttt{how} può essere impostato su tre valori:
        \begin{itemize}
            \item \ttt{SIG\_BLOCK}: blocca i segnali definiti nel parametro \ttt{set}
            \item \ttt{SIG\_UNBLOCK}: sblocca i segnali definiti nel parametro \ttt{set}
            \item \ttt{SIG\_SETMASK}: imposta la maschera uguale a \ttt{set}, bloccando tutti i segnali definiti in essa e sbloccando tutti gli altri
        \end{itemize}
        \item L'insieme puntato da \ttt{old\_set} viene impostato alla precedente maschera
    \end{itemize}

    \begin{framedobs}{}
        La maschera della funzione \ttt{sigprocmask()} viene applicata \textbf{solo sul processo} e non sui suoi thread, poiché ognuno di essi possiede una propria maschera che va modificata all'interno del thread stesso
    \end{framedobs}

    \begin{frameddefn}{Signal handler}
        Definiamo come \textbf{signal handler} la funzione associata ad un segnale che viene eseguita al posto del normale flusso del processo dopo la ricezione del segnale stesso, per poi riprendere l'esecuzione del processo dal punto in cui è stato interrotto (a meno che l'handler non termini il processo).
    \end{frameddefn}
    
    Ogni segnale possiede un \textbf{default handler}, corrispondente all'azione di default del segnale stesso, ma può essere sovrascritto dal programmatore (a meno che il segnale non sia SIGKILL o SIGSTOP).
        
    \newpage
    
    Per gestire i signal handler, la libreria \ttt{<signal.h>} fornisce:
    \begin{itemize}
        \item Le due macro \ttt{SIG\_IGN} e \ttt{SIG\_DFL} definiscono due signal handler:
        \begin{itemize}
            \item \ttt{SIG\_IGN} permette di ignorare il segnale
            \item \ttt{SIG\_DFL} assegna il default handler del segnale
        \end{itemize}
        
        \item La syscall \ttt{sighandler\_t signal(int signum, sighandler\_t handler)}, la quale imposta il gestore del segnale \ttt{signum} alla funzione \ttt{handler}. Il parametro \ttt{handler} può essere impostato anche sulle macro \ttt{SIG\_IGN} e \ttt{SIG\_DFL}.

        \textbf{ATTENZIONE:} tale syscall è \underline{deprecata}, dunque l'uso è sconsigliato

        \item La syscall \ttt{int sigaction(int signum, const struct
        sigaction* act, struct sigaction* oldact)} permette di impostare le informazioni relative alla gestione del segnale \ttt{signum} allo struct puntato da \ttt{act}, dove

\begin{verbatim}
struct sigaction {
    void (*sa_handler)(int);    /*Puntatore alla funzione signal
                                handler. Può essere SIG_IGN, SIG_DFL
                                o un puntatore a funzione */

    void (*sa_sigaction)(int, siginfo_t*, void*); /*Alternativo
                                                    a sa_handler*/

    sigset_t sa_mask;           /*Specifica la maschera dei segnali
                                che dovrebbero essere bloccati
                                durante l'esecuzione dell'handler*/

    int sa_flags;               /*Flags per modificare il
                                comportamento del segnale*/

    void (*sa_restorer)();      /*Obsoleto*/
};
\end{verbatim}
    \end{itemize}

    La libreria \ttt{<signal.h>} fornisce inoltre le seguenti syscall per la gestione dei segnali:
    \begin{itemize}
        \item La syscall \ttt{int kill(pid\_t pid, int sig)}, analoga al comando \ttt{kill}
        \item La syscall \ttt{unsigned int alarm(unsigned int seconds)} invia un SIGALARM dopo \ttt{seconds} secondi
        \item La syscall \ttt{int pause()}, la quale blocca il processo (o thread) chiamante finchè non viene ricevuto un segnale
        \item La syscall \ttt{int sigpending(sigset\_t* set)} imposta l'insieme puntato da \ttt{set} all'insieme dei pending signal
        \item La syscall \ttt{int sigsuspend(const sigset\_t* mask)} sospende il processo che invoca tale syscall e rimpiazza la sua maschera dei segnali con \ttt{mask}. Il processo rimane sospeso finchè non arriva un segnale per cui è definito un handler o finchè non arriva un segnale di terminazione
    \end{itemize}
    

    \chapter{Inter Process Communication (IPC)}

    \section{Named pipe e Unnamed pipe}

    I sistemi Unix-like forniscono funzionalità di \textbf{inter process communication (IPC)}, ossia modalità di scambio di messaggi e/o dati tra due processi, tramite la \textbf{scrittura e lettura sequenziale} seguendo il principio FIFO (First In, First Out), come se i dati scritti venissero inseriti all'interno di una "coda", venendo estratti man mano con la loro lettura.

    \begin{frameddefn}{Named pipe}
        Una \textbf{named Pipe} (anche chiamata direttamente \textbf{FIFO}) è un \textbf{file speciale} che può essere utilizzato da più processi e in cui le operazioni di scrittura e lettura sono \textbf{full-duplex} (ossia possono avvenire in contemporanea).

    \end{frameddefn}

    Una volta che la named pipe è stata creata, essa può essere utilizzata come un \textbf{qualsiasi altro file}. In particolare, essa può essere acceduta in lettura e/o scrittura da \textbf{qualsiasi processo} avente i permessi richiesti. 
    
    \begin{framedobs}{}
        Le operazioni di lettura e scrittura devono essere \textbf{simultanee}, poiché un processo che apre la FIFO in lettura rimane \textbf{bloccato} finchè un altro processo non aprirà la FIFO in scrittura (e viceversa).
    \end{framedobs}

    Per creare una \textbf{named pipe}, le librerie \ttt{<sys/types.h>} e \ttt{<sys/stat.h>} forniscono la funzione 
    \[\ttt{int mkfifo(const char* pathname,
    mode\_t mode)}\]
    la quale crea una named pipe con nome \ttt{pathname} e permessi impostati su \ttt{mode}. Inoltre, esiste anche un comando \ttt{mkfifo} del tutto analogo alla funzione.

    \begin{frameddefn}{Unnamed pipe}
        Un'\textbf{unnamed Pipe} (anche chiamata direttamente \textbf{pipe}) è una \textbf{struttura dati speciale in memoria} in cui le operazioni di scrittura e lettura sono \textbf{half-duplex} (ossia non possono avvenire in contemporanea).
    \end{frameddefn}

    Una unnamed pipe può essere creata tramite la syscall \ttt{int pipe(int fd[2])} (fornita da \ttt{<unistd.h>}), la quale \textbf{crea due file descriptor} per poter leggere e scrivere sulla pipe:
    \begin{itemize}
        \item Dopo la chiamata, \ttt{fd[0]} conterrà il numero associato al file descriptor per la \textbf{lettura} dalla pipe
        \item Dopo la chiamata, \ttt{fd[1]} conterrà il numero associato al file descriptor per la \textbf{scrittura} sulla pipe
    \end{itemize}

    In particolare, notiamo che dati scritti su una unnamed pipe sono \textbf{bufferizzati dal kernel} finchè non vengono letti:

    \begin{center}
        \includegraphics[scale=0.5]{images/pipe.png}
    \end{center}


    \begin{framedobs}{}
        Le unnamed pipe risultano principalmente utili nel caso di IPC tra \textbf{processi con un antenato in comune}.
    \end{framedobs}

    \textbf{Esempio:}
    \begin{itemize}
        \item Supponiamo che il processo A crei la pipe \ttt{p[]}
        \item Supponiamo inoltre che il processo A esegua \ttt{fork()} creando il processo B, il quale erediterà i file descriptor della pipe \ttt{p[]}
        \item Se A volesse inviare dei dati a B, sarà sufficiente che esso esegua la syscall \ttt{write()} col file descriptor \ttt{p[1]}.
        \item Successivamente, per far si che il processo B riceva tali dati, sarà sufficiente che esso esegua la syscall \ttt{read()} col file descriptor \ttt{p[0]}.
        
        \newpage
        \item Traducendo il tutto in codice, abbiamo che:

\begin{verbatim}

void main(){       
    int fd[2];
    pipe(fd);     //apertura della pipe e creazione fd
    
    int pid = fork();
    if(pid > 0){
        char to_send[13] = "Hello World!";
        
        write(fd[1], to_send, 13); //il padre scrive sulla pipe
    }
    else if(pid == 0){
        char to_read[13];
        read(fd[0], to_read, 13); //lettura dalla pipe
    }
    else{...}

    close(fd[0]);   //chiusura lettura pipe per entrambi i processi
    close(fd[1]);   //chiusura scrittura pipe per entrambi i processi
}
\end{verbatim}

    \item Volendo estendere l'esempio, qualsiasi altro processo discendente da A (dunque creato da A stesso, da un figlio di A, da un figlio di un figlio di A, ...) potrà comunicare utilizzando la stessa pipe
    
    \item Ad esempio, notiamo che:
        \begin{itemize}
            \item Se A creasse un altro processo C, tutti e tre i processi potrebbero comunicare tra di loro con la stessa pipe
            \item Se B creasse un altro processo D, tutti e quattro i processi potrebbero comunicare tra di loro con la stessa pipe
        \end{itemize}
    \end{itemize} 

    \begin{framedobs}{}
        Il buffer di un'unnamed pipe possiede una \textbf{dimensione massima}:
        \begin{itemize}
            \item Se un processo legge N byte da una pipe \textbf{vuota}, esso rimarrà \textbf{bloccato} finchè non verranno scritti N byte sulla pipe
            \item Se un processo scrive M byte su una pipe \textbf{piena}, esso rimarrà \textbf{bloccato} finchè non verranno letti M byte dalla pipe
        \end{itemize}
    \end{framedobs}

    \begin{framedobs}{}
        La lettura e la chiusura di una pipe vengono \textbf{chiuse} solo quando \textbf{tutti i processi} che hanno accesso alla pipe chiudono i propri file descriptor.

        Per tanto, se tutti i processi hanno chiuso il file descriptor di lettura, la syscall \ttt{read()} ritornerà 0. Se invece tutti i processi hanno chiuso il file descriptor di scrittura, la syscall \ttt{write()} ritornerà -1 e verrà inviato un SIGPIPE al processo chiamante.
    \end{framedobs}

    Essendo le unnamed pipe \textbf{half-duplex}, i dati potrebbero \textbf{collidere} nel caso in cui entrambi i processi tentino di scrivere in contemporanea o leggere in contemporanea.

    Per tanto, per scambiare dati bidirezionalmente tra due processi è consigliato \underline{creare due pipe}:
    \begin{itemize}
        \item La pipe \ttt{pipe1[]} verrà utilizzata in lettura dal processo figlio e in scrittura dal processo padre.
        
        \item La pipe \ttt{pipe2[]} verrà utilizzata in lettura dal processo padre e in scrittura dal processo figlio
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.4]{images/pipe_2.png}
    \end{center}

    Inoltre, al fine di prevenire collisioni, è consigliato \underline{chiudere immediatamente} i file descriptor \textbf{inutilizzati}:
    \begin{itemize}
        \item Il processo padre non necessità la lettura sulla pipe \ttt{pipe1} e la scrittura sulla pipe \ttt{pipe2}, per tanto chiuderà \ttt{pipe1[0]} e \ttt{pipe2[1]} 
        \item Il processo figlio non necessità la scrittura sulla pipe \ttt{pipe1} e la lettura sulla pipe \ttt{pipe2}, per tanto chiuderà \ttt{pipe1[1]} e \ttt{pipe2[0]} 
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.4]{images/pipe_3.png}
    \end{center}

    \textbf{Esempio:}
    
    \begin{verbatim}
    void main(){       
        int fd[2];
        pipe(fd);     //apertura della pipe e creazione fd
        
        int pid = fork();
        if(pid > 0){
            close(fd[0]); //il padre non ha bisogno di leggere

            char to_send[13] = "Hello World!";

            write(fd[1], to_send, 13); //il padre scrive sulla pipe

            close(fd[1]); //il padre chiude la scrittura
        }
        else if(pid == 0){
            close(fd[1]); //il figlio non ha bisogno di scrivere
            
            char to_read[13];

            read(fd[0], to_read, 13); //lettura dalla pipe

            close(fd[0]); //il figlio chiude la lettura
        }
        else{...}
    }
    \end{verbatim}

    \quad

    \section{Socket}

    Un \textbf{socket} è un'astrazione software che consente la comunicazione tra processi \textbf{residenti anche su macchine diverse}. In particolare, l'IPC tramite socket è basata sul \textbf{paradigma client-server}:
    \begin{itemize}
        \item Il primo processo assume il ruolo di \textbf{server}, mentre tutti gli altri processi assumono il ruolo di \textbf{client}
        \item \textbf{Server}:
        \begin{itemize}
            \item Definisce il socket
            \item Il \textbf{riferimento} a tale socket (ossia il nome del file o l'indirizzo di rete) è noto ai client
            \item Il server \textbf{accetta connessioni} sul socket da parte di uno o più client, ricavando un \textbf{file descriptor full-duplex} sulla connessione
        \end{itemize}
        \item \textbf{Client}:
        \begin{itemize}
            \item Definisce il socket
            \item Richiede al socket del server di stabilire una connessione, ricavando un \textbf{file descriptor full-duplex} su di essa
        \end{itemize}
    \end{itemize}

    In particolare, le operazioni svolte all'interno di una comunicazione via socket sono riassumibili in:
    \begin{enumerate}
        \item \textbf{Creazione} del socket per il processo server e per il processo client
        \item \textbf{Associazione (bind)} di un nome al socket del processo server
        \item \textbf{Ascolto (listen)} sul socket da parte del processo server
        \item \textbf{Richiesta di connessione (connect)} al socket del processo server da parte del processo client
        \item \textbf{Accettazione (accept)} della connessione in arrivo sul socket del processo server
        \item \textbf{Scambio di dati} tramite operazioni di lettura e scrittura dai due socket
        \item \textbf{Chiusura (close)} dei due socket quando lo scambio di dati è terminato
    \end{enumerate}

    \begin{center}
        \includegraphics[scale=0.475]{images/socket.png}
    \end{center}

    \begin{framedobs}{}
        Durante la creazione del socket, viene generato un \textbf{socket descriptor}, ossia il file descriptor full-duplex associato al socket.
        
        Per tanto, le operazioni di lettura e scrittura sul socket vengono effettuate tramite le syscall \ttt{read()} e \ttt{write()}
    \end{framedobs}
    
    \begin{framedobs}{}
        La scrittura o lettura su un \textbf{socket chiuso} genera un segnale SIGPIPE
    \end{framedobs}

    \begin{framedprop}{Tipologie di socket}
        Esistono varie tipologie di socket, ognuna dettata dal valore impostato per i seguenti parametri:
        \begin{itemize}
            \item Il \textbf{dominio}, ossia la modalità di collegamento:
            \begin{itemize}
                \item \ttt{AF\_LOCAL} (o \ttt{AF\_UNIX}): il client e il server risiedono sulla \textbf{stessa macchina}
                \item \ttt{AF\_INET}: il client e il server comunicano in rete tramite il \textbf{protocollo IPv4}
                \item \ttt{AF\_INET6}: il client e il server comunicano in rete tramite il \textbf{protocollo IPv6}
            \end{itemize}

            \item Il \textbf{tipo}, ossia la semantica del collegamento:
            \begin{itemize}
                \item \ttt{SOCK\_STREAM}: il flusso di dati è \textbf{bidirezionale, affidabile e basato su connessione} (TCP socket). Supporta anche notifiche asincrone (out of bound)
                \item \ttt{SOCK\_DGRAM}: il flusso di dati è \textbf{bidirezionale, non affidabile e senza connessione} (UDP socket). Non richiede l'operazione \ttt{accept} da parte del server.
                \item \ttt{SOCK\_RAW}: non viene fornita alcuna proprietà (raw socket)
            \end{itemize}
        \end{itemize}
    \end{framedprop}

    \begin{frameddefn}{Unnamed socket e named socket}
        Un \textbf{unnamed socket} è una struttura dati che rappresenta un socket ma al quale non è associato alcun nome o indirizzo.

        Per tanto, eseguendo l'operazione \textit{bind} su un unnamed socket, tale socket diviene un \textbf{named socket}
    \end{frameddefn}

    Per effettuare le varie operazioni sui socket, le librerie \ttt{<sys/types.h>} e \ttt{<sys/socket.h>} forniscono:
    \begin{itemize}
        \item La syscall \ttt{int socket(int domain, int type, int protocol)}, la quale definisce un socket, ritornando il suo socket descriptor.
        
        Il parametro \ttt{protocol} specifica il \textbf{protocollo} da utilizzare nella comunicazione. Se impostato a \ttt{0}, verrà utilizzato il protocollo di default associato al tipo di socket (es: TCP per \ttt{SOCK\_STREAM} e UDP per \ttt{SOCK\_DGRAM})
        
        \item La syscall \ttt{int bind(int sockfd, const struct sockaddr* addr, socklen\_t \\addrlen)}, la quale permette di associare il socket definito all'indirizzo IP o il nome definito da \ttt{addr}.
        
        Lo struct \ttt{sockaddr} del parametro \ttt{addr} può essere di due tipi:
        \begin{itemize}
            \item \ttt{struct socaddr\_un} se il tipo del socket è \ttt{AF\_LOCAL}
            \item \ttt{struct socaddr\_in} se il tipo del socket è \ttt{AF\_INET} o \ttt{AF\_INET6}
        \end{itemize}

    \begin{verbatim}
    struct sockaddr_in {
        sa_family_t sin_family; /* address family: AF_INET */
        in_port_t sin_port; /* port in network format*/
        struct in_addr sin_addr; /* internet address */
    };

    struct in_addr {
        uint32_t s_addr; /* address in network format */
    };
    \end{verbatim}
        
        Il parametro \ttt{addrlen} specifica la dimensione dello struct \ttt{sockaddr} utilizzato

        \item La funzione \ttt{uint32\_t htonl(uint32\_t hostlong)} per convertire l'unsigned int \ttt{hostlong} in formato network (vedi sopra gli struct \ttt{in\_addr} e \ttt{in\_port})
        \item La funzione \ttt{int inet\_aton(const char* cp, struct in\_addr* inp)} per convertire l'indirizzo IPv4 \ttt{cp} (dunque \ttt{cp = "X.Y.Z.W"}) in formato network
        \item La funzione \ttt{struct hostent* gethostbyname(const char* name)} per convertire in formato network il dominio o indirizzo IPv4 contenuto in \ttt{name}
        \item 
        \item La syscall \ttt{int listen(int sockfd, int
        backlog)} marca il socket \ttt{sockfd} come \textit{passive}, ossia pronto a ricevere richieste di connessione da accettare. Il parametro \ttt{backlog} indica la lunghezza della coda delle richieste in attesa di essere accettate. Restituisce 0 in caso di successo, -1 altrimenti.

        \item La syscall \ttt{int accept(int sockfd,
        struct sockaddr* addr, socklen\_t* \\addrlen)} estrae la prima richiesta di connessione nella coda in attesa del socket \ttt{sockfd}, creando un nuovo socket con connessione associato alla richiesta in arrivo e ritornando il suo socket descriptor.
        
        Il nuovo socket non è in ascolto, mentre la socket \ttt{sockfd} continua ad ascoltare per tutta la durata della syscall.

        \item La syscall \ttt{int connect(int sockfd,
        const struct sockaddr* addr, socklen\_t addrlen)} associa l'indirizzo \ttt{addr} ad un unnamed socket \ttt{sockfd}, ritornando il suo socket descriptor
    \end{itemize}

    \begin{framedobs}{}
        Per chiudere un socket, è sufficiente eseguire la syscall \ttt{close()} sul suo socket descriptor
    \end{framedobs}

    \begin{framedobs}{}
        Per far si che il server possa rimanere in ascolto di più client in arrivo, è necessario creare un processo figlio (o un thread) per ogni connessione stabilita, affinché il processo padre (o il thread principale) possa continuare ad accettare le connessioni in arrivo
    \end{framedobs}

    \textbf{Esempio:}

    \begin{verbatim}
    ----- File: server.c
    void main(){
        int sd = socket(AF_INET, SOCK_STREAM, 0);

        bind(sd, ...);
        listen(sd,MAX_QUEUED);

        ...     //disabilito il segnale SIGCHILD

        while (1) {
            int client_sd = accept(sd, ...);

            if (client_sd == -1){
                perror(“Errore accettando connessione dal client”);
                continue;
            }

            if (fork() == 0) { /*eseguito dal figlio */

                ...     // read/write su client_sd

                close(client_sd);
                exit(0);
            }
        }
    }

    ----- File: client.c
    void main(){
        int csd = socket(AF_INET, SOCK_STREAM,0);

        if (connect(csd, ...) != 0) {
            perror(“connessione non riuscita”);
        }

        ... /* read/write su csd

        close(csd);
    }\end{verbatim}

    \chapter{Multi-threading}

    \section{Processi e thread}

    In un'applicazione tradizionale, il programmatore definisce un \textbf{unico flusso di esecuzione (thread)} delle istruzioni. Le applicazioni \textbf{multi-thread}, invece, consentono al programmatore di definire diversi flussi di esecuzione, dove:
    \begin{itemize}
        \item Ciascun thread \textbf{condivide le strutture dati principali} dell'applicazione 
        \item Ciascun thread procede in modo \textbf{concorrente ed indipendente} dagli altri thread
        \item Il processo termina solo quando tutti i thread vengono terminati
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.55]{images/thread.png}
    \end{center}

    \textbf{Esempio:}

    \begin{itemize}
        \item Un moderno web browser potrebbe essere costituito dai seguenti thread:
        \begin{itemize}
            \item Thread principale di controllo dell'applicazione
            \item Thread per l'interazione con l'utente
            \item Thread per la visualizzazionse (rendering) delle pagine in
            formato HTML
            \item Thread per la gestione dei trasferimenti di pagine e file
            dalla rete
            \item Thread per l'esecuzione dei frammenti di script integrati
            nelle pagine Web
            \item Thread per l'esecuzione dei programmi Java, Flash, ...
        \end{itemize}
    \end{itemize}

    \quad

    
    L'uso dei thread (se utilizzati correttamente) aumenta notevolmente le \textbf{performance} di un processo per via dell'elevata presenza di \textbf{parallelismo interno} dei calcolatori moderni:
    \begin{itemize}
        \item \textbf{Direct Memory Access (DMA)}: trasferimento dati tra memoria primaria e periferiche di I/O senza intervento della CPU
        \item \textbf{Hyper-threading}: supporto a diversi thread, ciascuno con un proprio insieme di registri, alternandosi sulle unità funzionali della CPU
        \item \textbf{Multi-core}: diversi core di calcolo integrati sullo stesso chip, condividendo alcune risorse hardware (tra cui cache di II livello, MMU, ...)
        \item \textbf{Multi-processori}: diverse CPU integrate sulla stessa scheda madre
    \end{itemize}

    \begin{center}
        \includegraphics[scale=0.5]{images/thread_2.png}
    \end{center}

    Generalmente, scrivere applicazioni tradizionali (dunque \textbf{single-thread}) che sfruttino a fondo il parallelismo interno al compilatore risulta complesso.
    Tramite l'uso di applicazioni \textbf{multi-thread}, invece, ciascuno dei thread compie il proprio lavoro eseguendo un flusso di istruzioni indipendente tramite le proprie \textbf{risorse private} e cooperando con gli altri thread tramite le \textbf{risorse condivise}.

    \quad

    \begin{center}
        \begin{tabular}{l|l}
            \textbf{Risorse del processo (condivise)} & \textbf{Risorse del thread (non condivise)}\\
            \hline
            Spazio d'indirizzamento & Program counter\\
            Variabili globali & Registri\\
            File aperti & Contenuto dello stack\\
            Processi figli & Posizione nello stack\\
            Segnali in arrivo & Stato\\
            Maschera dei segnali &\\
            Handler dei segnali &
        \end{tabular}
    \end{center}

    \newpage

    Tra le \textbf{caratteristiche} delle applicazioni multi-thread, dunque, troviamo:
    \begin{itemize}
        \item \textbf{Lightweight}: sono la più piccola unità di lavoro eseguibile dalla CPU
        \item \textbf{Riduzione del tempo di risposta}: anche se un thread di un processo è bloccato in attesa di eventi, un altro thread dello stesso processo può essere eseguito dalla CPU
        \item \textbf{Migliore condivisione delle risorse}: tutti i thread dello stesso processo condividono parte delle risorse del processo stesso (strutture dati in memoria e file aperti) e la comunicazione tra thread è immediata
        \item \textbf{Migliore comunicazione}: la comunicazione tra thread è veloce in quanto i thread dello stesso processo condividono lo stesso indirizzo (e area) di
        memoria del processo a cui appartengono, rendendo ogni thread in grado di accedere e modificare i dati degli altri thread
        \item \textbf{Maggiore efficienza}: rispetto ad un'applicazione costituita da più processi cooperanti,
        un'applicazione multi-thread è più efficiente, poiché l'OS gestisce i thread più rapidamente

        (es: nei sistemi Linux-based, creare un thread richiede 1/10 del tempo richiesto per la creazione di un processo)
        \item \textbf{Maggiore scalabilità}: i thread possono sfruttare in modo implicito il parallelismo interno del calcolatore
        \item \textbf{Indipendenza}: il contenuto dei registri della CPU, la posizione e il contenuto dello stack sono privati ed indipendenti per ogni thread 
    \end{itemize}

    \quad

    \begin{frameddefn}{Kernel thread}
        Un \textbf{kernel thread} viene implementato a livello kernel (ma non necessariamente viene eseguito in kernel mode). Esso è l'unità di esecuzione più piccola in assoluto eseguibile dalla CPU e corrisponde all'astrazione definita all'interno dell'OS per \textbf{gestire un flusso di esecuzione}.
        
        Inoltre, ogni kernel thread è dotato di un \textbf{Thread Control Block (TCB)}, contenente le risorse private del thread.
    \end{frameddefn}


    \begin{frameddefn}{User thread}
        Un \textbf{user thread} viene implementato a livello utente tramite librerie e gestito come se fosse vero e proprio processo single-thread indipendente. Corrisponde al vero e proprio flusso di esecuzione indipendente dell'applicazione.

        Ogni user thread è \textbf{legato ad almeno un kernel thread}.
    \end{frameddefn}

    \begin{center}
        \begin{tabular}{l|l}
            \textbf{Kernel thread} & \textbf{User thread}\\
            \hline
            OS consapevole dei thread & OS ignaro dei thread\\
            Implementazione difficile & Implementazione facile\\
            Context switch lento & Context switch veloce\\
            Una chiamata bloccante di un thread & Una chiamata bloccante di un thread \\
            non blocca l'intero processo & blocca l'intero processo \\
        \end{tabular}
    \end{center}
    
    \begin{center}
        \begin{tabular}{ccc}
            \includegraphics[scale=0.5]{images/kernel_thread.png}
            &\qquad\;&
            \includegraphics[scale=0.5]{images/user_thread.png}
        \end{tabular}
    \end{center}

    Le modalità con cui gli user thread vengono legati ai kernel thread vengono racchiuse in \textbf{tre modelli}:
    \begin{itemize}
        \item \textbf{Modello 1 ad 1}: ogni user thread è legato ad \textbf{un proprio kernel thread}, implicando che ciascun thread possa invocare chiamate bloccanti senza bloccare tutti gli altri thread dello stesso processo.
        
        Inoltre, poiché il \textbf{kernel} si occupa della gestione e della schedulazione dei kernel thread, esso gestisce anche i vari user thread, sfruttando implicitamente il parallelismo interno al calcolatore stesso.

        \item \textbf{Modello molti ad 1}: più user thread dello stesso processo sono legati allo \textbf{stesso kernel thread}, implicando che se uno di tali thread invochi una chiamata bloccante tutti gli altri verranno a loro volta bloccati.
        
        Inoltre, in tal modo il \textbf{kernel non è coinvolto} nella gestione dei flussi dell'applicazione, la quale gestisce autonomamente gli user thread, rendendo impossibile sfruttare in modo implicito il parallelismo del calcolatore.

        \item \textbf{Modello molti a molti}: $n$ user thread dello stesso processo sono legati a $m$ kernel thread (dove $m \leq n$), ottenendo un misto dei due precedenti modelli
    \end{itemize}

    \newpage

    \section{POSIX Threads (pthreads)}

    Per realizzare un'applicazione multi-thread, generalmente il programmatore utilizza una liberia di sistema. Le API offerte da tale liberia non sono direttamente correlate con al tipologia di thread utilizzata (es: possono esistere diverse versioni di una liberia con API identiche ma thread a livello kernel o utente).

    La \textbf{libreria \ttt{<pthread.h>}} è definita dallo standard POSIX, il quale definisce le API ma non stabilisce quale debba essere la loro implementazione in uno specifico OS.
    In particolare, nei sistemi Linux-based moderni l'ultima implementazione di tale libreria (ossia Native POSIX Threads Library - NPTL) è basata sul \textbf{modello 1 ad 1}.

    Per \textbf{creare un thread}, viene fornita la funzione di liberia
    \begin{center}
        \ttt{int pthread\_create(pthread\_t* tid, const pthread\_attr\_t* attr,\\
        void* (*start\_routine)(void*), void* arg)}
    \end{center}
    dove:
    \begin{itemize}
        \item Nella variabile puntata da \ttt{tid} verrà inserito il Thread ID (TID) del thread creato
        \item Il parametro \ttt{pattr} punta ad una variabile contenente attributi e flag per la creazione del thread
        \item Il parametro \ttt{start\_routine} punta alla funzione iniziale eseguita dal thread appena la sua creazione è terminata
        \item Il parametro \ttt{arg} è un puntatore passato come argomento a \ttt{start\_routine()}
    \end{itemize}

    Per \textbf{terminare l'esecuzione di un thread}, invece, la funzione
    \[\ttt{void pthread\_exit(void* value\_ptr)}\]
    dove il parametro \ttt{value\_ptr} viene dato come \textbf{valore di ritorno} del thread (simile all'exit status di un processo).

    Tale funzione viene implicitamente invocata quando la funzione iniziale del thread termina. Inoltre, nel caso in cui venga invocata dall'\textbf{ultimo thread} di un processo, il processo stesso terminerà con \ttt{exit(0)}.

    \begin{framedobs}{}
        In Unix, la syscall \ttt{exit()} termina direttamente il processo chiamante. Nei sistemi Linux-based, invece, si ha che:
        \begin{itemize}
            \item La syscall \ttt{\_exit()} termina solo il thread in cui viene invocata
            \item La syscall \ttt{exit\_group()} termina tutti i thread di un processo
            \item La funzione \ttt{exit()} esegue in realtà \ttt{exit\_group()} invece che \ttt{\_exit()}
            \item Eseguire \ttt{return value} in \ttt{main()} equivale ad invocare \ttt{exit(value)}
            \item La funzione \ttt{pthread\_exit()} invoca al suo interno \ttt{\_exit()}
        \end{itemize}
    \end{framedobs}

    Per \textbf{attendere la terminazione di un thread} (in modo simile a come un processo padre attende un processo figlio tramite \ttt{wait()}), viene formita la funzione 
    \[\ttt{int pthread\_join(pthread\_t tid, void* pret)}\]
    dove \ttt{tid} è il TID del thread da attendere e in \ttt{pret} viene inserito il valore di ritorno passato nella chiamata \ttt{pthread\_exit()} del thread atteso.

    \begin{framedobs}{}
        A differenza di \ttt{wait()} per i processi figli, non è possibile specificare in \ttt{pthread\_join()} di attendere un thread qualsiasi 
    \end{framedobs}

    Infine, per \textbf{ottenere il TID} del thread chiamante, viene fornita la funzione
    \[\ttt{pthread\_t pthread\_self()}\]

    \textbf{Esempio:}

    \begin{verbatim}
    #include <pthread.h>

    int start(long v){
        pthread_t tid = pthread_self();     //ottieni il TID
        printf("Thread %d", tid);
        return v+1;     //il thread viene terminato automaticamente
    }

    int main(){
        int x = 3;

        pthread_t tid;
        pthread_create(&tid, 0, start, x);
        pthread_join(tid, &x);
        return x;
    }
    \end{verbatim}

    \newpage

    \begin{frameddefn}{Lightweight Process}
        Un \textbf{Lightweight Process (LWP)} è un processo che condivide alcune risorse selezionate con il proprio processo padre.

        L'implementazione dei thread nei sistemi Linux-based è basata sul concetto di LWP.
    \end{frameddefn}


    Per \textbf{creare un LWP}, viene fornita la funzione
    \[\ttt{int clone(int (*start)(void*), void* stack,  int flags, void* arg, ...)}\]
    dove:
    \begin{itemize}
        \item \ttt{start} è la funzione inziale eseguita all'avvio del nuovo LWP
        \item \ttt{stack} è l'indirizzo della cima dello stack UM del nuovo LWP. Se \ttt{stack = NULL}, il LWP creato utilizzerà una copia dello stack del padre
        \item \ttt{flags} indica quale caratteristiche copiare dal processo padre. È un bit-wise OR delle seguenti macro:
        \begin{itemize}
            \item \ttt{CLONE\_FILES}: copia i file descriptor
            \item \ttt{CLONE\_FS}: copia le informazioni relative al file system (es: la CWD)
            \item \ttt{CLONE\_SIGHAND}: copia i gestori dei segnali
            \item \ttt{CLONE\_THREAD}: il LWP creato viene inserito nello stesso gruppo thread del chiamante (dunque farà parte dello "stesso processo")
            \item \ttt{CLONE\_VM}: copia lo spazio di memoria
        \end{itemize}
        \item \ttt{arg} è l'argomento da passare in input a \ttt{start()}
    \end{itemize}

    \begin{framedobs}{}
        Eseguire una syscall \ttt{clone()} utilizzando \textbf{nessuna flag} per il parametro \ttt{flag} e \ttt{NULL} per il parametro \ttt{stack}, avrà lo stesso effetto di eseguire la syscall \ttt{fork()}.

        Eseguire, invece,  una syscall \ttt{clone()} utilizzando \textbf{tutte le flag} per il parametro \ttt{flag}, avrà lo stesso effetto di eseguire la funzione \ttt{pthread\_create()}.
    \end{framedobs}
    
    \newpage

    \section{Concorrenza tra thread}

    In una applicazione multi-thread, ciascun thread è un flusso di esecuzione in \textbf{concorrenza} con quelli degli altri thread. In particolare un sistema operativo multi-programma e pre-emptive, ciascun processo può essere interrotto da un altro processo e diversi processi o gestori di interruzione sono in esecuzione contemporaneamente.

    La coerenza delle \textbf{strutture dati private} di ciascun flusso di esecuzione è garantita dal meccanismo del context switch, mentre lo stesso non vale per le \textbf{strutture di dati condivise}.

    Per tanto, se due o più flussi di esecuzione hanno una struttura di dati in comune, la concorrenza dei flussi può determinare uno \textbf{stato della struttura non
    coerente} con la logica di ciascuno dei flussi.

    \begin{frameddefn}{Race condition}
        Una \textbf{race condition} è una situazione in lo stato della memoria condivisa tra due o più flussi di esecuzione concorrenti \textbf{dipende dall'ordine esatto degli accessi} alla memoria stessa (temporizzazione)
    \end{frameddefn}

    \textbf{Esempio:}

    \begin{itemize}
        \item Supponiamo che il flusso \#1 e il flusso \#2 condividano una variabile \ttt{counter}
        \item Ogni incremento e decremento di tale variabile prevede l'esecuzione di tre operazioni:
        
        \begin{itemize}
            \item \textbf{Load}: trasferimento del valore di \ttt{counter} dalla memoria ad un registro 
            \item \textbf{Update}: incremento o decremento del valore del registro
            \item \textbf{Store}: trasferimento del valore del registro in \ttt{counter} 
        \end{itemize}

        \item Se non vi sono controlli sull'ordine di accesso alla variabile \ttt{counter}, i due flussi potrebbero accedervi in contemporanea, ottenendo due valori separati e incoerenti
        
        \begin{center}
            \includegraphics[scale=0.5]{images/race_condition.png}
        \end{center}
    \end{itemize}

    \begin{frameddefn}{Sezione critica}
        Una \textbf{sezione critica} è una sequenza di istruzioni di un flusso di esecuzione che accede ad
        una \textbf{risorsa condivisa} e che non deve essere eseguita in modo concorrente ad un'altra sezione critica
    \end{frameddefn}

    \begin{frameddefn}{Semaforo e Mutex}
        Un \textbf{semaforo} è una struttura dati utilizzata per consentire o impedire gli accessi ad una sezione critica (e di conseguenza alla risorsa condivisa):
        \begin{itemize}
            \item Viene inizializzata una variabile intera contatore con un valore $n > 0$.
            
            Se $n > 1$, allora $n$ flussi possono accedere contemporaneamente alla risorsa condivisa.
            
            Se $n = 1$, allora solo un flusso alla volta può accedere alla risorsa condivisa. Inoltre, in tal caso definiamo tale semaforo come \textbf{Mutex (Mutual Exclusion)}

            \item Tramite la primitiva \textbf{Wait()}, un thread attende che il contatore sia positivo, per poi decrementarlo ed accedere alla risorsa condivisa.
            
            Se il semaforo è un mutex, tale primitiva viene anche detta \textbf{Lock()}.
            
            \item Tramite la primitica \textbf{Signal()}, viene incrementato il contatore (assumendo che la sezione critica abbia già smesso di utilizzare la risorsa condivisa).
            
            Se il semaforo è un mutex, tale primitiva viene anche detta \textbf{Unlock()}
        \end{itemize}
    \end{frameddefn}

    La libreria \ttt{<pthread.h>} fornisce delle funzioni per l'implementazione dei mutex:

    \begin{itemize}
        \item La funzione \ttt{int pthread\_mutex\_init(pthread\_mutex\_t* mutex, const\\ pthread\_mutexattr\_t* mutexattr)} inizializza un mutex e imposta i suoi attributi pari a \ttt{mutexattr}, i quali determinano il comportamento del semaforo quando un thread invoca un lock/unlock più volte consecutivamente:
        \begin{itemize}
            \item Se \ttt{*mutexattr = PTHREAD\_MUTEX\_NORMAL}, ogni operazione di lock blocca il thread finchè il lock precedente non viene rilasciato (creando eventuali stalli), mentre ogni operazione di unlock rilascia il semaforo e ritorna subito
            \item Se \ttt{*mutexattr = PTHREAD\_MUTEX\_RECURSIVE}, viene concesso allo stesso thread di mettere più lock (un contatore tiene conto del numero di
            lock messi), mentre ogni unlock decrementa il contatore e rilascia il semaforo quando il contatore è 0
            \item Se \ttt{*mutexattr = PTHREAD\_MUTEX\_ERRORCHECK}, viene generato un errore nel caso in cui un thread cerchi di mettere un lock ma il mutex detenga già un lock e se viene effettuato un unlock da parte di un thread che non aveva precedentemente effettuato un lock del mutex
            \item Se \ttt{mutexattr = NULL}, viene impostato \ttt{PTHREAD\_MUTEX\_NORMAL} come valore di default
        \end{itemize}
        \item La funzione \ttt{int pthread\_mutexattr\_settype(pthread\_mutexattr\_t* attr, int type)} permette di impostare \ttt{attr} pari a \ttt{PTHREAD\_MUTEX\_NORMAL}, \ttt{\\PTHREAD\_MUTEX\_RECURSIVE} o \ttt{PTHREAD\_MUTEX\_ERRORCHECK}
        \item La funzione \ttt{int pthread\_mutex\_lock(pthread\_mutex\_t* mutex)} rimane in attesa che \ttt{mutex} sia disponibile ed effettua un lock su di esso
        \item La funzione \ttt{int pthread\_mutex\_lock(pthread\_mutex\_t* mutex)} rimane in attesa che \ttt{mutex} sia disponibile ed effettua un lock su di esso
        \item La funzione \ttt{int pthread\_mutex\_trylock(pthread\_mutex\_t* mutex)} ritorna subito se è già presente un lock su \ttt{mutex}, altrimenti effettua un lock su di esso
        \item La funzione \ttt{int pthread\_mutex\_unlock(pthread\_mutex\_t* mutex)} effettua un unlock su \ttt{mutex}
        \item La funzione \ttt{int pthread\_mutex\_destroy(pthread\_mutex\_t* mutex)} elimina completamente la struttura dati
    \end{itemize}

    \textbf{Esempio:}

    \begin{verbatim}
    struct shared_resource {
        int var;
        pthread_mutex_t mutex;	
    } shared_res;

    void start(){
        pthread_t tid =; //ottieni tid

        //inizio sezione critica	
        for(int i = 0; i < 10; i++){
            pthread_mutex_lock(&shared_res.mutex);	//attesa del lock
        
            shared_res.var++;
            printf("Shared Var (Thread %d): %d\n", tid, shared_res.var);
            
            pthread_mutex_unlock(&shared_res.mutex);	//rilascio lock

            sleep(1);   //assicura che l'altro thread
                        //prenda il controllo della CPU
        }
    }

    void main(){
        pthread_t t1, t2;

        shared_res.var = 0;					//inizializzazione variabile condivisa
        pthread_mutex_init(&shared_res.mutex, NULL);		//creazione mutex
        
        pthread_create(&t1, NULL, start, NULL);     //avvia thread 1
        pthread_create(&t2, NULL, start, NULL);     //avvia thread 2
        pthread_join(t1, NULL);     //attendi thread 1
        pthread_join(t2, NULL);     //attendi thread 2

        pthread_mutex_destroy(&shared_res.mutex);
    }\end{verbatim}

    \newpage

    \section{Sincronizzazione tra thread}

    \begin{frameddefn}{Barriera}
        Una \textbf{barriera} è una struttura dati utilzzata per \textbf{bloccare momentaneamente} il flusso di esecuzione di $n$ processi o thread \textbf{finché tutti i thread partecipanti non hanno raggiunto la barriera}:
        \begin{itemize}
            \item Viene inizializzata una variabile intera contatore con valore $n > 0$
            \item Tramite la primitva \textbf{Wait()}, il thread chiamante raggiunge la barriera (il contatore viene decrementato) e rimane in attesa che $n = 0$
            \item Se $n = 0$, la barriera viene \textbf{superata} e tutti i thread in attesa vengono sbloccati e $n$ viene \textbf{ripristinato al valore iniziale}
        \end{itemize}
    \end{frameddefn}

    \textbf{Esempio:}

    \begin{itemize}
        \item Supponiamo che il flusso \#1, il flusso \#2 e il flusso \#3 condividano una barriera
        \item Se il flusso \#1 esegue la primitiva Wait(), esso rimarrà in attesa che tutti i thread rimanenti raggiungano la barriera (ossia finché  anche il flusso \#2 e \#3 non avranno eseguito la primiiva Wait())
        \item Se anche il flusso \#2 esegue la primitiva, i due flussi in attesa verranno sbloccati solo quando il flusso \#3 eseguirà Wait()
        \item Quando tutti e tre i flussi hanno eseguito Wait(), la barriera viene superata ed essi vengono tutti sbloccati
    \end{itemize}

    \quad

    La liberia \ttt{<pthread.h>} fornisce le seguenti funzioni per l'implementazione delle barriere:
    \begin{itemize}
        \item La funzione \ttt{int pthread\_barrier\_init(pthread\_barrier\_t* barrier, const pthread\_barrierattr\_t* attr, unsigned int count)} crea una nuova barriera con attributi \ttt{attr} per \ttt{count} thread
        
        Se \ttt{attr = NULL}, vengono impostati gli attributi di default

        \item La funzione \ttt{int pthread\_barrier\_wait(pthread\_barrier\_t* barrier)} permette al thread chiamante di raggiungere la barriera
        
        Quando la barriera viene superata, viene restituito \ttt{PTHREAD\_BARRIER\_SERIAL\_THREAD} ad un thread in attesa sulla barriera selezionato casualmente, mentre viene restituito 0 a tutti gli altri thread in attesa 

        \item La funzione \ttt{int pthread\_barrier\_destroy(pthread\_barrier\_t* barrier)} elimina completamente la struttura dati
        
    \end{itemize}

    \newpage

    \textbf{Esempio:}

    \begin{verbatim}
    pthread_barrier_t brr;

    void do_stuff(){
        sleep(1);	
        pthread_barrier_wait(&brr);
        printf("Barriera superata (Thread %d)\n", pthread_self());
    }

    void do_longer_stuff_2(){
        sleep(3);
        pthread_barrier_wait(&brr);
        printf("Barriera superata (Thread %d)\n", pthread_self());
    }

    void main(){
        pthread_t t1, t2;

        pthread_barrier_init(&brr, NULL, 2);
        
        pthread_create(&t1, NULL, do_stuff, NULL);
        pthread_create(&t2, NULL, do_longer_stuff, NULL);
        pthread_join(t1, NULL);
        pthread_join(t2, NULL);

        pthread_barrier_destroy(&brr);
    }
    \end{verbatim}


    \quad

    \section{Condizioni tra thread}

    \begin{frameddefn}{Condizione}
        Una \textbf{condizione} è una struttura dati utilizzata per \textbf{bloccare momentaneamente} il flusso di esecuzione di un processo finché un \textbf{predicato non è verificato}:
        \begin{itemize}
            \item Tramite la primitiva \textbf{Wait()}, il thread chiamante viene messo in attesa
            \item Tramite la primitiva \textbf{Signal()} permette di risvegliare un thread specifico tra quelli in attesa
            \item Tramite la primitiva \textbf{Broadcast()} risveglia tutti i thread in attesa
        \end{itemize}
    \end{frameddefn}

    \newpage

    \textbf{Esempio}:

    \begin{itemize}
        \item Supponiamo che il flusso \#1 e il flusso \#2 condividano una condizione
        \item Se il flusso \#1 esegue la primitiva Wait(), esso rimarrà in attesa che venga eseguita la primitva Signal() su di esso (o Broadcast()) da parte del flusso \#2 
    \end{itemize}


    \begin{framedobs}{}
        Una condizione deve essere \textbf{sempre associata ad un mutex}, in modo da evitare race condition sulla condizione stessa

        (es: un thread esegue Wait() sulla condizione ed un altro thread esegue Signal() sulla condizione prima che il primo thread venga effettivamente messo in attesa)
    \end{framedobs}

    La liberia \ttt{<pthread.h>} fornisce le seguenti funzioni per l'implementazione delle condizioni:

    \begin{itemize}
        \item La funzione \ttt{int pthread\_cond\_init(pthread\_cond\_t* cond, pthread\_condattr\_t* attr)} crea una nuova condizione con attributi \ttt{attr}.

        Se \ttt{attr = NULL}, vengono impostati gli attributi di default

        \item La funzione \ttt{int pthread\_cond\_signal(pthread\_cond\_t* cond)} risveglia un thread casuale tra quelli in attesa della condizione
        
        \item La funzione \ttt{int pthread\_cond\_broadcast(pthread\_cond\_t* cond)} risveglia tutti i thread in attesa della condizione
        
        \item La funzione \ttt{int pthread\_cond\_wait(pthread\_cond\_t* cond, pthread\_mutex\_t* mutex)} esegue unlock su \ttt{mutex} e attende di essere sbloccato da un altro thread, eseguendo automaticamente lock su \ttt{mutex} dopo essere stato sbloccato.
        
        \textbf{Attenzione:} il thread chiamante deve aver prima eseguito lock su \ttt{mutex}

        \item La funzione \ttt{int pthread\_cond\_destroy(pthread\_cond\_t* cond)} elimina completamente la struttura dati
    \end{itemize}
\end{document}
